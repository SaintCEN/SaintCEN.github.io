<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="数据结构（C语言版）, Sa1ntCHENの小窝">
    <meta name="description" content="Data Structure
线性表
顺序表
#define MAXSIZE 100

typedef int ElemType;
typedef struct &amp;#123;
    ElemType *elem;
    int l">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>数据结构（C语言版） | Sa1ntCHENの小窝</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    
    <style>
        body{
            background-image: url(/medias/bg.jpg);
            background-repeat: no-repeat;
            background-size: 100% 100%;
            background-attachment: fixed;
            background-position: center center;
        }
    </style>


    
    <!-- bg-cover style     -->



        <link rel="stylesheet" type="text/css"
            href="/libs/awesome/css/all.min.css">
        <link rel="stylesheet" type="text/css"
            href="/libs/materialize/materialize.min.css">
        <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
        <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
        <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.10.0/css/lightgallery.css">
        <link rel="stylesheet" type="text/css" href="/css/matery.css">
        <link rel="stylesheet" type="text/css" href="/css/my.css">
        <link rel="stylesheet" type="text/css" href="/css/dark.css"
            media="none" onload="if(media!='all')media='all'">

        


    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">



            
    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    


    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 8.0.0"><link rel="alternate" href="/atom.xml" title="Sa1ntCHENの小窝" type="application/atom+xml">
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Sa1ntCHENの小窝</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Sa1ntCHENの小窝</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/SaintCEN" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #1976D2;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/SaintCEN" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    

<div class="bg-cover pd-header post-cover">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">数据结构（C语言版）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/CS%E5%9F%BA%E7%A1%80/">
                                <span class="chip bg-color">CS基础</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E7%AC%94%E8%AE%B0/" class="post-category">
                                笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2025-09-26
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="data-structure">Data Structure</h1>
<h2 id="线性表">线性表</h2>
<h3 id="顺序表">顺序表</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">#define MAXSIZE 100

typedef int ElemType;
typedef struct &#123;
    ElemType *elem;
    int length;
&#125; Sqlist;

&#x2F;&#x2F;初始化
void InitList(Sqlist &amp;L) &#123;
    L.elem &#x3D; new ElemType[MAXSIZE];
    if (!L.elem) return;
    L.length &#x3D; 0;
&#125;

&#x2F;&#x2F;取值
void GetElem(Sqlist L, int i, ElemType &amp;e) &#123;
    if (i &lt; 1 || i &gt; L.length) return;
    e &#x3D; L.elem[i - 1];
&#125;

&#x2F;&#x2F;定位
int LocateElem(Sqlist L, ElemType e) &#123;
    for (int i &#x3D; 0; i &lt; L.length; i++) &#123;
        if (L.elem[i] &#x3D;&#x3D; e) return i + 1;
    &#125;
    return 0;
&#125;

&#x2F;&#x2F;插入
void InsertElem(Sqlist &amp;L, int i, ElemType e) &#123;
    if (i &lt; 1 || i &gt; L.length + 1) return;
    if (L.length &#x3D;&#x3D; MAXSIZE) return;
    for (int j &#x3D; L.length - 1; j &gt;&#x3D; i - 1; j--) &#123;
        L.elem[j + 1] &#x3D; L.elem[j];
    &#125;
    L.elem[i - 1] &#x3D; e;
    L.length++;
&#125;

&#x2F;&#x2F;删除
void DeleteElem(Sqlist &amp;L, int i) &#123;
    if (i &lt; 1 || i &gt; L.length) return;
    for (int j &#x3D; i; j &lt; L.length; j++) &#123;
        L.elem[j - 1] &#x3D; L.elem[j];
    &#125;
    L.length--;
&#125;</code></pre>
<h3 id="单链表">单链表</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;

typedef int ElemType;
typedef struct Node &#123;
    ElemType data;
    struct Node* next;
&#125;Node,*LinkList;

&#x2F;&#x2F; 初始化(带头结点)
void InitList(LinkList &amp;L) &#123;
    L &#x3D; (Node*)malloc(sizeof(Node));
    L-&gt;next &#x3D; NULL;
    &#x2F;&#x2F;若不带头结点，直接L &#x3D; NULL;
&#125;

&#x2F;&#x2F; 求表长
int Length(LinkList L)&#123;
    int len &#x3D; 0;
    Node *p &#x3D; L;
    while(p-&gt;next!&#x3D;NULL)&#123;
        p &#x3D; p-&gt;next;
        len++;
    &#125;
    return len;
&#125;

&#x2F;&#x2F; 取值
void GetElem(LinkList L, int i, ElemType &amp;e) &#123;
    Node* p &#x3D; L;
    int j &#x3D; 0;
    while (p &amp;&amp; j &lt; i) &#123;
        p &#x3D; p-&gt;next;
        j++;
    &#125;
    if (!p || j &gt; i) return;
    e &#x3D; p-&gt;data;
&#125;

&#x2F;&#x2F; 查找
Node* LocateNode(LinkList L, ElemType e) &#123;
    Node* p &#x3D; L-&gt;next;
    while (p &amp;&amp; p-&gt;data !&#x3D; e) &#123;
        p &#x3D; p-&gt;next;
    &#125;
    return p;
&#125;

&#x2F;&#x2F;插入
void insertNode(LinkList &amp;L, int i, ElemType e) &#123;
    Node* p &#x3D; L;
    int j &#x3D; 0;
    while (p &amp;&amp; j &lt; i - 1) &#123;
        p &#x3D; p-&gt;next;
        j++;
    &#125;
    if (!p) return;
    Node* s &#x3D; new Node;
    s-&gt;data &#x3D; e;
    s-&gt;next &#x3D; p-&gt;next;
    p-&gt;next &#x3D; s;
&#125;

&#x2F;&#x2F;删除
void deleteNode(LinkList &amp;L, int i) &#123;
    Node* p &#x3D; L;
    int j &#x3D; 0;
    while (p &amp;&amp; j &lt; i - 1) &#123;
        p &#x3D; p-&gt;next;
        j++;
    &#125;
    if (!p-&gt;next||!p) return;
    Node* q &#x3D; p-&gt;next;
    p-&gt;next &#x3D; q-&gt;next;
    delete q;
&#125;

&#x2F;&#x2F;头插法
void createList_H(LinkList &amp;L, int n) &#123;
    L &#x3D; new Node; &#x2F;&#x2F; L固定为头结点
    L-&gt;next &#x3D; NULL;
    for (int i &#x3D; 0; i &lt; n; i++) &#123;
        Node* p &#x3D; new Node;
        cin &gt;&gt; p-&gt;data;
        p-&gt;next &#x3D; L-&gt;next;
        L-&gt;next &#x3D; p;
    &#125;
&#125;

&#x2F;&#x2F;尾插法
void createList_R(Node* &amp;L, int n) &#123;
    L &#x3D; new Node; &#x2F;&#x2F;L为固定头结点
    L-&gt;next &#x3D; NULL;
    Node* r &#x3D; L;
    for (int i &#x3D; 0; i &lt; n; i++) &#123;
        Node* p &#x3D; new Node;
        cin &gt;&gt; p-&gt;data;
        p-&gt;next &#x3D; NULL;
        r-&gt;next &#x3D; p;
        r &#x3D; p;
    &#125;
    &#x2F;&#x2F;循环列表，p-&gt;next &#x3D; L-&gt;next;
&#125;

&#x2F;&#x2F;遍历
void printlist(LinkList L)
&#123;
     Node *p &#x3D; L;
     while (p) &#123;
           printf(&quot;%d &quot;, p-&gt;data);
           p &#x3D; p-&gt;next;
     &#125;
     printf(&quot;\n&quot;);
&#125;</code></pre>
<h3 id="双链表">双链表</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;

typedef int Elemtype;

&#x2F;&#x2F; 定义双链表节点
typedef struct DNode &#123;
    Elemtype data;
    struct DNode* prior;
    struct DNode* next;
&#125; DNode, *DList;

&#x2F;&#x2F; 初始化双链表
DList initList() &#123;
    DNode* head &#x3D; new DNode();
    head-&gt;prior &#x3D; nullptr;
    head-&gt;next &#x3D; nullptr;
    return head;
&#125;

&#x2F;&#x2F; 创建双链表
void createList(DList &amp;L, int n) &#123;
    DNode* p &#x3D; L;
    for (int i &#x3D; 0; i &lt; n; i++) &#123;
        DNode* newNode &#x3D; new DNode;
        cin &gt;&gt; newNode-&gt;data;
        newNode-&gt;prior &#x3D; p;
        newNode-&gt;next &#x3D; nullptr;
        p-&gt;next &#x3D; newNode;
        p &#x3D; newNode;
    &#125;
    &#x2F;&#x2F;循环链表，newNode-&gt;next &#x3D; L-&gt;next;L-&gt;next-&gt;prior &#x3D; newNode;
&#125;

&#x2F;&#x2F; 插入操作
void insertNode(DList &amp;L, int pos, Elemtype e) &#123;
    DNode* p &#x3D; L;
    int i &#x3D; 0;
    while (p &amp;&amp; i &lt; pos) &#123;
        p &#x3D; p-&gt;next;
        i++;
    &#125;
    if (!p) &#123;
        return;
    &#125;
    DNode* newNode &#x3D; new DNode;
    newNode-&gt;data &#x3D; e;
    newNode-&gt;next &#x3D; p-&gt;next;
    newNode-&gt;prior &#x3D; p;
    if (p-&gt;next) &#123;
        p-&gt;next-&gt;prior &#x3D; newNode;
    &#125;
    p-&gt;next &#x3D; newNode;
&#125;

&#x2F;&#x2F; 删除操作
void deleteNode(DList &amp;L, int pos) &#123;
    DNode* p &#x3D; L-&gt;next;
    int i &#x3D; 0;
    while (p &amp;&amp; i &lt; pos) &#123;
        p &#x3D; p-&gt;next;
        i++;
    &#125;
    if (!p) &#123;
        return;
    &#125;
    if (p-&gt;prior) &#123;
        p-&gt;prior-&gt;next &#x3D; p-&gt;next;
    &#125;
    if (p-&gt;next) &#123;
        p-&gt;next-&gt;prior &#x3D; p-&gt;prior;
    &#125;
    delete p;
&#125;

&#x2F;&#x2F; 正向遍历
void traverseForward(DList L) &#123;
    DNode* p &#x3D; L-&gt;next;
    while (p) &#123;
        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;
        p &#x3D; p-&gt;next;
    &#125;
    cout &lt;&lt; endl;
&#125;

&#x2F;&#x2F; 反向遍历
void traverseBackward(DList L) &#123;
    DNode* p &#x3D; L;
    while (p-&gt;next) &#123;
        p &#x3D; p-&gt;next;
    &#125;
    while (p !&#x3D; L) &#123;
        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;
        p &#x3D; p-&gt;prior;
    &#125;
    cout &lt;&lt; endl;
&#125;</code></pre>
<h4 id="stl">STL</h4>
<p><strong>list</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;list&gt;
#include&lt;iostream&gt;
using namespace std;

int main()&#123;
    list&lt;int&gt; l;
    &#x2F;&#x2F; 插入元素
    l.push_back(10);
    l.push_front(5);
    &#x2F;&#x2F; 输出
    for (int val : l) &#123;
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    &#125;
    &#x2F;&#x2F; 查找元素
    auto it &#x3D; find(l.begin(), l.end(), 10);
    if (it !&#x3D; l.end()) &#123;
        cout &lt;&lt; distance(l.begin(),it) &lt;&lt; endl;
    &#125;
    &#x2F;&#x2F; 删除元素
    l.erase(l.begin());
    &#x2F;&#x2F; 反转链表
    l.reverse();
    &#x2F;&#x2F; 排序链表
    l.sort();
    &#x2F;&#x2F; 删除相邻的重复元素
    l.push_back(20);
    l.push_back(20);
    l.unique();
&#125;</code></pre>
<h3 id="静态链表">静态链表</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">typedef int ElemType;
#define MAXSIZE 50

typedef struct&#123;
    ElemType data;
    int next;&#x2F;&#x2F; 存储地址(具体数值)
&#125;SLinkList[MAXSIZE];</code></pre>
<h2 id="栈与队列">栈与队列</h2>
<h3 id="栈">栈</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

#define MAXSIZE 100

typedef int Elemtype;

&#x2F;&#x2F;顺序存储
typedef struct
&#123;
    Elemtype *top;
    Elemtype *base;
    int size;
&#125; SqStack;

void Init(SqStack &amp;s)
&#123;
    s.base &#x3D; new Elemtype[MAXSIZE];
    s.top &#x3D; s.base;
    s.size &#x3D; MAXSIZE;
&#125;

bool IsEmpty(SqStack s)
&#123;
    return s.base &#x3D;&#x3D; s.top;
&#125;

bool IsFull(SqStack s)
&#123;
    return (s.top - s.base) &#x3D;&#x3D; s.size;
&#125;

void Push(SqStack &amp;s, Elemtype e)
&#123;
    if (IsFull(s))
    &#123;
        return;
    &#125;
    *s.top &#x3D; e;
    s.top++;
&#125;

Elemtype Pop(SqStack &amp;s, Elemtype &amp;e)
&#123;
    if (IsEmpty(s))
    &#123;
        return;
    &#125;
    s.top--;
    e &#x3D; *s.top;
&#125;

void Print(SqStack &amp;s)
&#123;
    if (IsEmpty(s))
    &#123;
        return;
    &#125;
    for (Elemtype *p &#x3D; s.base; p !&#x3D; s.top; p++)
    &#123;
        cout &lt;&lt; *p &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

Elemtype GetTop(SqStack s)
&#123;
    if (IsEmpty(s))
    &#123;
        return;
    &#125;
    Elemtype e &#x3D; *s.top;
    return e;
&#125;

&#x2F;&#x2F; 链式存储
typedef struct Linknode
&#123;
    Elemtype data;
    struct Linknode *next;
&#125; Linknode, *LiStack;

void Init(LiStack &amp;s)
&#123;
    s &#x3D; NULL;
&#125;

void Push(LiStack &amp;s, Elemtype e)
&#123;
    LiStack p &#x3D; new Linknode;
    p-&gt;data &#x3D; e;
    p-&gt;next &#x3D; s;
    s &#x3D; p;
&#125;

void Pop(LiStack &amp;s, Elemtype &amp;e)
&#123;
    if (s &#x3D;&#x3D; NULL)
        return;
    e &#x3D; s-&gt;data;
    LiStack p &#x3D; s;
    s &#x3D; s-&gt;next;
    delete p;
&#125;

Elemtype GetTop(LiStack s)
&#123;
    if (s !&#x3D; NULL)
        return s-&gt;data;
    return -1;
&#125;

&#x2F;&#x2F; 共享存储
typedef struct
&#123;
    Elemtype *base;
    Elemtype *top1;
    Elemtype *top2;
    int capacity;
&#125; SharedStack;</code></pre>
<h4 id="stl-1">STL</h4>
<p><strong>stack</strong></p>
<ul>
<li><code>top()</code> 访问栈顶元素（如果栈为空，此处会出错）</li>
<li><code>push(x)</code> 向栈中插入元素 x</li>
<li><code>pop()</code> 删除栈顶元素</li>
<li><code>size()</code> 查询容器中的元素数量</li>
<li><code>empty()</code> 询问容器是否为空</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;stack&gt;
using namespace std;
int main()&#123;
stack&lt;int&gt; s1;
s1.push(2);
s1.push(1);
cout &lt;&lt; s1.size() &lt;&lt; endl;
s1.pop();
s1.pop();
cout &lt;&lt; s1.empty() &lt;&lt; endl;
&#125;</code></pre>
<h3 id="队列">队列</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;

#define maxsize 100

typedef int ElemType;
typedef struct &#123;
    ElemType *base;
    int front;
    int rear;
&#125; SqQueue;&#x2F;&#x2F; 可作为单向队列或循环队列，这里视为循环队列

&#x2F;&#x2F; 初始化
void InitQueue(SqQueue &amp;q) &#123;
    q.base &#x3D; new ElemType[maxsize];
    if (!q.base) &#123;
        return;
    &#125;
    q.front &#x3D; 0;
    q.rear &#x3D; 0;
&#125;

&#x2F;&#x2F; 长度
int QueueLength(SqQueue q) &#123;
    return (q.rear - q.front + maxsize) % maxsize;
&#125;

&#x2F;&#x2F; 判断是否为空
bool IsEmpty(SqQueue q) &#123;
    return q.front &#x3D;&#x3D; q.rear;
&#125;

&#x2F;&#x2F; 判断是否已满
bool IsFull(SqQueue q) &#123;
    return (q.rear + 1) % maxsize &#x3D;&#x3D; q.front;
&#125;

&#x2F;&#x2F; 入队
void EnQueue(SqQueue &amp;q, ElemType e) &#123;
    if (IsFull(q)) &#123;
        return;
    &#125;
    q.base[q.rear] &#x3D; e;
    q.rear &#x3D; (q.rear + 1) % maxsize;
&#125;

&#x2F;&#x2F; 出队
void DeQueue(SqQueue &amp;q, ElemType &amp;e) &#123;
    if (IsEmpty(q)) &#123;
        return;
    &#125;
    e &#x3D; q.base[q.front];
    q.front &#x3D; (q.front + 1) % maxsize;
&#125;

&#x2F;&#x2F; 获取队头元素
ElemType GetHead(SqQueue q) &#123;
    if (!IsEmpty(q)) &#123;
        return q.base[q.front];
    &#125;
    return -1;
&#125;

&#x2F;&#x2F; 打印
void PrintQueue(SqQueue q) &#123;
    if (IsEmpty(q)) &#123;
        return;
    &#125;
    int i &#x3D; q.front;
    while (i !&#x3D; q.rear) &#123;
        cout &lt;&lt; q.base[i] &lt;&lt; &quot; &quot;;
        i &#x3D; (i + 1) % maxsize;
    &#125;
    cout &lt;&lt; endl;
&#125;

&#x2F;&#x2F; 队列链式存储(带头结点)
&#x2F;&#x2F; 节点定义
typedef struct QNode&#123;
    ElemType data;
    struct QNode *next;
&#125;QNode;

&#x2F;&#x2F; 链队列定义
typedef struct &#123;
    QNode *front;
    QNode *rear;
&#125;LinkQueue;

&#x2F;&#x2F; 初始化队列
void InitQueue(LinkQueue &amp;Q) &#123;
    Q.front &#x3D; new QNode;
    Q.rear &#x3D; Q.front;
    Q.front-&gt;next &#x3D; NULL;
&#125;

&#x2F;&#x2F; 判断为空
bool IsEmpty(LinkQueue Q)&#123;
    return (Q.front &#x3D;&#x3D; Q.rear);
&#125;

&#x2F;&#x2F; 入队操作
void EnQueue(LinkQueue &amp;Q, ElemType e) &#123;
    QNode *newNode &#x3D; new QNode;
    newNode-&gt;data &#x3D; e;
    newNode-&gt;next &#x3D; NULL;
    Q.rear-&gt;next &#x3D; newNode;
    Q.rear &#x3D; newNode;
&#125;

&#x2F;&#x2F; 出队操作
void DeQueue(LinkQueue &amp;Q, ElemType &amp;e) &#123;
    if (IsEmpty(Q)) &#123;
        return;
    &#125;

    QNode *temp &#x3D; Q.front-&gt;next;
    e &#x3D; temp-&gt;data;
    Q.front-&gt;next &#x3D; temp-&gt;next;

    if (temp &#x3D;&#x3D; Q.rear) &#123;
        Q.rear &#x3D; Q.front;
    &#125;
    delete temp;
&#125;

&#x2F;&#x2F; 获取队头元素
ElemType GetFront(LinkQueue Q) &#123;
    if (IsEmpty(Q)) &#123;
        return -1;
    &#125;
    return Q.front-&gt;next-&gt;data;
&#125;</code></pre>
<h4 id="stl-2">STL</h4>
<p><strong>queue</strong></p>
<ul>
<li><code>front()</code> 访问队首元素（如果队列为空，此处会出错）</li>
<li><code>push(x)</code> 向队列中插入元素 x</li>
<li><code>pop()</code> 删除队首元素</li>
<li><code>size()</code> 查询容器中的元素数量</li>
<li><code>empty()</code> 询问容器是否为空</li>
</ul>
<p><strong>deque</strong></p>
<ul>
<li><code>push_front(x)</code> 在队首插入元素 x</li>
<li><code>push_back(x)</code> 在队尾插入元素 x</li>
<li><code>pop_front()</code> 删除队首元素</li>
<li><code>pop_back()</code> 删除队尾元素</li>
<li><code>front()</code> 访问队首元素</li>
<li><code>back()</code> 访问队尾元素</li>
<li><code>size()</code> 查询元素数量</li>
<li><code>empty()</code> 判断是否为空</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;queue&gt;
#include&lt;iostream&gt;
using namespace std;

int main()&#123;
&#x2F;&#x2F; 单向队列
queue&lt;int&gt; q1;
q1.push(2);
q1.push(1);
q1.pop();
cout &lt;&lt; q1.size() &lt;&lt; endl;
cout &lt;&lt; q1.front() &lt;&lt; endl;
q1.pop();
cout &lt;&lt; q1.empty() &lt;&lt; endl;
&#x2F;&#x2F; 双向队列
deque&lt;int&gt; dq;
dq.push_back(3);
dq.push_front(1);
dq.pop_front();
dq.push_front(5);
dq.pop_back();
dq.pop_back();
cout &lt;&lt; dq.size() &lt;&lt; endl;
cout &lt;&lt; dq.empty() &lt;&lt; endl;
&#125;</code></pre>
<h4 id="优先队列priority_queue">优先队列(priority_queue)</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 默认最小堆(原理其实是构建完全二叉树进行堆排序，因此初始化时有数组和比较条件)
priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq
&#x2F;&#x2F; 自定义堆
struct cmp &#123;
    bool operator()(int a, int b) &#123;
        return a &lt; b; &#x2F;&#x2F; 最大堆
    &#125;
&#125;;
priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; pq;
&#x2F;&#x2F; 插入元素
int element &#x3D; 1;
pq.push(element);
&#x2F;&#x2F; 访问顶部元素
int top &#x3D; pq.top();
&#x2F;&#x2F; 删除顶部元素
pq.pop();
&#x2F;&#x2F; 检查是否为空
bool isEmpty &#x3D; pq.empty();
&#x2F;&#x2F; 获取元素数量
size_t size &#x3D; pq.size();</code></pre>
<h3 id="数组">数组</h3>
<p>以二维数组为例：</p>
<p><span class="math display"><em>L</em><em>O</em><em>C</em>(<em>i</em>, <em>j</em>) = <em>L</em><em>O</em><em>C</em>(0, 0) + (<em>n</em> * <em>i</em> + <em>j</em>) * <em>L</em></span></p>
<p>其中<span class="math inline"><em>L</em></span>为每个数组元素所占的单元。</p>
<p><strong>特殊矩阵的压缩存储</strong></p>
<p>1.对称矩阵</p>
<p>对于 n 阶矩阵 A，若<span class="math inline"><em>a</em><sub><em>i</em>, <em>j</em></sub> = <em>a</em><sub><em>j</em>, <em>i</em></sub></span>，则为对称矩阵。假设我们要压缩成一维数组，求解下标<span class="math inline"><em>k</em></span>有以下公式：</p>
<p><span class="math display">$$
i&gt;=j,k = \frac{i(i-1)}{2}+j-1\\i&lt;j,k = \frac{j(j-1)}{2}+i-1\\
$$</span></p>
<p>2.三角矩阵</p>
<p><span class="math display">$$
上三角：i&gt;j,k =
\frac{n(n+1)}{2},i&lt;=j,\frac{(2n-i+2)(i-1)}{2}+j-i\\
下三角：i&gt;j,k = \frac{i(i-1)}{2}+j-1,i&lt;=j,\frac{n(n+1)}{2}
$$</span></p>
<p>3.带状矩阵</p>
<p>第 1 行和第 n
行有两个元，其余行均有三个元，（形成三条对角线），对<span class="math inline"><em>a</em><sub><em>i</em>, <em>j</em></sub></span>若压缩成一维矩阵有：</p>
<p><span class="math display"><em>k</em> = 2<em>i</em> + <em>j</em> − 3</span></p>
<p>4.稀疏矩阵</p>
<p>将稀疏分布的矩阵转为三元组（行标<span class="math inline"><em>i</em></span>，列标<span class="math inline"><em>j</em></span>，值<span class="math inline"><em>a</em><sub><em>i</em>, <em>j</em></sub></span>）</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">typedef struct&#123;
    int col;
    int row;
    int data;
&#125;Matrix;</code></pre>
<h4 id="stl-3">STL</h4>
<p><strong>vector</strong></p>
<ul>
<li><p><code>push_back(x)</code> 在尾部插入元素 x</p></li>
<li><p><code>pop_back()</code> 删除尾部元素</p></li>
<li><p><code>front()</code> 访问首元素</p></li>
<li><p><code>back()</code> 访问尾元素</p></li>
<li><p><code>size()</code> 查询元素数量</p></li>
<li><p><code>empty()</code> 判断是否为空</p></li>
<li><p><code>clear()</code> 清空所有元素</p></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;vector&gt;
#include&lt;iostream&gt;
using namespace std;

int main()&#123;
vector&lt;int&gt; vec;
vec.push_back(1);
vec.push_back(2);
vec.pop_back();
vec.push_back(3);

cout &lt;&lt; vec.size() &lt;&lt; endl;
cout &lt;&lt; vec.front() &lt;&lt; endl;
cout &lt;&lt; vec.back() &lt;&lt; endl;
cout &lt;&lt; vec[1] &lt;&lt; endl;

vec.clear();
cout &lt;&lt; vec.empty() &lt;&lt; endl;

vector&lt;vector&lt;int&gt;&gt; matrix(3, vector&lt;int&gt;(2, 0));&#x2F;&#x2F; 3行，2列，每行填充0
matrix[0][0] &#x3D; 1;
matrix[1].push_back(3);
vector&lt;int&gt; new_row &#x3D; &#123;5, 7, 9&#125;;
matrix.push_back(new_row);
for (int i &#x3D; 0; i &lt; matrix.size(); i++) &#123;
    for (int j &#x3D; 0; j &lt; matrix[i].size(); j++) &#123;
          cout &lt;&lt; matrix[i][j] &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;
&#125;</code></pre>
<h2 id="串">串</h2>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

#define maxlen 255

&#x2F;&#x2F; 顺序存储
typedef struct&#123;
    char ch[maxlen];
    int length;
&#125;SString;

&#x2F;&#x2F; 堆分配存储
typedef struct&#123;
    char *ch;
    int length;
&#125;HString;

&#x2F;&#x2F; 链式存储
typedef struct CharNode &#123;
    char ch;
    struct CharNode *next;
&#125; CharNode, *CharPtr;

typedef struct &#123;
    CharPtr head;
    int length;
&#125; LString;

&#x2F;&#x2F; 字串定位算法
&#x2F;&#x2F; Brute-Force
int BF(SString s,SSting t,int pos)&#123;
    int i &#x3D; pos;
    int j &#x3D; 1;
    while(i&lt;&#x3D;s.length &amp;&amp; j&lt;&#x3D;t.length())&#123;
        if(s.ch[i]&#x3D;&#x3D;t.ch[j])&#123;
            i++;
            j++;
        &#125;
            else&#123;
                i &#x3D; i - j + 2;
                j &#x3D; 1;
        &#125;
    &#125;
   if(j&gt;t.length) return i-t.length;
   else return 0;
&#125;

&#x2F;&#x2F; KMP
vector&lt;int&gt; Next(const string &amp;j) &#123;
    int m &#x3D; j.length();
    vector&lt;int&gt; next(m + 1, 0);
    int k &#x3D; 0;
    next[0] &#x3D; -1;
    for (int i &#x3D; 1; i &lt; m; i++) &#123;
        while (k &gt;&#x3D; 0 &amp;&amp; j[i] !&#x3D; j[k]) &#123;
            k &#x3D; next[k];
        &#125;
        k++;
        next[i + 1] &#x3D; k;
    &#125;
    return next;
&#125;

void KMP(const string &amp;t, const string &amp;j) &#123;
    int n &#x3D; t.length();
    int m &#x3D; j.length();
        return;
    &#125;
    vector&lt;int&gt; next &#x3D; Next(j);
    int i &#x3D; 0;
    int k &#x3D; 0;
    while (i &lt; n) &#123;
        if (k &#x3D;&#x3D; -1 || t[i] &#x3D;&#x3D; j[k]) &#123;
            i++;
            k++;
            if (k &#x3D;&#x3D; m) &#123;
                cout &lt;&lt; t.substr(i - m) &lt;&lt; endl;
                return;
            &#125;
        &#125; else &#123;
            k &#x3D; next[k];
        &#125;
    return;
&#125;</code></pre>
<h4 id="stl-4">STL</h4>
<p><strong>string</strong></p>
<p>长度：<code>s.size()</code>/<code>s.length()</code></p>
<p>查找字符（串）第一次出现的位置：<code>s.find(u)</code>/<code>s.find(t,pos)</code>
<strong>注：不是 KMP</strong></p>
<p>截取子串：<code>substr(pos,len)</code></p>
<p>插入：<code>insert(index,str)</code></p>
<p>替换字符串：<code>replace(first,second,str)</code></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main()&#123;
string s &#x3D; &quot;hello, world&quot;;
cout &lt;&lt; s.size() &lt;&lt; endl;
size_t pos1 &#x3D; s.find(&#39;o&#39;);
size_t pos2 &#x3D; s.find(&quot;world&quot;, 0);
string sub &#x3D; s.substr(7, 5);
string s2 &#x3D; s;
s2.insert(5, &quot; C++&quot;);
string s3 &#x3D; s;
s3.replace(0, 5, &quot;Hi&quot;);
&#125;</code></pre>
<h3 id="广义表">广义表</h3>
<pre class="language-c++" data-language="c++"><code class="language-c++">typedef enum(ATOM,LIST) ElemTag;&#x2F;&#x2F;ATOM&#x3D;&#x3D;0,原子；LIST&#x3D;&#x3D;1，子表
typedef struct GLNode
&#123;
    ElemTag tag;&#x2F;&#x2F;区分原子结点or表结点
    union&#123;
        AtomType atom;&#x2F;&#x2F;原子值域
        struct&#123;
            struct GNode* hp,*tp;
        &#125;ptr;
    &#125;;
&#125;*GList;
GetHead(LS);&#x2F;&#x2F;取表头
GetTail(LS);&#x2F;&#x2F;取表尾，仍为广义表</code></pre>
<h2 id="树">树</h2>
<h4 id="二叉树">二叉树</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;

#define MAXSIZE 100

typedef int TElemType;

&#x2F;&#x2F; 顺序存储结构（即层序遍历，空结点值为0）
typedef struct&#123;
    TElemType data[MAXSIZE];
&#125;SqBiTree;

&#x2F;&#x2F; 链式定义结点结构
typedef struct BiTNode &#123;
    TElemType data;
    BiTNode *lchild, *rchild;
&#125; BiTNode, *BiTree;

&#x2F;&#x2F; 中序遍历（递归）
void InOrderTraverse(BiTree T) &#123;
    if (T) &#123;
        InOrderTraverse(T-&gt;lchild);
        cout &lt;&lt; T-&gt;data;
        InOrderTraverse(T-&gt;rchild);
    &#125;
&#125;

&#x2F;&#x2F; 先序遍历（递归）
void PreOrderTraverse(BiTree T) &#123;
    if (T) &#123;
        cout &lt;&lt; T-&gt;data;
        PreOrderTraverse(T-&gt;lchild);
        PreOrderTraverse(T-&gt;rchild);
    &#125;
&#125;

&#x2F;&#x2F; 后序遍历（递归）
void PostOrderTraverse(BiTree T) &#123;
    if (T) &#123;
        PostOrderTraverse(T-&gt;lchild);
        PostOrderTraverse(T-&gt;rchild);
        cout &lt;&lt; T-&gt;data;
    &#125;
&#125;

&#x2F;&#x2F; 中序遍历（非递归）
void InOrderTraverse_NonRecursive(BiTree T) &#123;
    stack&lt;BiTree&gt; s;
    BiTree p &#x3D; T;
    while (p || !s.empty()) &#123;
        if (p) &#123;
            s.push(p);
            p &#x3D; p-&gt;lchild;
        &#125; else &#123;
            BiTree q &#x3D; s.top();
            s.pop();
            cout &lt;&lt; q-&gt;data;
            p &#x3D; q-&gt;rchild;
        &#125;
    &#125;
&#125;

&#x2F;&#x2F; 先序遍历（非递归）
void PreOrderTraverse_NonRecursive(BiTree T) &#123;
    if (!T) return;
    stack&lt;BiTree&gt; s;
    s.push(T);
    while (!s.empty()) &#123;
        BiTree q &#x3D; s.top();
        s.pop();
        cout &lt;&lt; q-&gt;data;
        if (q-&gt;rchild) s.push(q-&gt;rchild); &#x2F;&#x2F; 右子树后访问 根据栈先进后出的原则先进
        if (q-&gt;lchild) s.push(q-&gt;lchild);
    &#125;
&#125;

&#x2F;&#x2F; 后序遍历（非递归）
void PostOrderTraverse_NonRecursive(BiTree T) &#123;
    stack&lt;BiTree&gt; s;
    BiTree p &#x3D; T;
    BiTree lastVisited &#x3D; nullptr;
    while (p || !s.empty()) &#123;
        if (p) &#123;
            s.push(p);
            p &#x3D; p-&gt;lchild;
        &#125; else &#123;
            BiTree q &#x3D; s.top();
            if (q-&gt;rchild &amp;&amp; lastVisited !&#x3D; q-&gt;rchild) &#123;
                p &#x3D; q-&gt;rchild;
            &#125; else &#123;
                cout &lt;&lt; q-&gt;data;
                lastVisited &#x3D; q;
                s.pop();
            &#125;
        &#125;
    &#125;
&#125;

&#x2F;&#x2F; 层次遍历二叉树
void LevelOrderTraverse(BiTree T) &#123;
    if (!T) return;
    queue&lt;BiTree&gt; q;
    q.push(T);
    while (!q.empty()) &#123;
        BiTree node &#x3D; q.front();
        q.pop();
        cout &lt;&lt; node-&gt;data &lt;&lt; &#39; &#39;;
        if (node-&gt;lchild)
            q.push(node-&gt;lchild);
        if (node-&gt;rchild)
            q.push(node-&gt;rchild);
    &#125;
&#125;

&#x2F;&#x2F; 根据前序输入创建二叉树，&#39;#&#39;表示空节点
void CreateBiTree(BiTree &amp;T) &#123;
    char ch;
    cin &gt;&gt; ch;
    if (ch &#x3D;&#x3D; &#39;#&#39;) &#123;
        T &#x3D; nullptr;
    &#125; else &#123;
        T &#x3D; new BiTNode;
        T-&gt;data &#x3D; ch;
        CreateBiTree(T-&gt;lchild);
        CreateBiTree(T-&gt;rchild);
    &#125;
&#125;

&#x2F;&#x2F; 根据中序输入创建二叉树，&#39;#&#39;表示空节点
void CreateBiTree(BiTree &amp;T) &#123;
    char ch;
    cin &gt;&gt; ch;
    if (ch &#x3D;&#x3D; &#39;#&#39;) &#123;
        T &#x3D; nullptr;
    &#125; else &#123;
        CreateBiTree(T-&gt;lchild);
        T &#x3D; new BiTNode;
        T-&gt;data &#x3D; ch;
        CreateBiTree(T-&gt;rchild);
    &#125;
&#125;

&#x2F;&#x2F; 根据后序输入创建二叉树，&#39;#&#39;表示空节点
void CreateBiTree(BiTree &amp;T) &#123;
    char ch;
    cin &gt;&gt; ch;
    if (ch &#x3D;&#x3D; &#39;#&#39;) &#123;
        T &#x3D; nullptr;
    &#125; else &#123;
        CreateBiTree(T-&gt;lchild);
        CreateBiTree(T-&gt;rchild);
        T &#x3D; new BiTNode;
        T-&gt;data &#x3D; ch;
    &#125;
&#125;

&#x2F;&#x2F; 计算二叉树的高度
int Depth(BiTree T) &#123;
    if (!T) return 0;
    int m &#x3D; Depth(T-&gt;lchild);
    int n &#x3D; Depth(T-&gt;rchild);
    return (m &gt; n ? m + 1 : n + 1);
&#125;

&#x2F;&#x2F; 统计二叉树的节点个数
int NodeCount(BiTree T) &#123;
    if (!T) return 0;
    return NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + 1;
&#125;

&#x2F;&#x2F; 线索二叉树的结点结构
typedef struct BiThrNode &#123;
    TElemType data;
    BiThrNode *lchild, *rchild;
    int LTag, RTag; &#x2F;&#x2F; 0 表示指针，1 表示线索
&#125; BiThrNode, *BiThrTree;

&#x2F;&#x2F; 全局变量，用于中序线索化过程中的前驱节点
BiThrNode *pre &#x3D; nullptr;

&#x2F;&#x2F; 中序线索化（递归）
void InThreading(BiThrTree p) &#123;
    if (p) &#123;
        InThreading(p-&gt;lchild);
        if (!p-&gt;lchild) &#123;
            p-&gt;LTag &#x3D; 1;
            p-&gt;lchild &#x3D; pre;
        &#125; else &#123;
            p-&gt;LTag &#x3D; 0;
        &#125;
        if (pre &amp;&amp; !pre-&gt;rchild) &#123;
            pre-&gt;RTag &#x3D; 1;
            pre-&gt;rchild &#x3D; p;
        &#125; else if &#123;
            pre-&gt;RTag &#x3D; 0;
        &#125;
        pre &#x3D; p;
        InThreading(p-&gt;rchild);
    &#125;
&#125;

&#x2F;&#x2F; 构建中序线索二叉树（带头结点）
void CreateInOrderThread(BiThrTree &amp;T) &#123;
    BiThrTree head &#x3D; new BiThrNode;
    head-&gt;LTag &#x3D; 0;
    head-&gt;RTag &#x3D; 1;
    head-&gt;rchild &#x3D; head;
    pre &#x3D; head;
    head-&gt;lchild &#x3D; T;
    InThreading(T);
    pre-&gt;rchild &#x3D; head;
    pre-&gt;RTag &#x3D; 1;
    T &#x3D; head;
&#125;

&#x2F;&#x2F; 遍历中序线索二叉树（非递归）
void InOrderTraverse_Thr(BiThrTree T) &#123;
    BiThrTree p &#x3D; T-&gt;lchild;
    while (p !&#x3D; T) &#123;
        while (p-&gt;LTag &#x3D;&#x3D; 0) p &#x3D; p-&gt;lchild;
        cout &lt;&lt; p-&gt;data;
        while (p-&gt;RTag &#x3D;&#x3D; 1 &amp;&amp; p-&gt;rchild !&#x3D; T) &#123;
            p &#x3D; p-&gt;rchild;
            cout &lt;&lt; p-&gt;data;
        &#125;
        p &#x3D; p-&gt;rchild;
    &#125;
&#125;</code></pre>
<h4 id="树与森林">树与森林</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">#define MAXSIZE 100

&#x2F;&#x2F; 双亲表示法
typedef struct&#123;
    char data;
    int parent;
&#125;PTNode;
typedef struct&#123;
    PTNode nodes[MAXSIZE];
    int n;
&#125;PTree;

&#x2F;&#x2F; 孩子表示法
typedef struct CSNode&#123;
    char data;
    struct CSNode* firstchild,*nextsibling;
&#125;CSNode,*CSTree;</code></pre>
<h4 id="哈夫曼树">哈夫曼树</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;

typedef struct
&#123;
    int weight;
    int parent, lchild, rchild;
&#125; HTNode, *HuffmanTree;

typedef char **HuffmanCode;

void CreateHuffmanTree(HuffmanTree &amp;T, int n)
&#123;
    if (n &lt;&#x3D; 1)
        return;
    int m &#x3D; 2 * n - 1;
    T &#x3D; new HTNode[m + 1];

    &#x2F;&#x2F; 初始化所有节点
    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
    &#123;
        T[i].parent &#x3D; 0;
        T[i].lchild &#x3D; 0;
        T[i].rchild &#x3D; 0;
        T[i].weight &#x3D; 0;
    &#125;

    &#x2F;&#x2F; 输入叶子节点权重
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        cin &gt;&gt; T[i].weight;
    &#125;

    &#x2F;&#x2F; 使用优先队列存储
    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        pq.push(make_pair(T[i].weight, i));
    &#125;

    int current &#x3D; n + 1; &#x2F;&#x2F; 当前中间节点索引
    for (int i &#x3D; 1; i &lt;&#x3D; n - 1; i++)
    &#123;
        &#x2F;&#x2F; 获取两个最小节点
        int s1 &#x3D; -1, s2 &#x3D; -1;

        &#x2F;&#x2F; 寻找第一个有效节点
        while (!pq.empty() &amp;&amp; s1 &#x3D;&#x3D; -1)
        &#123;
            auto top &#x3D; pq.top();
            pq.pop();
            if (T[top.second].parent &#x3D;&#x3D; 0)
            &#123;
                s1 &#x3D; top.second;
            &#125;
        &#125;

        &#x2F;&#x2F; 寻找第二个有效节点
        while (!pq.empty() &amp;&amp; s2 &#x3D;&#x3D; -1)
        &#123;
            auto top &#x3D; pq.top();
            pq.pop();
            if (T[top.second].parent &#x3D;&#x3D; 0)
            &#123;
                s2 &#x3D; top.second;
            &#125;
        &#125;

        if (s1 &#x3D;&#x3D; -1 || s2 &#x3D;&#x3D; -1)
        &#123;
            return;
        &#125;

        &#x2F;&#x2F; 创建新节点
        T[current].weight &#x3D; T[s1].weight + T[s2].weight;
        T[current].lchild &#x3D; s1;
        T[current].rchild &#x3D; s2;
        T[s1].parent &#x3D; current;
        T[s2].parent &#x3D; current;

        &#x2F;&#x2F; 将新节点加入优先队列
        pq.push(make_pair(T[current].weight, current));
        current++;
    &#125;
&#125;

void CreateHuffmanCode(HuffmanTree HT, HuffmanCode &amp;HC, int n)
&#123;
    HC &#x3D; new char *[n + 1];
    char *cd &#x3D; new char[n];
    cd[n - 1] &#x3D; &#39;\0&#39;;

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        int start &#x3D; n - 1;
        int c &#x3D; i;
        int f &#x3D; HT[i].parent;

        while (f !&#x3D; 0)
        &#123;
            start--;
            if (HT[f].lchild &#x3D;&#x3D; c)
            &#123;
                cd[start] &#x3D; &#39;0&#39;;
            &#125;
            else
            &#123;
                cd[start] &#x3D; &#39;1&#39;;
            &#125;
            c &#x3D; f;
            f &#x3D; HT[f].parent;
        &#125;

        HC[i] &#x3D; new char[n - start];
        strcpy(HC[i], &amp;cd[start]);
    &#125;
    delete[] cd;
&#125;</code></pre>
<h4 id="并查集">并查集</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">const int MAXN &#x3D; 1000;
int father[MAXN];
int Rank[MAXN];

void init()
&#123;
    for (int i &#x3D; 0; i &lt; MAXN; i++)
    &#123;
        father[i] &#x3D; i;
        Rank[i] &#x3D; 1;
    &#125;
&#125;

int find_set(int x)
&#123;
    if (x !&#x3D; father[x])
    &#123;
        father[x] &#x3D; find_set(father[x]);
    &#125;
    return father[x];
&#125;

void Union(int x, int y)
&#123;
    int root_x &#x3D; find_set(x);
    int root_y &#x3D; find_set(y);
    if (root_x &#x3D;&#x3D; root_y)
        return;
    if (Rank[root_x] &gt; Rank[root_y])
    &#123;
        father[root_y] &#x3D; root_x;
        Rank[root_x] +&#x3D; Rank[root_y];
    &#125;
    else
    &#123;
        father[root_x] &#x3D; root_y;
        Rank[root_y] +&#x3D; Rank[root_x];
    &#125;
&#125;</code></pre>
<h2 id="图">图</h2>
<p><strong>邻接矩阵</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;

#define MaxInt 32767     &#x2F;&#x2F; 极大值
#define MVNum 100        &#x2F;&#x2F; 顶点最大值
typedef char VerTexType; &#x2F;&#x2F; 顶点类型定义
typedef int ArcType;     &#x2F;&#x2F; 边类型定义

&#x2F;&#x2F; 邻接矩阵表示法
typedef struct
&#123;
    VerTexType vexs[MVNum];     &#x2F;&#x2F; 顶点表
    ArcType arcs[MVNum][MVNum]; &#x2F;&#x2F; 邻接矩阵
    int vexnum, arcnum; &#x2F;&#x2F; 顶点数目 边数目
&#125; AMGraph;

&#x2F;&#x2F; 为AMGraph定位顶点
int LocateVex(AMGraph G, VerTexType v)
&#123;
    for (int i &#x3D; 0; i &lt; G.vexnum; i++)
    &#123;
        if (G.vexs[i] &#x3D;&#x3D; v)
        &#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

&#x2F;&#x2F; 初始化邻接矩阵
void CreateAM(AMGraph &amp;G)
&#123;
    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;
    for (int i &#x3D; 0; i &lt; G.vexnum; i++)
    &#123;
        cin &gt;&gt; G.vexs[i];
    &#125;
    for (int i &#x3D; 0; i &lt; G.vexnum; i++)
    &#123;
        for (int j &#x3D; 0; j &lt; G.vexnum; j++)
        &#123;
            if (i &#x3D;&#x3D; j)
            &#123;
                G.arcs[i][j] &#x3D; 0;
            &#125;
            else
            &#123;
                G.arcs[i][j] &#x3D; MaxInt;
            &#125;
        &#125;
    &#125;
    for (int k &#x3D; 0; k &lt; G.arcnum; k++)
    &#123;
        VerTexType v1, v2;
        ArcType w;
        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;
        int i &#x3D; LocateVex(G, v1);
        int j &#x3D; LocateVex(G, v2);
        G.arcs[i][j] &#x3D; w;
        G.arcs[j][i] &#x3D; w;
    &#125;
&#125;</code></pre>
<p><strong>邻接表</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;

&#x2F;&#x2F; 邻接表表示法
typedef struct ArcNode
&#123;
    int adjvex; &#x2F;&#x2F; 该边指向的顶点位置
    int weight; &#x2F;&#x2F; 边的权重
    struct ArcNode *nextarc;
&#125; ArcNode;

typedef struct VNode
&#123;
    VerTexType data;   &#x2F;&#x2F; 顶点信息
    ArcNode *firstarc; &#x2F;&#x2F; 指向第一条边的指针
&#125; VNode, AdjList[MVNum];

typedef struct
&#123;
    AdjList vertices;   &#x2F;&#x2F; 邻接表
    int vexnum, arcnum; &#x2F;&#x2F; 顶点数和边数
&#125; ALGraph;

&#x2F;&#x2F; 为 ALGraph 定位顶点
int LocateVex(const ALGraph &amp;G, VerTexType v)
&#123;
    for (int i &#x3D; 0; i &lt; G.vexnum; i++)
    &#123;
        if (G.vertices[i].data &#x3D;&#x3D; v)
        &#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

&#x2F;&#x2F; 初始化邻接表
void CreateAL(ALGraph &amp;G)
&#123;
    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;
    for (int i &#x3D; 0; i &lt; G.vexnum; i++)
    &#123;
        cin &gt;&gt; G.vertices[i].data;
        G.vertices[i].firstarc &#x3D; NULL;
    &#125;
    for (int k &#x3D; 0; k &lt; G.arcnum; k++)
    &#123;
        VerTexType v1, v2;
        ArcType weight;
        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; weight;
        int i &#x3D; LocateVex(G, v1);
        int j &#x3D; LocateVex(G, v2);

        &#x2F;&#x2F; 添加边 v1 -&gt; v2 头插法
        ArcNode *p1 &#x3D; new ArcNode;
        p1-&gt;adjvex &#x3D; j;
        p1-&gt;weight &#x3D; weight;
        p1-&gt;nextarc &#x3D; G.vertices[i].firstarc;
        G.vertices[i].firstarc &#x3D; p1;

        &#x2F;* 添加边 v2 -&gt; v1（无向图必须对称）
        ArcNode *p2 &#x3D; new ArcNode;
        p2-&gt;adjvex &#x3D; i;
        p2-&gt;weight &#x3D; weight;
        p2-&gt;nextarc &#x3D; G.vertices[j].firstarc;
        G.vertices[j].firstarc &#x3D; p2;
        *&#x2F;
    &#125;
&#125;</code></pre>
<p><strong>十字链表</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 十字链表表示法（有向图）
typedef struct ArcNode_OL &#123;
    int tailvex;             &#x2F;&#x2F; 弧尾顶点位置
    int headvex;             &#x2F;&#x2F; 弧头顶点位置
    struct ArcNode_OL *hlink; &#x2F;&#x2F; 指向同一弧头的下一条弧
    struct ArcNode_OL *tlink; &#x2F;&#x2F; 指向同一弧尾的下一条弧
    int weight;              &#x2F;&#x2F; 弧的权值
    InfoType info;        &#x2F;&#x2F; 其他信息
&#125; ArcNode_OL;

typedef struct VexNode_OL &#123;
    VerTexType data;         &#x2F;&#x2F; 顶点数据
    ArcNode_OL *firstin;     &#x2F;&#x2F; 指向以该顶点为弧头的第一条弧
    ArcNode_OL *firstout;    &#x2F;&#x2F; 指向以该顶点为弧尾的第一条弧
&#125; VexNode_OL;

typedef struct &#123;
    VexNode_OL xlist[MVNum]; &#x2F;&#x2F; 顶点表
    int vexnum, arcnum;      &#x2F;&#x2F; 顶点数和弧数
&#125; OLGraph;</code></pre>
<p><strong>邻接多重表</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 邻接多重表表示法（无向图）
typedef struct EBox &#123;
    int ivex, jvex;          &#x2F;&#x2F; 该边依附的两个顶点位置
    struct EBox *ilink;      &#x2F;&#x2F; 指向依附于顶点ivex的下一条边
    struct EBox *jlink;      &#x2F;&#x2F; 指向依附于顶点jvex的下一条边
    int weight;              &#x2F;&#x2F; 边的权值
    bool mark;             &#x2F;&#x2F; 访问标记
    InfoType info;         &#x2F;&#x2F; 其他信息
&#125; EBox;

typedef struct VexBox &#123;
    VerTexType data;         &#x2F;&#x2F; 顶点数据
    EBox *firstedge;         &#x2F;&#x2F; 指向第一条依附于该顶点的边
&#125; VexBox;

typedef struct &#123;
    VexBox adjmulist[MVNum]; &#x2F;&#x2F; 顶点表
    int vexnum, edgenum;     &#x2F;&#x2F; 顶点数和边数
&#125; AMLGraph;</code></pre>
<p><strong>DFS</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

const int MVNum &#x3D; 100;
bool visited[MVNum];
vector&lt;int&gt; path;

struct AMGraph
&#123;
    int arcs[MVNum][MVNum];
    int vexnum, arcnum;
&#125;;

struct ArcNode
&#123;
    int adjvex;
    ArcNode *nextarc;
&#125;;

struct VNode
&#123;
    ArcNode *firstarc;
&#125;;

struct ALGraph
&#123;
    VNode vertices[MVNum];
    int vexnum, arcnum;
&#125;;

void DFS_AM(AMGraph G, int v)
&#123;
    cout &lt;&lt; v &lt;&lt; &quot; &quot;;
    visited[v] &#x3D; true;
    path.push_back(v);
    for (int w &#x3D; 0; w &lt; G.vexnum; w++)
        if (G.arcs[v][w] &amp;&amp; !visited[w])
            DFS_AM(G, w);
&#125;

void DFS_AL(ALGraph G, int v)
&#123;
    cout &lt;&lt; v &lt;&lt; &quot; &quot;;
    visited[v] &#x3D; true;
    path.push_back(v);
    ArcNode *p &#x3D; G.vertices[v].firstarc;
    while (p)
    &#123;
        int w &#x3D; p-&gt;adjvex;
        if (!visited[w])
            DFS_AL(G, w);
        p &#x3D; p-&gt;nextarc;
    &#125;
&#125;

void DFSTraverse_AM(AMGraph G)
&#123;
    path.clear();
    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)
        visited[i] &#x3D; false;
    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)
        if (!visited[i])
            DFS_AM(G, i);
&#125;

void DFSTraverse_AL(ALGraph G)
&#123;
    path.clear();
    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)
        visited[i] &#x3D; false;
    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)
        if (!visited[i])
            DFS_AL(G, i);
&#125;

void PrintPath()
&#123;
    for (size_t i &#x3D; 0; i &lt; path.size(); ++i) &#123;
        cout &lt;&lt; path[i];
        if (i &lt; path.size() - 1)
            cout &lt;&lt; &quot; -&gt; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;</code></pre>
<p><strong>BFS</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;

const int MVNum &#x3D; 100;
bool visited[MVNum];
vector&lt;int&gt; path;

struct AMGraph
&#123;
    int arcs[MVNum][MVNum];
    int vexnum, arcnum;
&#125;;

struct ArcNode
&#123;
    int adjvex;
    ArcNode *nextarc;
&#125;;

struct VNode
&#123;
    ArcNode *firstarc;
&#125;;

struct ALGraph
&#123;
    VNode vertices[MVNum];
    int vexnum, arcnum;
&#125;;

void BFS_AM(AMGraph G, int v)
&#123;
    queue&lt;int&gt; Q;
    cout &lt;&lt; v &lt;&lt; &quot; &quot;;
    visited[v] &#x3D; true;
    path.push_back(v);
    Q.push(v);

    while (!Q.empty())
    &#123;
        int u &#x3D; Q.front();
        Q.pop();
        for (int w &#x3D; 0; w &lt; G.vexnum; w++)
        &#123;
            if (G.arcs[u][w] &amp;&amp; !visited[w])
            &#123;
                cout &lt;&lt; w &lt;&lt; &quot; &quot;;
                visited[w] &#x3D; true;
                path.push_back(w);
                Q.push(w);
            &#125;
        &#125;
    &#125;
&#125;

void BFS_AL(ALGraph G, int v)
&#123;
    queue&lt;int&gt; Q;
    cout &lt;&lt; v &lt;&lt; &quot; &quot;;
    visited[v] &#x3D; true;
    path.push_back(v);
    Q.push(v);

    while (!Q.empty())
    &#123;
        int u &#x3D; Q.front();
        Q.pop();
        ArcNode *p &#x3D; G.vertices[u].firstarc;
        while (p)
        &#123;
            int w &#x3D; p-&gt;adjvex;
            if (!visited[w])
            &#123;
                cout &lt;&lt; w &lt;&lt; &quot; &quot;;
                visited[w] &#x3D; true;
                path.push_back(w);
                Q.push(w);
            &#125;
            p &#x3D; p-&gt;nextarc;
        &#125;
    &#125;
&#125;

void BFSTraverse_AM(AMGraph G)
&#123;
    path.clear();
    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)
        visited[i] &#x3D; false;
    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)
        if (!visited[i])
            BFS_AM(G, i);
&#125;

void BFSTraverse_AL(ALGraph G)
&#123;
    path.clear();
    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)
        visited[i] &#x3D; false;
    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)
        if (!visited[i])
            BFS_AL(G, i);
&#125;

void PrintPath()
&#123;
    for (size_t i &#x3D; 0; i &lt; path.size(); ++i) &#123;
        cout &lt;&lt; path[i];
        if (i &lt; path.size() - 1)
            cout &lt;&lt; &quot; -&gt; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;</code></pre>
<p><strong>最小生成树（MST）</strong></p>
<p><strong>Kruskal</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;

#define MAXVEX 100
#define INF 114514

typedef struct &#123;
    int adjvex;
    int weight;
    struct ArcNode *next;
&#125; ArcNode;

typedef struct &#123;
    ArcNode *firstarc;
&#125; AdjList[MAXVEX];

typedef struct &#123;
    AdjList vertices;
    int vexnum, arcnum;
&#125; Graph;

bool hasCycle(Graph &amp;G, int from, int to, vector&lt;bool&gt;&amp; visited, int parent) &#123;
    visited[from] &#x3D; true;
    ArcNode* p &#x3D; G.vertices[from].firstarc;
    while(p) &#123;
        int next &#x3D; p-&gt;adjvex;
        if(!visited[next]) &#123;
        if(hasCycle(G, next, to, visited, from)) &#123;
                return true;
            &#125;
        &#125;
        else if( next !&#x3D; parent &amp;&amp; next &#x3D;&#x3D; to) &#123;
            return true;
        &#125;
        p &#x3D; p-&gt;next;
    &#125;
    return false;
&#125;

bool isSafe(Graph &amp;G, int from, int to) &#123;
    vector&lt;bool&gt; visited(G.vexnum + 1, false);
    return !hasCycle(G, from, to, visited, -1);
&#125;

void CreateGraph(Graph &amp;G) &#123;
    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;
    for(int i&#x3D;1; i&lt;&#x3D;G.vexnum; i++) &#123;
        G.vertices[i].firstarc &#x3D; nullptr;
    &#125;
    for(int i&#x3D;1; i&lt;&#x3D;G.arcnum; i++) &#123;
        int m,n,w;
        cin &gt;&gt; m &gt;&gt; n &gt;&gt; w;
        ArcNode *p1 &#x3D; new ArcNode;
        p1-&gt;adjvex &#x3D; n;
        p1-&gt;weight &#x3D; w;
        p1-&gt;next &#x3D; G.vertices[m].firstarc;
        G.vertices[m].firstarc &#x3D; p1;

        ArcNode *p2 &#x3D; new ArcNode;
        p2-&gt;adjvex &#x3D; m;
        p2-&gt;weight &#x3D; w;
        p2-&gt;next &#x3D; G.vertices[n].firstarc;
        G.vertices[n].firstarc &#x3D; p2;
    &#125;
&#125;

void PrintMST(vector&lt;vector&lt;int&gt;&gt; &amp;mst, int n) &#123;
    for(int i&#x3D;1; i&lt;&#x3D;n; i++) &#123;
        for(int j&#x3D;i+1; j&lt;&#x3D;n; j++) &#123;
            if(mst[i][j] !&#x3D; 0) &#123;
                cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;
            &#125;
        &#125;
    &#125;
&#125;

int main() &#123;
    Graph G;
    CreateGraph(G);
    vector&lt;vector&lt;int&gt;&gt; mst(G.vexnum+1, vector&lt;int&gt;(G.vexnum+1, 0));
    int MSTedge &#x3D; 0;

    while(MSTedge &lt; G.vexnum-1) &#123;
        int min &#x3D; INF;
        int p1 &#x3D; -1, p2 &#x3D; -1;

        for(int i&#x3D;1; i&lt;&#x3D;G.vexnum; i++) &#123;
            ArcNode *p &#x3D; G.vertices[i].firstarc;
            while(p) &#123;
                if(p-&gt;weight &lt; min &amp;&amp; !mst[i][p-&gt;adjvex] &amp;&amp; isSafe(G, i, p-&gt;adjvex)) &#123;
                    min &#x3D; p-&gt;weight;
                    p1 &#x3D; i;
                    p2 &#x3D; p-&gt;adjvex;
                &#125;
                p &#x3D; p-&gt;next;
            &#125;
        &#125;

        if(p1 &#x3D;&#x3D; -1) &#123;
            cout &lt;&lt; &quot;Invalid.&quot; &lt;&lt; endl;
            return 1;
        &#125;

        mst[p1][p2] &#x3D; 1;
        mst[p2][p1] &#x3D; 1;
        MSTedge++;
    &#125;

    PrintMST(mst, G.vexnum);
    return 0;
&#125;</code></pre>
<p><strong>Prim</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;

#define INF 32366
#define MAX_VERTICES 100

typedef struct &#123;
    int edges[MAX_VERTICES][MAX_VERTICES];
    int edgeCount;
    int vertexCount;
&#125; Graph;

void printMST(vector&lt;vector&lt;int&gt;&gt;&amp; mst, int n) &#123;
    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
        for(int j &#x3D; i + 1; j &lt;&#x3D; n; j++) &#123;
            if(mst[i][j] &#x3D;&#x3D; 1) &#123;
                cout &lt;&lt; i &lt;&lt; &quot; - &quot; &lt;&lt; j &lt;&lt; endl;
            &#125;
        &#125;
    &#125;
&#125;

int main() &#123;
    int n;
    cin &gt;&gt; n;

    Graph g;
    g.edgeCount &#x3D; n - 1;
    g.vertexCount &#x3D; n;

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
        for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;
            g.edges[i][j] &#x3D; INF;
        &#125;
    &#125;

    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
        int from, to, weight;
        cin &gt;&gt; from &gt;&gt; to &gt;&gt; weight;
        g.edges[from][to] &#x3D; weight;
        g.edges[to][from] &#x3D; weight;
    &#125;

    vector&lt;bool&gt; visited(n + 1, false);
    vector&lt;vector&lt;int&gt;&gt; mst(n + 1, vector&lt;int&gt;(n + 1, 0));
    visited[1] &#x3D; true;
    int mstEdgeCount &#x3D; 0;

    while(mstEdgeCount &lt; n - 1) &#123;
        int minWeight &#x3D; INF;
        int minFrom &#x3D; -1;
        int minTo &#x3D; -1;

        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
            if(visited[i]) &#123;
                for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;
                    if(!visited[j] &amp;&amp; g.edges[i][j] &lt; minWeight) &#123;
                        minWeight &#x3D; g.edges[i][j];
                        minFrom &#x3D; i;
                        minTo &#x3D; j;
                    &#125;
                &#125;
            &#125;
        &#125;

        if(minFrom &#x3D;&#x3D; -1) &#123;
            cout &lt;&lt; &quot;Invalid.&quot; &lt;&lt; endl;
            return 1;
        &#125;

        mst[minFrom][minTo] &#x3D; 1;
        mst[minTo][minFrom] &#x3D; 1;
        visited[minTo] &#x3D; true;
        mstEdgeCount++;
    &#125;

    printMST(mst, n);

    return 0;
&#125;</code></pre>
<p><strong>最短路径</strong></p>
<p><strong>Dijkstra</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;

#define MVNum 100
#define INF 114154

typedef struct
&#123;
    char vexs[MVNum];
    int arcs[MVNum][MVNum];
    int vexNum, arcNum;
&#125; Graph;

int LocateVex(const Graph &amp;G, char v)
&#123;
    for (int i &#x3D; 0; i &lt; G.vexNum; ++i)
    &#123;
        if (G.vexs[i] &#x3D;&#x3D; v)
            return i;
    &#125;
    return -1;
&#125;

void Create(Graph &amp;G)
&#123;
    cin &gt;&gt; G.vexNum &gt;&gt; G.arcNum;
    for (int i &#x3D; 1; i &lt;&#x3D; G.vexNum; i++)
    &#123;
        cin &gt;&gt; G.vexs[i];
    &#125;
    for (int i &#x3D; 1; i &lt;&#x3D; G.vexNum; i++)
    &#123;
        for(int j&#x3D;1;j&lt;&#x3D;G.vexNum;j++)
        &#123;
            G.arcs[i][j]&#x3D;INF;
            if(i&#x3D;&#x3D;j)
            &#123;
                G.arcs[i][j]&#x3D;0;
            &#125;
        &#125;
    &#125;
    for (int k &#x3D; 1; k &lt;&#x3D; G.arcNum; k++)
    &#123;
        char v1, v2;
        int w;
        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;
        int i &#x3D; LocateVex(G, v1);
        int j &#x3D; LocateVex(G, v2);
        if (i !&#x3D; -1 &amp;&amp; j !&#x3D; -1)
        &#123;
            G.arcs[i][j] &#x3D; w;
        &#125;
    &#125;
&#125;

void Dijkstra(Graph &amp;G, char start)&#123;
    int v0 &#x3D; LocateVex(G,start);
    int n &#x3D; G.vexNum;

    vector&lt;int&gt; dist(n + 1, INF);
    vector&lt;bool&gt; visited(n + 1, false);
    vector&lt;int&gt; path(n + 1, -1);
    dist[v0] &#x3D; 0;

    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
        int u &#x3D; -1;
        int minDist &#x3D; INF;
        for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;
            if(!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123;
                u &#x3D; j;
                minDist &#x3D; dist[j];
            &#125;
        &#125;

        if(u &#x3D;&#x3D; -1) break;
        visited[u] &#x3D; true;

        for(int v &#x3D; 1; v &lt;&#x3D; n; v++) &#123;
            if(!visited[v] &amp;&amp; G.arcs[u][v] !&#x3D; INF) &#123;
                if(dist[u] + G.arcs[u][v] &lt; dist[v]) &#123;
                    dist[v] &#x3D; dist[u] + G.arcs[u][v];
                    path[v] &#x3D; u;  &#x2F;&#x2F; 记录路径
                &#125;
            &#125;
        &#125;
    &#125;

    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
        if(i !&#x3D; v0) &#123;
            if(dist[i] &#x3D;&#x3D; INF) &#123;
                cout &lt;&lt; &quot;Invalid.&quot; &lt;&lt; endl;
            &#125; else &#123;
                cout &lt;&lt; dist[i] &lt;&lt; endl;
                cout &lt;&lt; start;
                vector&lt;int&gt; route;
                int k &#x3D; i;
                while(k !&#x3D; -1) &#123;
                    route.push_back(k);
                    k &#x3D; path[k];
                &#125;
                for(int r &#x3D; route.size()-1; r &gt;&#x3D; 0; r--) &#123;
                    cout &lt;&lt; &quot; -&gt; &quot; &lt;&lt; G.vexs[route[r]];
                &#125;
                cout &lt;&lt; endl;
            &#125;
        &#125;
    &#125;
&#125;

int main()
&#123;
    Graph G;
    Create(G);
    char start;
    cin &gt;&gt; start;
    Dijkstra(G, start);
    return 0;
&#125;</code></pre>
<p><strong>Floyd</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;

#define MVNum 100
#define INF 114154

typedef struct
&#123;
    char vexs[MVNum];
    int arcs[MVNum][MVNum];
    int vexNum, arcNum;
&#125; Graph;

int LocateVex(const Graph &amp;G, char v)
&#123;
    for (int i &#x3D; 0; i &lt; G.vexNum; ++i)
    &#123;
        if (G.vexs[i] &#x3D;&#x3D; v)
            return i;
    &#125;
    return -1;
&#125;

void Create(Graph &amp;G)
&#123;
    cin &gt;&gt; G.vexNum &gt;&gt; G.arcNum;
    for (int i &#x3D; 1; i &lt;&#x3D; G.vexNum; i++)
    &#123;
        cin &gt;&gt; G.vexs[i];
    &#125;
    for (int i &#x3D; 1; i &lt;&#x3D; G.vexNum; i++)
    &#123;
        for(int j&#x3D;1;j&lt;&#x3D;G.vexNum;j++)
        &#123;
            G.arcs[i][j]&#x3D;INF;
            if(i&#x3D;&#x3D;j)
            &#123;
                G.arcs[i][j]&#x3D;0;
            &#125;
        &#125;
    &#125;
    for (int k &#x3D; 1; k &lt;&#x3D; G.arcNum; k++)
    &#123;
        char v1, v2;
        int w;
        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;
        int i &#x3D; LocateVex(G, v1);
        int j &#x3D; LocateVex(G, v2);
        if (i !&#x3D; -1 &amp;&amp; j !&#x3D; -1)
        &#123;
            G.arcs[i][j] &#x3D; w;
        &#125;
    &#125;
&#125;

void Floyd(Graph &amp;G)
&#123;
    int n &#x3D; G.vexNum;
    vector&lt;vector&lt;int&gt;&gt; dist(n + 1, vector&lt;int&gt;(n + 1));
    vector&lt;vector&lt;int&gt;&gt; path(n + 1, vector&lt;int&gt;(n + 1, -1));

    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
        for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;
            dist[i][j] &#x3D; G.arcs[i][j];
            if(dist[i][j] &lt; INF &amp;&amp; i !&#x3D; j) &#123;
                path[i][j] &#x3D; i;
            &#125;
        &#125;
    &#125;

    for(int k &#x3D; 1; k &lt;&#x3D; n; k++) &#123;
        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
            for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;
                if(dist[i][k] !&#x3D; INF &amp;&amp; dist[k][j] !&#x3D; INF &amp;&amp;
                   dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;
                    dist[i][j] &#x3D; dist[i][k] + dist[k][j];
                    path[i][j] &#x3D; path[k][j];
                &#125;
            &#125;
        &#125;
    &#125;

    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
        for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;
            if(i !&#x3D; j) &#123;
                cout &lt;&lt; G.vexs[i] &lt;&lt; &quot; &quot; &lt;&lt; G.vexs[j];
                if(dist[i][j] &#x3D;&#x3D; INF) &#123;
                    cout &lt;&lt; &quot;Invalid.&quot; &lt;&lt; endl;
                &#125; else &#123;
                    cout &lt;&lt; dist[i][j] &lt;&lt; endl;
                    cout &lt;&lt; G.vexs[i];
                    int k &#x3D; path[i][j];
                    vector&lt;int&gt; route;
                    while(k !&#x3D; -1) &#123;
                        route.push_back(k);
                        k &#x3D; path[i][k];
                    &#125;
                    for(int r &#x3D; route.size()-1; r &gt;&#x3D; 0; r--) &#123;
                        cout &lt;&lt; &quot; -&gt; &quot; &lt;&lt; G.vexs[route[r]];
                    &#125;
                    cout &lt;&lt; &quot; -&gt; &quot; &lt;&lt; G.vexs[j] &lt;&lt; endl;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;

int main()
&#123;
    Graph G;
    Create(G);
    Floyd(G);
    return 0;
&#125;</code></pre>
<p><strong>拓扑排序</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;

#define MVNum 100

typedef struct &#123;
    char vexs[MVNum];
    int arcs[MVNum][MVNum];
    int vexNum, arcNum;
&#125; Graph;

int LocateVex(const Graph &amp;G, char v) &#123;
    for (int i &#x3D; 0; i &lt; G.vexNum; ++i) &#123;
        if (G.vexs[i] &#x3D;&#x3D; v)
            return i;
    &#125;
    return -1;
&#125;

void CreateGraph(Graph &amp;G) &#123;
    cin &gt;&gt; G.vexNum &gt;&gt; G.arcNum;

    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;
        cin &gt;&gt; G.vexs[i];
    &#125;

    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;
        for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123;
            G.arcs[i][j] &#x3D; 0;
        &#125;
    &#125;

    for (int k &#x3D; 0; k &lt; G.arcNum; k++) &#123;
        char v1, v2;
        cin &gt;&gt; v1 &gt;&gt; v2;
        int i &#x3D; LocateVex(G, v1);
        int j &#x3D; LocateVex(G, v2);
        if (i !&#x3D; -1 &amp;&amp; j !&#x3D; -1) &#123;
            G.arcs[i][j] &#x3D; 1;  &#x2F;&#x2F; 有向图
        &#125;
    &#125;
&#125;

bool TopologicalSort(Graph &amp;G) &#123;
    vector&lt;int&gt; inDegree(G.vexNum, 0);
    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;
        for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123;
            if (G.arcs[j][i] &#x3D;&#x3D; 1) &#123;
                inDegree[i]++;
            &#125;
        &#125;
    &#125;

    queue&lt;int&gt; q;
    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;
        if (inDegree[i] &#x3D;&#x3D; 0) &#123;
            q.push(i);
        &#125;
    &#125;

    int count &#x3D; 0;
    vector&lt;char&gt; result;

    while (!q.empty()) &#123;
        int v &#x3D; q.front();
        q.pop();
        result.push_back(G.vexs[v]);
        count++;

        for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;
            if (G.arcs[v][i] &#x3D;&#x3D; 1) &#123;
                inDegree[i]--;
                if (inDegree[i] &#x3D;&#x3D; 0) &#123;
                    q.push(i);
                &#125;
            &#125;
        &#125;
    &#125;

    if (count &#x3D;&#x3D; G.vexNum) &#123;
        for (char c : result) &#123;
            cout &lt;&lt; c &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;
        return true;
    &#125; else &#123;
        return false;
    &#125;
&#125;

int main() &#123;
    Graph G;
    CreateGraph(G);
    TopologicalSort(G);
    return 0;
&#125;</code></pre>
<p><strong>关键路径</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;

#define MVNum 100
#define INF 114154

typedef struct &#123;
    char vexs[MVNum];
    int arcs[MVNum][MVNum];
    int vexNum, arcNum;
&#125; Graph;

int LocateVex(const Graph &amp;G, char v) &#123;
    for (int i &#x3D; 0; i &lt; G.vexNum; ++i) &#123;
        if (G.vexs[i] &#x3D;&#x3D; v)
            return i;
    &#125;
    return -1;
&#125;

void CreateGraph(Graph &amp;G) &#123;
    cin &gt;&gt; G.vexNum &gt;&gt; G.arcNum;

    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;
        cin &gt;&gt; G.vexs[i];
    &#125;

    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;
        for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123;
            G.arcs[i][j] &#x3D; 0;
        &#125;
    &#125;

    for (int k &#x3D; 0; k &lt; G.arcNum; k++) &#123;
        char v1, v2;
        int w;
        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;
        int i &#x3D; LocateVex(G, v1);
        int j &#x3D; LocateVex(G, v2);
        if (i !&#x3D; -1 &amp;&amp; j !&#x3D; -1) &#123;
            G.arcs[i][j] &#x3D; w;
        &#125;
    &#125;
&#125;

bool TopologicalSort(Graph &amp;G, vector&lt;int&gt; &amp;topoOrder) &#123;
    vector&lt;int&gt; inDegree(G.vexNum, 0);
    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;
        for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123;
            if (G.arcs[j][i] !&#x3D; 0) &#123;
                inDegree[i]++;
            &#125;
        &#125;
    &#125;

    queue&lt;int&gt; q;
    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;
        if (inDegree[i] &#x3D;&#x3D; 0) &#123;
            q.push(i);
        &#125;
    &#125;

    while (!q.empty()) &#123;
        int v &#x3D; q.front();
        q.pop();
        topoOrder.push_back(v);

        for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;
            if (G.arcs[v][i] !&#x3D; 0) &#123;
                inDegree[i]--;
                if (inDegree[i] &#x3D;&#x3D; 0) &#123;
                    q.push(i);
                &#125;
            &#125;
        &#125;
    &#125;

    return topoOrder.size() &#x3D;&#x3D; G.vexNum;
&#125;

void CalculateVE(Graph &amp;G, const vector&lt;int&gt; &amp;topoOrder, vector&lt;int&gt; &amp;ve) &#123;
    &#x2F;&#x2F; 初始化ve数组
    ve.resize(G.vexNum, 0);

    &#x2F;&#x2F; 按拓扑顺序计算ve
    for (int i &#x3D; 0; i &lt; topoOrder.size(); i++) &#123;
        int u &#x3D; topoOrder[i];
        for (int v &#x3D; 0; v &lt; G.vexNum; v++) &#123;
            if (G.arcs[u][v] !&#x3D; 0) &#123;
                ve[v] &#x3D; max(ve[v], ve[u] + G.arcs[u][v]);
            &#125;
        &#125;
    &#125;
&#125;

void CalculateVL(Graph &amp;G, const vector&lt;int&gt; &amp;topoOrder, const vector&lt;int&gt; &amp;ve, vector&lt;int&gt; &amp;vl) &#123;
    &#x2F;&#x2F; 初始化vl数组
    vl.resize(G.vexNum, ve[topoOrder.back()]);

    &#x2F;&#x2F; 按逆拓扑顺序计算vl
    for (int i &#x3D; topoOrder.size() - 1; i &gt;&#x3D; 0; i--) &#123;
        int u &#x3D; topoOrder[i];
        for (int v &#x3D; 0; v &lt; G.vexNum; v++) &#123;
            if (G.arcs[u][v] !&#x3D; 0) &#123;
                vl[u] &#x3D; min(vl[u], vl[v] - G.arcs[u][v]);
            &#125;
        &#125;
    &#125;
&#125;

void FindCriticalPath(Graph &amp;G, const vector&lt;int&gt; &amp;ve, const vector&lt;int&gt; &amp;vl) &#123;
    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;
        for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123;
            if (G.arcs[i][j] !&#x3D; 0) &#123;
                int e &#x3D; ve[i];  &#x2F;&#x2F; 活动最早开始时间
                int l &#x3D; vl[j] - G.arcs[i][j];  &#x2F;&#x2F; 活动最晚开始时间
                if (e &#x3D;&#x3D; l) &#123;  &#x2F;&#x2F; 关键活动
                    cout &lt;&lt; G.vexs[i] &lt;&lt; &quot; &quot; &lt;&lt; G.vexs[j] &lt;&lt; &quot; &quot; &lt;&lt; G.arcs[i][j] &lt;&lt; endl;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;

int main() &#123;
    Graph G;
    CreateGraph(G);

    vector&lt;int&gt; topoOrder;
    if (!TopologicalSort(G, topoOrder)) &#123;
        cout &lt;&lt; &quot;ERROR&quot; &lt;&lt; endl;
        return 0;
    &#125;

    vector&lt;int&gt; ve, vl;
    CalculateVE(G, topoOrder, ve);
    CalculateVL(G, topoOrder, ve, vl);

    FindCriticalPath(G, ve, vl);

    return 0;
&#125;</code></pre>
<h3 id="查找">查找</h3>
<h4 id="线性表-1">线性表</h4>
<p><strong>顺序查找</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">typedef struct&#123;
    KeyType key;
    InfoType otherinfo;
&#125;ElemType;

typedef struct&#123;
    ElemType *R;
    int length;
&#125;SSTable;

int Search_Seq(SSTable ST,KeyType key)&#123;
    for(int i&#x3D;ST.length;i&gt;&#x3D;1;i--)&#123;
        if(ST.R[i],key&#x3D;&#x3D;key)&#123;
            return i;
        &#125;
    &#125;
    return 0;
&#125;</code></pre>
<p><strong>二分查找</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">typedef struct&#123;
    KeyType key;
    InfoType otherinfo;
&#125;ElemType;

typedef struct&#123;
    ElemType *R;
    int length;
&#125;SSTable;

int Search_Bin(SSTable ST,KeyType key)&#123;
    int low &#x3D; 1;
    int high &#x3D; ST.length;
    while(low&lt;&#x3D;high)&#123;
        int mid &#x3D; (low+high) &lt;&lt; 1;
        if(key&#x3D;&#x3D;ST.R[mid].key)&#123;
            return mid;
        &#125;
        else if(key&lt;ST.R[mid].key)&#123;
            high &#x3D; mid - 1;
        &#125;
        else&#123;
            low &#x3D; mid + 1;
        &#125;
    &#125;
    return 0;
&#125;</code></pre>
<p><strong>分块查找</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">typedef struct&#123;
    KeyType key;
    InfoType otherinfo;
&#125;ElemType;

typedef struct&#123;
    ElemType *R;
    int length;
&#125;SSTable;

typedef struct &#123;
    KeyType max_key; &#x2F;&#x2F; 块内最大关键字
    int start;       &#x2F;&#x2F; 块起始位置
    int end;         &#x2F;&#x2F; 块结束位置
&#125; IndexBlock;

int BlockSearch(SSTable ST, IndexBlock index[], int index_len, KeyType key) &#123;
    int low &#x3D; 0, high &#x3D; index_len - 1;
    int block_idx &#x3D; -1;

    &#x2F;&#x2F; 二分查找确定所在块
    while (low &lt;&#x3D; high) &#123;
        int mid &#x3D; (low + high) &#x2F; 2;
        if (key &lt;&#x3D; index[mid].max_key) &#123;
            block_idx &#x3D; mid;
            high &#x3D; mid - 1;
        &#125; else &#123;
            low &#x3D; mid + 1;
        &#125;
    &#125;

    if (block_idx &#x3D;&#x3D; -1)
        return -1;

    &#x2F;&#x2F; 在块内顺序查找
    for (int i &#x3D; index[block_idx].start; i &lt;&#x3D; index[block_idx].end; ++i) &#123;
        if (ST.R[i].key &#x3D;&#x3D; key)
            return i;
    &#125;

    return -1;
&#125;</code></pre>
<h4 id="树表">树表</h4>
<p><strong>二叉排序树</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">typedef struct&#123;
    KeyType key;
    InfoType otherinfo;
&#125;ElemType;

typedef struct BSTNode&#123;
    ElemType data;
    struct BSTNode *lchild,*rchild;
&#125;BSTNode,*BSTree;

BSTree SearchBST(BSTree T,KeyType key)&#123;
    if(!T || key&#x3D;&#x3D;T-&gt;data.key)&#123;
        return T;
    &#125;
    else if(key&lt;T-&gt;data.key)&#123;
        return SearchBST(T-&gt;lchild,key);
    &#125;
    else&#123;
        return SearchBST(T-&gt;rchild,key);
    &#125;
&#125;

void InsertBST(BSTree &amp;T,ElemType e)&#123;
    if(!T)&#123;
        BSTNode S &#x3D; new BSTNode;
        S-&gt;data &#x3D; e;
        S-&gt;lchild &#x3D; NULL;
        S-&gt;rchild &#x3D; NULL;
        T &#x3D; S;
    &#125;
    else if(e.key&lt;T-&gt;data.key)&#123;
        InsertBST(T-&gt;lchild,e);
    &#125;
    else if(e.key&gt;T-&gt;data.key)&#123;
        InsertBST(T-&gt;rchild,e);
    &#125;
&#125;

void CreateBST(BSTree &amp;T)&#123;
    int e;
    T &#x3D; NULL;
    cin &gt;&gt; e;
    while(e.key!&#x3D;-1)&#123;
        InsertBST(T,e);
        cin &gt;&gt; e;
    &#125;
&#125;

void DeleteBST(BSTree &amp;T, KeyType key) &#123;
    BSTree p &#x3D; T;      &#x2F;&#x2F; 当前节点指针
    BSTree f &#x3D; NULL;   &#x2F;&#x2F; 父节点指针

    &#x2F;&#x2F; 查找删除节点
    while (p) &#123;
        if (p-&gt;data.key &#x3D;&#x3D; key) break;
        f &#x3D; p;
        if (p-&gt;data.key &gt; key) p &#x3D; p-&gt;lchild;
        else p &#x3D; p-&gt;rchild;
    &#125;
    if (!p) return;

    BSTree q &#x3D; p;      &#x2F;&#x2F; 辅助指针 q 指向待删除节点

    &#x2F;&#x2F; Case 1: 节点 p 是叶子节点或仅有一个子树
    if (!p-&gt;lchild) &#123;        &#x2F;&#x2F; 左子树为空，用右子树替换
        if (!f) T &#x3D; p-&gt;rchild;              &#x2F;&#x2F; p 是根节点
        else if (f-&gt;lchild &#x3D;&#x3D; p) f-&gt;lchild &#x3D; p-&gt;rchild;
        else f-&gt;rchild &#x3D; p-&gt;rchild;
        free(q);
    &#125; else if (!p-&gt;rchild) &#123; &#x2F;&#x2F; 右子树为空，用左子树替换
        if (!f) T &#x3D; p-&gt;lchild;              &#x2F;&#x2F; p 是根节点
        else if (f-&gt;lchild &#x3D;&#x3D; p) f-&gt;lchild &#x3D; p-&gt;lchild;
        else f-&gt;rchild &#x3D; p-&gt;lchild;
        free(q);
    &#125; else &#123;
        &#x2F;&#x2F; Case 2: 节点 p 有两个子树，找左子树的最右节点（前驱）
        BSTree s &#x3D; p-&gt;lchild;
        BSTree parent_s &#x3D; p; &#x2F;&#x2F; s 的父节点
        while (s-&gt;rchild) &#123;
            parent_s &#x3D; s;
            s &#x3D; s-&gt;rchild;
        &#125;

        &#x2F;&#x2F; 用前驱 s 替换 p 的值
        p-&gt;data &#x3D; s-&gt;data;

        &#x2F;&#x2F; 删除前驱节点 s（此时 s 至多有一个左子树）
        if (parent_s &#x3D;&#x3D; p) parent_s-&gt;lchild &#x3D; s-&gt;lchild;
        else parent_s-&gt;rchild &#x3D; s-&gt;lchild;
        free(s);
    &#125;
&#125;</code></pre>
<h4 id="哈希表">哈希表</h4>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;string&gt;
using namespace std;

&#x2F;&#x2F; 拉链法
static const int tableSize &#x3D; 10;

vector&lt;list&lt;pair&lt;int, string&gt;&gt;&gt; chainTable(tableSize);

int hashFunction(int key)
&#123;
    return key % tableSize;
&#125;

void insertChaining(int key, string value)
&#123;
    int index &#x3D; hashFunction(key);
    chainTable[index].push_back(make_pair(key, value));
&#125;

string searchChaining(int key)
&#123;
    int index &#x3D; hashFunction(key);
    for (auto &amp;p : chainTable[index])
    &#123;
        if (p.first &#x3D;&#x3D; key)
            return p.second;
    &#125;
    return &quot;&quot;;
&#125;

void removeChaining(int key)
&#123;
    int index &#x3D; hashFunction(key);
    auto &amp;chain &#x3D; chainTable[index];
    for (auto it &#x3D; chain.begin(); it !&#x3D; chain.end(); ++it)
    &#123;
        if (it-&gt;first &#x3D;&#x3D; key)
        &#123;
            chain.erase(it);
            return;
        &#125;
    &#125;
&#125;

&#x2F;&#x2F; 开放定址法（以线性探测为例）
enum EntryState &#123; EMPTY, OCCUPIED, DELETED &#125;;

struct HashEntry &#123;
    int key;
    string value;
    EntryState state;
&#125;;

vector&lt;HashEntry&gt; openTable(tableSize, &#123;0, &quot;&quot;, EMPTY&#125;);

int hashFunctionLP(int key)
&#123;
    return key % tableSize;
&#125;

void insertLinear(int key, string value)
&#123;
    int idx &#x3D; hashFunctionLP(key);
    for (int i &#x3D; 0; i &lt; tableSize; ++i)
    &#123;
        int probe &#x3D; (idx + i) % tableSize;
        if (openTable[probe].state &#x3D;&#x3D; EMPTY || openTable[probe].state &#x3D;&#x3D; DELETED)
        &#123;
            openTable[probe].key &#x3D; key;
            openTable[probe].value &#x3D; value;
            openTable[probe].state &#x3D; OCCUPIED;
            return;
        &#125;
    &#125;
&#125;

string searchLinear(int key)
&#123;
    int idx &#x3D; hashFunctionLP(key);
    for (int i &#x3D; 0; i &lt; tableSize; ++i)
    &#123;
        int probe &#x3D; (idx + i) % tableSize;
        if (openTable[probe].state &#x3D;&#x3D; EMPTY)
            return &quot;&quot;;
        if (openTable[probe].state &#x3D;&#x3D; OCCUPIED &amp;&amp; openTable[probe].key &#x3D;&#x3D; key)
            return openTable[probe].value;
    &#125;
    return &quot;&quot;;
&#125;

void removeLinear(int key)
&#123;
    int idx &#x3D; hashFunctionLP(key);
    for (int i &#x3D; 0; i &lt; tableSize; ++i)
    &#123;
        int probe &#x3D; (idx + i) % tableSize;
        if (openTable[probe].state &#x3D;&#x3D; EMPTY)
            return;
        if (openTable[probe].state &#x3D;&#x3D; OCCUPIED &amp;&amp; openTable[probe].key &#x3D;&#x3D; key)
        &#123;
            openTable[probe].state &#x3D; DELETED;
            return;
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="stl-5">STL</h4>
<p><strong>unordered_set</strong></p>
<ul>
<li><code>insert(x)</code> 向集合中插入元素 x（若已存在，则不插入）</li>
<li><code>erase(x)</code> 从集合中删除元素 x</li>
<li><code>find(x)</code> 查找元素 x，返回迭代器；若未找到，返回
<code>end()</code></li>
<li><code>count(x)</code> 统计元素 x 在集合中出现的次数（要么 0，要么
1）</li>
<li><code>size()</code> 查询集合中元素数量</li>
<li><code>empty()</code> 判断集合是否为空</li>
<li><code>clear()</code> 清空集合中的所有元素</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;unordered_set&gt;
using namespace std;

int main()&#123;
    unordered_set&lt;int&gt; us;
    us.insert(3);
    us.insert(1);
    us.insert(4)
    us.insert(1);
    cout &lt;&lt; us.size() &lt;&lt; endl;
    cout &lt;&lt; (us.find(2) !&#x3D; us.end()) &lt;&lt; endl;
    cout &lt;&lt; us.count(1) &lt;&lt; endl;
    us.erase(3);
    us.clear();
    cout &lt;&lt; us.empty() &lt;&lt; endl;
&#125;</code></pre>
<p><strong>unordered_map</strong></p>
<ul>
<li><code>insert({k, v})</code> 向映射中插入键值对
<code>(k, v)</code>（若键已存在，不插入）</li>
<li><code>erase(k)</code> 删除键为 k 的元素</li>
<li><code>find(k)</code> 查找键为 k
的元素，返回指向该元素的迭代器；若未找到，返回 <code>end()</code></li>
<li><code>count(k)</code> 统计键 k 在映射中出现的次数（要么 0，要么
1）</li>
<li><code>operator[](k)</code> 如果键 k
存在，返回对应的值；否则插入一个键为
k、值为默认构造的元素并返回其引用</li>
<li><code>size()</code> 查询映射中元素数量</li>
<li><code>empty()</code> 判断映射是否为空</li>
<li><code>clear()</code> 清空映射中的所有元素</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
using namespace std;

int main()&#123;
    unordered_map&lt;string, int&gt; um;
    um.insert(&#123;&quot;apple&quot;, 3&#125;);
    um.insert(make_pair(&quot;banana&quot;, 5));
    um[&quot;cherry&quot;] &#x3D; 2;
    cout &lt;&lt; um.size() &lt;&lt; endl;
    cout &lt;&lt; um[&quot;cherry&quot;] &lt;&lt; endl;
    auto it &#x3D; um.find(&quot;banana&quot;);
    if (it !&#x3D; um.end()) &#123;
        cout &lt;&lt; it-&gt;second &lt;&lt; endl;
    &#125;
    um.erase(&quot;apple&quot;);
    um.clear();
    cout &lt;&lt; um.empty() &lt;&lt; endl;
&#125;</code></pre>
<h3 id="排序">排序</h3>
<p><strong>插入排序</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

typedef struct
&#123;
    int *r;
    int length;
&#125; SqList;

void InsertSort(SqList &amp;L)
&#123;
    for (int i &#x3D; 1; i &lt; L.length; i++)
    &#123;
        int temp &#x3D; L.r[i];
        int j &#x3D; i - 1;
        while (j &gt;&#x3D; 0 &amp;&amp; L.r[j] &gt; temp)
        &#123;
            L.r[j + 1] &#x3D; L.r[j];
            j--;
        &#125;
        L.r[j + 1] &#x3D; temp;
    &#125;
&#125;

&#x2F;&#x2F; 二分查找插入位置
void BinaryInsertSort(SqList &amp;L)
&#123;
    for (int i &#x3D; 1; i &lt; L.length; i++)
    &#123;
        int temp &#x3D; L.r[i];
        int start &#x3D; 0;
        int end &#x3D; i - 1;
        while (start &lt;&#x3D; end)
        &#123;
            int mid &#x3D; (start + end) &#x2F; 2;
            if (L.r[mid] &gt; temp)
            &#123;
                end &#x3D; mid - 1;
            &#125;
            else
            &#123;
                start &#x3D; mid + 1;
            &#125;
        &#125;

        for (int j &#x3D; i - 1; j &gt;&#x3D; start; j--)
        &#123;
            L.r[j + 1] &#x3D; L.r[j];
        &#125;

        L.r[start] &#x3D; temp;
    &#125;
&#125;</code></pre>
<p><strong>希尔排序</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

#define MAXSIZE 100

typedef struct
&#123;
    int data[MAXSIZE];
    int length;
&#125; Sqlist;

void ShellSort(Sqlist &amp;L)
&#123;
    &#x2F;&#x2F; 初始间隔（gap）为长度的一半，逐步缩小间隔直到1
    for (int gap &#x3D; L.length &#x2F; 2; gap &gt; 0; gap &#x2F;&#x3D; 2)
    &#123;
        &#x2F;&#x2F; 对每个子序列进行插入排序
        for (int i &#x3D; gap; i &lt; L.length; i++)
        &#123;
            int temp &#x3D; L.data[i];
            int j;
            for (j &#x3D; i; j &gt;&#x3D; gap &amp;&amp; L.data[j - gap] &gt; temp; j -&#x3D; gap)
            &#123;
                L.data[j] &#x3D; L.data[j - gap];
            &#125;
            L.data[j] &#x3D; temp;
        &#125;
    &#125;
&#125;</code></pre>
<p><strong>冒泡排序</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

#define MAXSIZE 100

typedef struct
&#123;
    int data[MAXSIZE];
    int length;
&#125; Sqlist;

void bubble(Sqlist &amp;L)
&#123;
    for (int i &#x3D; L.length - 1; i &gt; 0; i--)
    &#123;
        for (int j &#x3D; 0; j &lt; i; j++)
        &#123;
            if (L.data[j] &gt; L.data[j + 1])
            &#123;
                swap(L.data[j], L.data[j + 1]);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p><strong>快速排序</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

void QuickSort(int a[], int m, int n)
&#123;
    if (m &gt;&#x3D; n)
        return;

    int low &#x3D; m;
    int high &#x3D; n;
    int pivot &#x3D; a[(m + n) &#x2F; 2];
    while (low &lt;&#x3D; high)
    &#123;
        while (a[low] &lt; pivot)
            low++;
        while (a[high] &gt; pivot)
            high--;
        if (low &lt;&#x3D; high)
        &#123;
            swap(a[low], a[high]);
            low++;
            high--;
        &#125;
    &#125;
    QuickSort(a, m, high);
    QuickSort(a, low, n);
&#125;</code></pre>
<p><strong>选择排序</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

#define MAXSIZE 100
typedef struct
&#123;
    int data[MAXSIZE];
    int length;
&#125; Sqlist;

void Select(Sqlist &amp;L)
&#123;
    for (int i &#x3D; 0; i &lt; L.length - 1; i++)
    &#123;
        int k &#x3D; i;
        for (int j &#x3D; i + 1; j &lt; L.length; j++)
        &#123;
            if (L.data[j] &lt; L.data[k])
            &#123;
                k &#x3D; j;
            &#125;
        &#125;
        if (k !&#x3D; i)
        &#123;
            swap(L.data[i], L.data[k]);
        &#125;
    &#125;
&#125;</code></pre>
<p><strong>堆排序</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

#define MAXSIZE 100

typedef struct
&#123;
    int data[MAXSIZE];
    int length;
&#125; Sqlist;

void HeapAdjust(Sqlist &amp;L, int s, int m)
&#x2F;&#x2F; s: 待调整的子树根节点下标  m：最后一个元素的下标（调整范围上限）
&#123;
    int rc &#x3D; L.data[s];
    &#x2F;&#x2F; 沿关键字较大的子节点向下筛选
    for (int j &#x3D; 2 * s + 1; j &lt;&#x3D; m; j &#x3D; 2 * j + 1) &#x2F;&#x2F; 完全二叉树 左孩子下标2k+1
    &#123;
        &#x2F;&#x2F; 比较左右孩子，j指向较大的孩子
        if (j &lt; m &amp;&amp; L.data[j] &lt; L.data[j + 1])
            j &#x3D; j + 1; &#x2F;&#x2F; 右孩子更大，j指向右孩子

        &#x2F;&#x2F; 若根节点已比最大孩子大，则调整完成
        if (rc &gt;&#x3D; L.data[j])
            break;

        L.data[s] &#x3D; L.data[j]; &#x2F;&#x2F; 将较大孩子值上移
        s &#x3D; j;                 &#x2F;&#x2F; s指向下一层待比较位置
    &#125;
    L.data[s] &#x3D; rc; &#x2F;&#x2F; 将最初根节点值放入最终位置
&#125;

void CreateHeap(Sqlist &amp;L)
&#123;
    &#x2F;&#x2F; 从最后一个非叶子节点开始向前调整
    for (int i &#x3D; L.length &#x2F; 2 - 1; i &gt;&#x3D; 0; i--)
    &#123;
        HeapAdjust(L, i, L.length - 1); &#x2F;&#x2F; 调整以i为根的子树
    &#125;
&#125;

void HeapSort(Sqlist &amp;L)
&#123;
    CreateHeap(L);

    for (int i &#x3D; L.length - 1; i &gt; 0; i--)
    &#123;
        swap(L.data[0], L.data[i]); &#x2F;&#x2F; 堆顶最大值交换到末尾
        HeapAdjust(L, 0, i - 1);    &#x2F;&#x2F; 调整剩余元素为新堆
    &#125;
&#125;</code></pre>
<p><strong>归并排序</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
#define MAXSIZE 100

typedef struct
&#123;
    int data[MAXSIZE];
    int length;
&#125; Sqlist;

void Merge(Sqlist &amp;L, int low, int mid, int high)
&#123;
    int *temp &#x3D; new int[high - low + 1];
    int i &#x3D; low;     &#x2F;&#x2F; 左半部分起始索引
    int j &#x3D; mid + 1; &#x2F;&#x2F; 右半部分起始索引
    int k &#x3D; 0;       &#x2F;&#x2F; 临时数组索引

    &#x2F;&#x2F; 合并元素到临时数组
    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; high)
    &#123;
        if (L.data[i] &lt;&#x3D; L.data[j])
            temp[k++] &#x3D; L.data[i++];
        else
            temp[k++] &#x3D; L.data[j++];
    &#125;

    &#x2F;&#x2F; 处理剩余元素
    while (i &lt;&#x3D; mid)
        temp[k++] &#x3D; L.data[i++];
    while (j &lt;&#x3D; high)
        temp[k++] &#x3D; L.data[j++];

    &#x2F;&#x2F; 将排序好的数据拷贝回原数组
    for (i &#x3D; low, k &#x3D; 0; i &lt;&#x3D; high; i++, k++)
        L.data[i] &#x3D; temp[k];

    delete[] temp; &#x2F;&#x2F; 释放临时数组
&#125;

&#x2F;&#x2F; 递归分治函数
void MSort(Sqlist &amp;L, int low, int high)
&#123;
    if (low &lt; high)
    &#123;
        int mid &#x3D; (low + high) &#x2F; 2; &#x2F;&#x2F; 计算中间位置
        MSort(L, low, mid);         &#x2F;&#x2F; 递归左半部分
        MSort(L, mid + 1, high);    &#x2F;&#x2F; 递归右半部分
        Merge(L, low, mid, high);   &#x2F;&#x2F; 合并已排序部分
    &#125;
&#125;

&#x2F;&#x2F; 归并排序入口函数
void MergeSort(Sqlist &amp;L)
&#123;
    if (L.length &lt;&#x3D; 0)
        return;
    MSort(L, 0, L.length - 1); &#x2F;&#x2F; 调用递归排序
&#125;</code></pre>
<p><strong>基数排序</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

#define MAXSIZE 100

typedef struct
&#123;
    int data[MAXSIZE];
    int length;
&#125; Sqlist;

&#x2F;&#x2F; 以位数比较为例
void RadixSort(Sqlist &amp;L)
&#123;
    if (L-&gt;length &lt;&#x3D; 1)
        return;

    int max_num &#x3D; L-&gt;data[0];
    for (int i &#x3D; 1; i &lt; L-&gt;length; ++i)
    &#123;
        if (L-&gt;data[i] &gt; max_num)
            max_num &#x3D; L-&gt;data[i];
    &#125;

    for (int exp &#x3D; 1; max_num &#x2F; exp &gt; 0; exp *&#x3D; 10)
    &#123;
        int count[10] &#x3D; &#123;0&#125;;
        int output[MAXSIZE];

        for (int i &#x3D; 0; i &lt; L-&gt;length; ++i)
        &#123;
            int digit &#x3D; (L-&gt;data[i] &#x2F; exp) % 10;
            count[digit]++;
        &#125;

        for (int j &#x3D; 1; j &lt; 10; ++j)
        &#123;
            count[j] +&#x3D; count[j - 1];
        &#125;

        for (int i &#x3D; L-&gt;length - 1; i &gt;&#x3D; 0; --i)
        &#123;
            int digit &#x3D; (L-&gt;data[i] &#x2F; exp) % 10;
            output[count[digit] - 1] &#x3D; L-&gt;data[i];
            count[digit]--;
        &#125;

        for (int i &#x3D; 0; i &lt; L-&gt;length; ++i)
        &#123;
            L-&gt;data[i] &#x3D; output[i];
        &#125;
    &#125;
&#125;</code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Sa1ntCHEN</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://saintcen.github.io/2025/09/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/">https://saintcen.github.io/2025/09/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Sa1ntCHEN</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/CS%E5%9F%BA%E7%A1%80/">
                                    <span class="chip bg-color">CS基础</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2025/10/13/MoeCTF2025_Web_wp/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="MoeCTF2025_Web_wp">
                        
                        <span class="card-title">MoeCTF2025_Web_wp</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2025-10-13
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AC%94%E8%AE%B0/" class="post-category">
                                    笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/CTF/">
                        <span class="chip bg-color">CTF</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2025/09/25/AutoDL%E5%B0%8Ftrick%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="AutoDL小trick（更新中）">
                        
                        <span class="card-title">AutoDL小trick（更新中）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2025-09-25
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%A7%91%E7%A0%94/" class="post-category">
                                    科研
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/AI/">
                        <span class="chip bg-color">AI</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>




    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="tencent"
                   type="playlist"
                   id="2870668388"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2025</span>
            
            <a href="/about" target="_blank">Sa1ntCHEN</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/SaintCEN" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:24009300521@stu.xidian.edu.cn" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2587899960" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2587899960" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.10.0/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
