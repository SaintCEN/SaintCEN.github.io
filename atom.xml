<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sa1ntCHENの小窝</title>
  
  <subtitle>Van!shment Th!s World</subtitle>
  <link href="https://saintcen.github.io/atom.xml" rel="self"/>
  
  <link href="https://saintcen.github.io/"/>
  <updated>2025-09-25T11:16:27.132Z</updated>
  <id>https://saintcen.github.io/</id>
  
  <author>
    <name>Sa1ntCHEN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构（C语言版）</title>
    <link href="https://saintcen.github.io/2025/09/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/"/>
    <id>https://saintcen.github.io/2025/09/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/</id>
    <published>2025-09-25T16:00:00.000Z</published>
    <updated>2025-09-25T11:16:27.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="data-structure">Data Structure</h1><h2 id="线性表">线性表</h2><h3 id="顺序表">顺序表</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#define MAXSIZE 100typedef int ElemType;typedef struct &#123;    ElemType *elem;    int length;&#125; Sqlist;&#x2F;&#x2F;初始化void InitList(Sqlist &amp;L) &#123;    L.elem &#x3D; new ElemType[MAXSIZE];    if (!L.elem) return;    L.length &#x3D; 0;&#125;&#x2F;&#x2F;取值void GetElem(Sqlist L, int i, ElemType &amp;e) &#123;    if (i &lt; 1 || i &gt; L.length) return;    e &#x3D; L.elem[i - 1];&#125;&#x2F;&#x2F;定位int LocateElem(Sqlist L, ElemType e) &#123;    for (int i &#x3D; 0; i &lt; L.length; i++) &#123;        if (L.elem[i] &#x3D;&#x3D; e) return i + 1;    &#125;    return 0;&#125;&#x2F;&#x2F;插入void InsertElem(Sqlist &amp;L, int i, ElemType e) &#123;    if (i &lt; 1 || i &gt; L.length + 1) return;    if (L.length &#x3D;&#x3D; MAXSIZE) return;    for (int j &#x3D; L.length - 1; j &gt;&#x3D; i - 1; j--) &#123;        L.elem[j + 1] &#x3D; L.elem[j];    &#125;    L.elem[i - 1] &#x3D; e;    L.length++;&#125;&#x2F;&#x2F;删除void DeleteElem(Sqlist &amp;L, int i) &#123;    if (i &lt; 1 || i &gt; L.length) return;    for (int j &#x3D; i; j &lt; L.length; j++) &#123;        L.elem[j - 1] &#x3D; L.elem[j];    &#125;    L.length--;&#125;</code></pre><h3 id="单链表">单链表</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;typedef int ElemType;typedef struct Node &#123;    ElemType data;    struct Node* next;&#125;Node,*LinkList;&#x2F;&#x2F; 初始化(带头结点)void InitList(LinkList &amp;L) &#123;    L &#x3D; (Node*)malloc(sizeof(Node));    L-&gt;next &#x3D; NULL;    &#x2F;&#x2F;若不带头结点，直接L &#x3D; NULL;&#125;&#x2F;&#x2F; 求表长int Length(LinkList L)&#123;    int len &#x3D; 0;    Node *p &#x3D; L;    while(p-&gt;next!&#x3D;NULL)&#123;        p &#x3D; p-&gt;next;        len++;    &#125;    return len;&#125;&#x2F;&#x2F; 取值void GetElem(LinkList L, int i, ElemType &amp;e) &#123;    Node* p &#x3D; L;    int j &#x3D; 0;    while (p &amp;&amp; j &lt; i) &#123;        p &#x3D; p-&gt;next;        j++;    &#125;    if (!p || j &gt; i) return;    e &#x3D; p-&gt;data;&#125;&#x2F;&#x2F; 查找Node* LocateNode(LinkList L, ElemType e) &#123;    Node* p &#x3D; L-&gt;next;    while (p &amp;&amp; p-&gt;data !&#x3D; e) &#123;        p &#x3D; p-&gt;next;    &#125;    return p;&#125;&#x2F;&#x2F;插入void insertNode(LinkList &amp;L, int i, ElemType e) &#123;    Node* p &#x3D; L;    int j &#x3D; 0;    while (p &amp;&amp; j &lt; i - 1) &#123;        p &#x3D; p-&gt;next;        j++;    &#125;    if (!p) return;    Node* s &#x3D; new Node;    s-&gt;data &#x3D; e;    s-&gt;next &#x3D; p-&gt;next;    p-&gt;next &#x3D; s;&#125;&#x2F;&#x2F;删除void deleteNode(LinkList &amp;L, int i) &#123;    Node* p &#x3D; L;    int j &#x3D; 0;    while (p &amp;&amp; j &lt; i - 1) &#123;        p &#x3D; p-&gt;next;        j++;    &#125;    if (!p-&gt;next||!p) return;    Node* q &#x3D; p-&gt;next;    p-&gt;next &#x3D; q-&gt;next;    delete q;&#125;&#x2F;&#x2F;头插法void createList_H(LinkList &amp;L, int n) &#123;    L &#x3D; new Node; &#x2F;&#x2F; L固定为头结点    L-&gt;next &#x3D; NULL;    for (int i &#x3D; 0; i &lt; n; i++) &#123;        Node* p &#x3D; new Node;        cin &gt;&gt; p-&gt;data;        p-&gt;next &#x3D; L-&gt;next;        L-&gt;next &#x3D; p;    &#125;&#125;&#x2F;&#x2F;尾插法void createList_R(Node* &amp;L, int n) &#123;    L &#x3D; new Node; &#x2F;&#x2F;L为固定头结点    L-&gt;next &#x3D; NULL;    Node* r &#x3D; L;    for (int i &#x3D; 0; i &lt; n; i++) &#123;        Node* p &#x3D; new Node;        cin &gt;&gt; p-&gt;data;        p-&gt;next &#x3D; NULL;        r-&gt;next &#x3D; p;        r &#x3D; p;    &#125;    &#x2F;&#x2F;循环列表，p-&gt;next &#x3D; L-&gt;next;&#125;&#x2F;&#x2F;遍历void printlist(LinkList L)&#123;     Node *p &#x3D; L;     while (p) &#123;           printf(&quot;%d &quot;, p-&gt;data);           p &#x3D; p-&gt;next;     &#125;     printf(&quot;\n&quot;);&#125;</code></pre><h3 id="双链表">双链表</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;typedef int Elemtype;&#x2F;&#x2F; 定义双链表节点typedef struct DNode &#123;    Elemtype data;    struct DNode* prior;    struct DNode* next;&#125; DNode, *DList;&#x2F;&#x2F; 初始化双链表DList initList() &#123;    DNode* head &#x3D; new DNode();    head-&gt;prior &#x3D; nullptr;    head-&gt;next &#x3D; nullptr;    return head;&#125;&#x2F;&#x2F; 创建双链表void createList(DList &amp;L, int n) &#123;    DNode* p &#x3D; L;    for (int i &#x3D; 0; i &lt; n; i++) &#123;        DNode* newNode &#x3D; new DNode;        cin &gt;&gt; newNode-&gt;data;        newNode-&gt;prior &#x3D; p;        newNode-&gt;next &#x3D; nullptr;        p-&gt;next &#x3D; newNode;        p &#x3D; newNode;    &#125;    &#x2F;&#x2F;循环链表，newNode-&gt;next &#x3D; L-&gt;next;L-&gt;next-&gt;prior &#x3D; newNode;&#125;&#x2F;&#x2F; 插入操作void insertNode(DList &amp;L, int pos, Elemtype e) &#123;    DNode* p &#x3D; L;    int i &#x3D; 0;    while (p &amp;&amp; i &lt; pos) &#123;        p &#x3D; p-&gt;next;        i++;    &#125;    if (!p) &#123;        return;    &#125;    DNode* newNode &#x3D; new DNode;    newNode-&gt;data &#x3D; e;    newNode-&gt;next &#x3D; p-&gt;next;    newNode-&gt;prior &#x3D; p;    if (p-&gt;next) &#123;        p-&gt;next-&gt;prior &#x3D; newNode;    &#125;    p-&gt;next &#x3D; newNode;&#125;&#x2F;&#x2F; 删除操作void deleteNode(DList &amp;L, int pos) &#123;    DNode* p &#x3D; L-&gt;next;    int i &#x3D; 0;    while (p &amp;&amp; i &lt; pos) &#123;        p &#x3D; p-&gt;next;        i++;    &#125;    if (!p) &#123;        return;    &#125;    if (p-&gt;prior) &#123;        p-&gt;prior-&gt;next &#x3D; p-&gt;next;    &#125;    if (p-&gt;next) &#123;        p-&gt;next-&gt;prior &#x3D; p-&gt;prior;    &#125;    delete p;&#125;&#x2F;&#x2F; 正向遍历void traverseForward(DList L) &#123;    DNode* p &#x3D; L-&gt;next;    while (p) &#123;        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        p &#x3D; p-&gt;next;    &#125;    cout &lt;&lt; endl;&#125;&#x2F;&#x2F; 反向遍历void traverseBackward(DList L) &#123;    DNode* p &#x3D; L;    while (p-&gt;next) &#123;        p &#x3D; p-&gt;next;    &#125;    while (p !&#x3D; L) &#123;        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        p &#x3D; p-&gt;prior;    &#125;    cout &lt;&lt; endl;&#125;</code></pre><h4 id="stl">STL</h4><p><strong>list</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;list&gt;#include&lt;iostream&gt;using namespace std;int main()&#123;    list&lt;int&gt; l;    &#x2F;&#x2F; 插入元素    l.push_back(10);    l.push_front(5);    &#x2F;&#x2F; 输出    for (int val : l) &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;    &#x2F;&#x2F; 查找元素    auto it &#x3D; find(l.begin(), l.end(), 10);    if (it !&#x3D; l.end()) &#123;        cout &lt;&lt; distance(l.begin(),it) &lt;&lt; endl;    &#125;    &#x2F;&#x2F; 删除元素    l.erase(l.begin());    &#x2F;&#x2F; 反转链表    l.reverse();    &#x2F;&#x2F; 排序链表    l.sort();    &#x2F;&#x2F; 删除相邻的重复元素    l.push_back(20);    l.push_back(20);    l.unique();&#125;</code></pre><h3 id="静态链表">静态链表</h3><pre class="language-c++" data-language="c++"><code class="language-c++">typedef int ElemType;#define MAXSIZE 50typedef struct&#123;    ElemType data;    int next;&#x2F;&#x2F; 存储地址(具体数值)&#125;SLinkList[MAXSIZE];</code></pre><h2 id="栈与队列">栈与队列</h2><h3 id="栈">栈</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100typedef int Elemtype;&#x2F;&#x2F;顺序存储typedef struct&#123;    Elemtype *top;    Elemtype *base;    int size;&#125; SqStack;void Init(SqStack &amp;s)&#123;    s.base &#x3D; new Elemtype[MAXSIZE];    s.top &#x3D; s.base;    s.size &#x3D; MAXSIZE;&#125;bool IsEmpty(SqStack s)&#123;    return s.base &#x3D;&#x3D; s.top;&#125;bool IsFull(SqStack s)&#123;    return (s.top - s.base) &#x3D;&#x3D; s.size;&#125;void Push(SqStack &amp;s, Elemtype e)&#123;    if (IsFull(s))    &#123;        return;    &#125;    *s.top &#x3D; e;    s.top++;&#125;Elemtype Pop(SqStack &amp;s, Elemtype &amp;e)&#123;    if (IsEmpty(s))    &#123;        return;    &#125;    s.top--;    e &#x3D; *s.top;&#125;void Print(SqStack &amp;s)&#123;    if (IsEmpty(s))    &#123;        return;    &#125;    for (Elemtype *p &#x3D; s.base; p !&#x3D; s.top; p++)    &#123;        cout &lt;&lt; *p &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;Elemtype GetTop(SqStack s)&#123;    if (IsEmpty(s))    &#123;        return;    &#125;    Elemtype e &#x3D; *s.top;    return e;&#125;&#x2F;&#x2F; 链式存储typedef struct Linknode&#123;    Elemtype data;    struct Linknode *next;&#125; Linknode, *LiStack;void Init(LiStack &amp;s)&#123;    s &#x3D; NULL;&#125;void Push(LiStack &amp;s, Elemtype e)&#123;    LiStack p &#x3D; new Linknode;    p-&gt;data &#x3D; e;    p-&gt;next &#x3D; s;    s &#x3D; p;&#125;void Pop(LiStack &amp;s, Elemtype &amp;e)&#123;    if (s &#x3D;&#x3D; NULL)        return;    e &#x3D; s-&gt;data;    LiStack p &#x3D; s;    s &#x3D; s-&gt;next;    delete p;&#125;Elemtype GetTop(LiStack s)&#123;    if (s !&#x3D; NULL)        return s-&gt;data;    return -1;&#125;&#x2F;&#x2F; 共享存储typedef struct&#123;    Elemtype *base;    Elemtype *top1;    Elemtype *top2;    int capacity;&#125; SharedStack;</code></pre><h4 id="stl-1">STL</h4><p><strong>stack</strong></p><ul><li><code>top()</code> 访问栈顶元素（如果栈为空，此处会出错）</li><li><code>push(x)</code> 向栈中插入元素 x</li><li><code>pop()</code> 删除栈顶元素</li><li><code>size()</code> 查询容器中的元素数量</li><li><code>empty()</code> 询问容器是否为空</li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;stack&gt;using namespace std;int main()&#123;stack&lt;int&gt; s1;s1.push(2);s1.push(1);cout &lt;&lt; s1.size() &lt;&lt; endl;s1.pop();s1.pop();cout &lt;&lt; s1.empty() &lt;&lt; endl;&#125;</code></pre><h3 id="队列">队列</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;#define maxsize 100typedef int ElemType;typedef struct &#123;    ElemType *base;    int front;    int rear;&#125; SqQueue;&#x2F;&#x2F; 可作为单向队列或循环队列，这里视为循环队列&#x2F;&#x2F; 初始化void InitQueue(SqQueue &amp;q) &#123;    q.base &#x3D; new ElemType[maxsize];    if (!q.base) &#123;        return;    &#125;    q.front &#x3D; 0;    q.rear &#x3D; 0;&#125;&#x2F;&#x2F; 长度int QueueLength(SqQueue q) &#123;    return (q.rear - q.front + maxsize) % maxsize;&#125;&#x2F;&#x2F; 判断是否为空bool IsEmpty(SqQueue q) &#123;    return q.front &#x3D;&#x3D; q.rear;&#125;&#x2F;&#x2F; 判断是否已满bool IsFull(SqQueue q) &#123;    return (q.rear + 1) % maxsize &#x3D;&#x3D; q.front;&#125;&#x2F;&#x2F; 入队void EnQueue(SqQueue &amp;q, ElemType e) &#123;    if (IsFull(q)) &#123;        return;    &#125;    q.base[q.rear] &#x3D; e;    q.rear &#x3D; (q.rear + 1) % maxsize;&#125;&#x2F;&#x2F; 出队void DeQueue(SqQueue &amp;q, ElemType &amp;e) &#123;    if (IsEmpty(q)) &#123;        return;    &#125;    e &#x3D; q.base[q.front];    q.front &#x3D; (q.front + 1) % maxsize;&#125;&#x2F;&#x2F; 获取队头元素ElemType GetHead(SqQueue q) &#123;    if (!IsEmpty(q)) &#123;        return q.base[q.front];    &#125;    return -1;&#125;&#x2F;&#x2F; 打印void PrintQueue(SqQueue q) &#123;    if (IsEmpty(q)) &#123;        return;    &#125;    int i &#x3D; q.front;    while (i !&#x3D; q.rear) &#123;        cout &lt;&lt; q.base[i] &lt;&lt; &quot; &quot;;        i &#x3D; (i + 1) % maxsize;    &#125;    cout &lt;&lt; endl;&#125;&#x2F;&#x2F; 队列链式存储(带头结点)&#x2F;&#x2F; 节点定义typedef struct QNode&#123;    ElemType data;    struct QNode *next;&#125;QNode;&#x2F;&#x2F; 链队列定义typedef struct &#123;    QNode *front;    QNode *rear;&#125;LinkQueue;&#x2F;&#x2F; 初始化队列void InitQueue(LinkQueue &amp;Q) &#123;    Q.front &#x3D; new QNode;    Q.rear &#x3D; Q.front;    Q.front-&gt;next &#x3D; NULL;&#125;&#x2F;&#x2F; 判断为空bool IsEmpty(LinkQueue Q)&#123;    return (Q.front &#x3D;&#x3D; Q.rear);&#125;&#x2F;&#x2F; 入队操作void EnQueue(LinkQueue &amp;Q, ElemType e) &#123;    QNode *newNode &#x3D; new QNode;    newNode-&gt;data &#x3D; e;    newNode-&gt;next &#x3D; NULL;    Q.rear-&gt;next &#x3D; newNode;    Q.rear &#x3D; newNode;&#125;&#x2F;&#x2F; 出队操作void DeQueue(LinkQueue &amp;Q, ElemType &amp;e) &#123;    if (IsEmpty(Q)) &#123;        return;    &#125;    QNode *temp &#x3D; Q.front-&gt;next;    e &#x3D; temp-&gt;data;    Q.front-&gt;next &#x3D; temp-&gt;next;    if (temp &#x3D;&#x3D; Q.rear) &#123;        Q.rear &#x3D; Q.front;    &#125;    delete temp;&#125;&#x2F;&#x2F; 获取队头元素ElemType GetFront(LinkQueue Q) &#123;    if (IsEmpty(Q)) &#123;        return -1;    &#125;    return Q.front-&gt;next-&gt;data;&#125;</code></pre><h4 id="stl-2">STL</h4><p><strong>queue</strong></p><ul><li><code>front()</code> 访问队首元素（如果队列为空，此处会出错）</li><li><code>push(x)</code> 向队列中插入元素 x</li><li><code>pop()</code> 删除队首元素</li><li><code>size()</code> 查询容器中的元素数量</li><li><code>empty()</code> 询问容器是否为空</li></ul><p><strong>deque</strong></p><ul><li><code>push_front(x)</code> 在队首插入元素 x</li><li><code>push_back(x)</code> 在队尾插入元素 x</li><li><code>pop_front()</code> 删除队首元素</li><li><code>pop_back()</code> 删除队尾元素</li><li><code>front()</code> 访问队首元素</li><li><code>back()</code> 访问队尾元素</li><li><code>size()</code> 查询元素数量</li><li><code>empty()</code> 判断是否为空</li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;queue&gt;#include&lt;iostream&gt;using namespace std;int main()&#123;&#x2F;&#x2F; 单向队列queue&lt;int&gt; q1;q1.push(2);q1.push(1);q1.pop();cout &lt;&lt; q1.size() &lt;&lt; endl;cout &lt;&lt; q1.front() &lt;&lt; endl;q1.pop();cout &lt;&lt; q1.empty() &lt;&lt; endl;&#x2F;&#x2F; 双向队列deque&lt;int&gt; dq;dq.push_back(3);dq.push_front(1);dq.pop_front();dq.push_front(5);dq.pop_back();dq.pop_back();cout &lt;&lt; dq.size() &lt;&lt; endl;cout &lt;&lt; dq.empty() &lt;&lt; endl;&#125;</code></pre><h4 id="优先队列priority_queue">优先队列(priority_queue)</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 默认最小堆(原理其实是构建完全二叉树进行堆排序，因此初始化时有数组和比较条件)priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq&#x2F;&#x2F; 自定义堆struct cmp &#123;    bool operator()(int a, int b) &#123;        return a &lt; b; &#x2F;&#x2F; 最大堆    &#125;&#125;;priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; pq;&#x2F;&#x2F; 插入元素int element &#x3D; 1;pq.push(element);&#x2F;&#x2F; 访问顶部元素int top &#x3D; pq.top();&#x2F;&#x2F; 删除顶部元素pq.pop();&#x2F;&#x2F; 检查是否为空bool isEmpty &#x3D; pq.empty();&#x2F;&#x2F; 获取元素数量size_t size &#x3D; pq.size();</code></pre><h3 id="数组">数组</h3><p>以二维数组为例：</p><p><span class="math display"><em>L</em><em>O</em><em>C</em>(<em>i</em>, <em>j</em>) = <em>L</em><em>O</em><em>C</em>(0, 0) + (<em>n</em> * <em>i</em> + <em>j</em>) * <em>L</em></span></p><p>其中<span class="math inline"><em>L</em></span>为每个数组元素所占的单元。</p><p><strong>特殊矩阵的压缩存储</strong></p><p>1.对称矩阵</p><p>对于 n 阶矩阵 A，若<span class="math inline"><em>a</em><sub><em>i</em>, <em>j</em></sub> = <em>a</em><sub><em>j</em>, <em>i</em></sub></span>，则为对称矩阵。假设我们要压缩成一维数组，求解下标<span class="math inline"><em>k</em></span>有以下公式：</p><p><span class="math display">$$i&gt;=j,k = \frac{i(i-1)}{2}+j-1\\i&lt;j,k = \frac{j(j-1)}{2}+i-1\\$$</span></p><p>2.三角矩阵</p><p><span class="math display">$$上三角：i&gt;j,k =\frac{n(n+1)}{2},i&lt;=j,\frac{(2n-i+2)(i-1)}{2}+j-i\\下三角：i&gt;j,k = \frac{i(i-1)}{2}+j-1,i&lt;=j,\frac{n(n+1)}{2}$$</span></p><p>3.带状矩阵</p><p>第 1 行和第 n行有两个元，其余行均有三个元，（形成三条对角线），对<span class="math inline"><em>a</em><sub><em>i</em>, <em>j</em></sub></span>若压缩成一维矩阵有：</p><p><span class="math display"><em>k</em> = 2<em>i</em> + <em>j</em> − 3</span></p><p>4.稀疏矩阵</p><p>将稀疏分布的矩阵转为三元组（行标<span class="math inline"><em>i</em></span>，列标<span class="math inline"><em>j</em></span>，值<span class="math inline"><em>a</em><sub><em>i</em>, <em>j</em></sub></span>）</p><pre class="language-c++" data-language="c++"><code class="language-c++">typedef struct&#123;    int col;    int row;    int data;&#125;Matrix;</code></pre><h4 id="stl-3">STL</h4><p><strong>vector</strong></p><ul><li><p><code>push_back(x)</code> 在尾部插入元素 x</p></li><li><p><code>pop_back()</code> 删除尾部元素</p></li><li><p><code>front()</code> 访问首元素</p></li><li><p><code>back()</code> 访问尾元素</p></li><li><p><code>size()</code> 查询元素数量</p></li><li><p><code>empty()</code> 判断是否为空</p></li><li><p><code>clear()</code> 清空所有元素</p></li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;vector&gt;#include&lt;iostream&gt;using namespace std;int main()&#123;vector&lt;int&gt; vec;vec.push_back(1);vec.push_back(2);vec.pop_back();vec.push_back(3);cout &lt;&lt; vec.size() &lt;&lt; endl;cout &lt;&lt; vec.front() &lt;&lt; endl;cout &lt;&lt; vec.back() &lt;&lt; endl;cout &lt;&lt; vec[1] &lt;&lt; endl;vec.clear();cout &lt;&lt; vec.empty() &lt;&lt; endl;vector&lt;vector&lt;int&gt;&gt; matrix(3, vector&lt;int&gt;(2, 0));&#x2F;&#x2F; 3行，2列，每行填充0matrix[0][0] &#x3D; 1;matrix[1].push_back(3);vector&lt;int&gt; new_row &#x3D; &#123;5, 7, 9&#125;;matrix.push_back(new_row);for (int i &#x3D; 0; i &lt; matrix.size(); i++) &#123;    for (int j &#x3D; 0; j &lt; matrix[i].size(); j++) &#123;          cout &lt;&lt; matrix[i][j] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;&#125;</code></pre><h2 id="串">串</h2><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;#define maxlen 255&#x2F;&#x2F; 顺序存储typedef struct&#123;    char ch[maxlen];    int length;&#125;SString;&#x2F;&#x2F; 堆分配存储typedef struct&#123;    char *ch;    int length;&#125;HString;&#x2F;&#x2F; 链式存储typedef struct CharNode &#123;    char ch;    struct CharNode *next;&#125; CharNode, *CharPtr;typedef struct &#123;    CharPtr head;    int length;&#125; LString;&#x2F;&#x2F; 字串定位算法&#x2F;&#x2F; Brute-Forceint BF(SString s,SSting t,int pos)&#123;    int i &#x3D; pos;    int j &#x3D; 1;    while(i&lt;&#x3D;s.length &amp;&amp; j&lt;&#x3D;t.length())&#123;        if(s.ch[i]&#x3D;&#x3D;t.ch[j])&#123;            i++;            j++;        &#125;            else&#123;                i &#x3D; i - j + 2;                j &#x3D; 1;        &#125;    &#125;   if(j&gt;t.length) return i-t.length;   else return 0;&#125;&#x2F;&#x2F; KMPvector&lt;int&gt; Next(const string &amp;j) &#123;    int m &#x3D; j.length();    vector&lt;int&gt; next(m + 1, 0);    int k &#x3D; 0;    next[0] &#x3D; -1;    for (int i &#x3D; 1; i &lt; m; i++) &#123;        while (k &gt;&#x3D; 0 &amp;&amp; j[i] !&#x3D; j[k]) &#123;            k &#x3D; next[k];        &#125;        k++;        next[i + 1] &#x3D; k;    &#125;    return next;&#125;void KMP(const string &amp;t, const string &amp;j) &#123;    int n &#x3D; t.length();    int m &#x3D; j.length();        return;    &#125;    vector&lt;int&gt; next &#x3D; Next(j);    int i &#x3D; 0;    int k &#x3D; 0;    while (i &lt; n) &#123;        if (k &#x3D;&#x3D; -1 || t[i] &#x3D;&#x3D; j[k]) &#123;            i++;            k++;            if (k &#x3D;&#x3D; m) &#123;                cout &lt;&lt; t.substr(i - m) &lt;&lt; endl;                return;            &#125;        &#125; else &#123;            k &#x3D; next[k];        &#125;    return;&#125;</code></pre><h4 id="stl-4">STL</h4><p><strong>string</strong></p><p>长度：<code>s.size()</code>/<code>s.length()</code></p><p>查找字符（串）第一次出现的位置：<code>s.find(u)</code>/<code>s.find(t,pos)</code><strong>注：不是 KMP</strong></p><p>截取子串：<code>substr(pos,len)</code></p><p>插入：<code>insert(index,str)</code></p><p>替换字符串：<code>replace(first,second,str)</code></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123;string s &#x3D; &quot;hello, world&quot;;cout &lt;&lt; s.size() &lt;&lt; endl;size_t pos1 &#x3D; s.find(&#39;o&#39;);size_t pos2 &#x3D; s.find(&quot;world&quot;, 0);string sub &#x3D; s.substr(7, 5);string s2 &#x3D; s;s2.insert(5, &quot; C++&quot;);string s3 &#x3D; s;s3.replace(0, 5, &quot;Hi&quot;);&#125;</code></pre><h3 id="广义表">广义表</h3><pre class="language-c++" data-language="c++"><code class="language-c++">typedef enum(ATOM,LIST) ElemTag;&#x2F;&#x2F;ATOM&#x3D;&#x3D;0,原子；LIST&#x3D;&#x3D;1，子表typedef struct GLNode&#123;    ElemTag tag;&#x2F;&#x2F;区分原子结点or表结点    union&#123;        AtomType atom;&#x2F;&#x2F;原子值域        struct&#123;            struct GNode* hp,*tp;        &#125;ptr;    &#125;;&#125;*GList;GetHead(LS);&#x2F;&#x2F;取表头GetTail(LS);&#x2F;&#x2F;取表尾，仍为广义表</code></pre><h2 id="树">树</h2><h4 id="二叉树">二叉树</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;#define MAXSIZE 100typedef int TElemType;&#x2F;&#x2F; 顺序存储结构（即层序遍历，空结点值为0）typedef struct&#123;    TElemType data[MAXSIZE];&#125;SqBiTree;&#x2F;&#x2F; 链式定义结点结构typedef struct BiTNode &#123;    TElemType data;    BiTNode *lchild, *rchild;&#125; BiTNode, *BiTree;&#x2F;&#x2F; 中序遍历（递归）void InOrderTraverse(BiTree T) &#123;    if (T) &#123;        InOrderTraverse(T-&gt;lchild);        cout &lt;&lt; T-&gt;data;        InOrderTraverse(T-&gt;rchild);    &#125;&#125;&#x2F;&#x2F; 先序遍历（递归）void PreOrderTraverse(BiTree T) &#123;    if (T) &#123;        cout &lt;&lt; T-&gt;data;        PreOrderTraverse(T-&gt;lchild);        PreOrderTraverse(T-&gt;rchild);    &#125;&#125;&#x2F;&#x2F; 后序遍历（递归）void PostOrderTraverse(BiTree T) &#123;    if (T) &#123;        PostOrderTraverse(T-&gt;lchild);        PostOrderTraverse(T-&gt;rchild);        cout &lt;&lt; T-&gt;data;    &#125;&#125;&#x2F;&#x2F; 中序遍历（非递归）void InOrderTraverse_NonRecursive(BiTree T) &#123;    stack&lt;BiTree&gt; s;    BiTree p &#x3D; T;    while (p || !s.empty()) &#123;        if (p) &#123;            s.push(p);            p &#x3D; p-&gt;lchild;        &#125; else &#123;            BiTree q &#x3D; s.top();            s.pop();            cout &lt;&lt; q-&gt;data;            p &#x3D; q-&gt;rchild;        &#125;    &#125;&#125;&#x2F;&#x2F; 先序遍历（非递归）void PreOrderTraverse_NonRecursive(BiTree T) &#123;    if (!T) return;    stack&lt;BiTree&gt; s;    s.push(T);    while (!s.empty()) &#123;        BiTree q &#x3D; s.top();        s.pop();        cout &lt;&lt; q-&gt;data;        if (q-&gt;rchild) s.push(q-&gt;rchild); &#x2F;&#x2F; 右子树后访问 根据栈先进后出的原则先进        if (q-&gt;lchild) s.push(q-&gt;lchild);    &#125;&#125;&#x2F;&#x2F; 后序遍历（非递归）void PostOrderTraverse_NonRecursive(BiTree T) &#123;    stack&lt;BiTree&gt; s;    BiTree p &#x3D; T;    BiTree lastVisited &#x3D; nullptr;    while (p || !s.empty()) &#123;        if (p) &#123;            s.push(p);            p &#x3D; p-&gt;lchild;        &#125; else &#123;            BiTree q &#x3D; s.top();            if (q-&gt;rchild &amp;&amp; lastVisited !&#x3D; q-&gt;rchild) &#123;                p &#x3D; q-&gt;rchild;            &#125; else &#123;                cout &lt;&lt; q-&gt;data;                lastVisited &#x3D; q;                s.pop();            &#125;        &#125;    &#125;&#125;&#x2F;&#x2F; 层次遍历二叉树void LevelOrderTraverse(BiTree T) &#123;    if (!T) return;    queue&lt;BiTree&gt; q;    q.push(T);    while (!q.empty()) &#123;        BiTree node &#x3D; q.front();        q.pop();        cout &lt;&lt; node-&gt;data &lt;&lt; &#39; &#39;;        if (node-&gt;lchild)            q.push(node-&gt;lchild);        if (node-&gt;rchild)            q.push(node-&gt;rchild);    &#125;&#125;&#x2F;&#x2F; 根据前序输入创建二叉树，&#39;#&#39;表示空节点void CreateBiTree(BiTree &amp;T) &#123;    char ch;    cin &gt;&gt; ch;    if (ch &#x3D;&#x3D; &#39;#&#39;) &#123;        T &#x3D; nullptr;    &#125; else &#123;        T &#x3D; new BiTNode;        T-&gt;data &#x3D; ch;        CreateBiTree(T-&gt;lchild);        CreateBiTree(T-&gt;rchild);    &#125;&#125;&#x2F;&#x2F; 根据中序输入创建二叉树，&#39;#&#39;表示空节点void CreateBiTree(BiTree &amp;T) &#123;    char ch;    cin &gt;&gt; ch;    if (ch &#x3D;&#x3D; &#39;#&#39;) &#123;        T &#x3D; nullptr;    &#125; else &#123;        CreateBiTree(T-&gt;lchild);        T &#x3D; new BiTNode;        T-&gt;data &#x3D; ch;        CreateBiTree(T-&gt;rchild);    &#125;&#125;&#x2F;&#x2F; 根据后序输入创建二叉树，&#39;#&#39;表示空节点void CreateBiTree(BiTree &amp;T) &#123;    char ch;    cin &gt;&gt; ch;    if (ch &#x3D;&#x3D; &#39;#&#39;) &#123;        T &#x3D; nullptr;    &#125; else &#123;        CreateBiTree(T-&gt;lchild);        CreateBiTree(T-&gt;rchild);        T &#x3D; new BiTNode;        T-&gt;data &#x3D; ch;    &#125;&#125;&#x2F;&#x2F; 计算二叉树的高度int Depth(BiTree T) &#123;    if (!T) return 0;    int m &#x3D; Depth(T-&gt;lchild);    int n &#x3D; Depth(T-&gt;rchild);    return (m &gt; n ? m + 1 : n + 1);&#125;&#x2F;&#x2F; 统计二叉树的节点个数int NodeCount(BiTree T) &#123;    if (!T) return 0;    return NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + 1;&#125;&#x2F;&#x2F; 线索二叉树的结点结构typedef struct BiThrNode &#123;    TElemType data;    BiThrNode *lchild, *rchild;    int LTag, RTag; &#x2F;&#x2F; 0 表示指针，1 表示线索&#125; BiThrNode, *BiThrTree;&#x2F;&#x2F; 全局变量，用于中序线索化过程中的前驱节点BiThrNode *pre &#x3D; nullptr;&#x2F;&#x2F; 中序线索化（递归）void InThreading(BiThrTree p) &#123;    if (p) &#123;        InThreading(p-&gt;lchild);        if (!p-&gt;lchild) &#123;            p-&gt;LTag &#x3D; 1;            p-&gt;lchild &#x3D; pre;        &#125; else &#123;            p-&gt;LTag &#x3D; 0;        &#125;        if (pre &amp;&amp; !pre-&gt;rchild) &#123;            pre-&gt;RTag &#x3D; 1;            pre-&gt;rchild &#x3D; p;        &#125; else if &#123;            pre-&gt;RTag &#x3D; 0;        &#125;        pre &#x3D; p;        InThreading(p-&gt;rchild);    &#125;&#125;&#x2F;&#x2F; 构建中序线索二叉树（带头结点）void CreateInOrderThread(BiThrTree &amp;T) &#123;    BiThrTree head &#x3D; new BiThrNode;    head-&gt;LTag &#x3D; 0;    head-&gt;RTag &#x3D; 1;    head-&gt;rchild &#x3D; head;    pre &#x3D; head;    head-&gt;lchild &#x3D; T;    InThreading(T);    pre-&gt;rchild &#x3D; head;    pre-&gt;RTag &#x3D; 1;    T &#x3D; head;&#125;&#x2F;&#x2F; 遍历中序线索二叉树（非递归）void InOrderTraverse_Thr(BiThrTree T) &#123;    BiThrTree p &#x3D; T-&gt;lchild;    while (p !&#x3D; T) &#123;        while (p-&gt;LTag &#x3D;&#x3D; 0) p &#x3D; p-&gt;lchild;        cout &lt;&lt; p-&gt;data;        while (p-&gt;RTag &#x3D;&#x3D; 1 &amp;&amp; p-&gt;rchild !&#x3D; T) &#123;            p &#x3D; p-&gt;rchild;            cout &lt;&lt; p-&gt;data;        &#125;        p &#x3D; p-&gt;rchild;    &#125;&#125;</code></pre><h4 id="树与森林">树与森林</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#define MAXSIZE 100&#x2F;&#x2F; 双亲表示法typedef struct&#123;    char data;    int parent;&#125;PTNode;typedef struct&#123;    PTNode nodes[MAXSIZE];    int n;&#125;PTree;&#x2F;&#x2F; 孩子表示法typedef struct CSNode&#123;    char data;    struct CSNode* firstchild,*nextsibling;&#125;CSNode,*CSTree;</code></pre><h4 id="哈夫曼树">哈夫曼树</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;typedef struct&#123;    int weight;    int parent, lchild, rchild;&#125; HTNode, *HuffmanTree;typedef char **HuffmanCode;void CreateHuffmanTree(HuffmanTree &amp;T, int n)&#123;    if (n &lt;&#x3D; 1)        return;    int m &#x3D; 2 * n - 1;    T &#x3D; new HTNode[m + 1];    &#x2F;&#x2F; 初始化所有节点    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    &#123;        T[i].parent &#x3D; 0;        T[i].lchild &#x3D; 0;        T[i].rchild &#x3D; 0;        T[i].weight &#x3D; 0;    &#125;    &#x2F;&#x2F; 输入叶子节点权重    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    &#123;        cin &gt;&gt; T[i].weight;    &#125;    &#x2F;&#x2F; 使用优先队列存储    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    &#123;        pq.push(make_pair(T[i].weight, i));    &#125;    int current &#x3D; n + 1; &#x2F;&#x2F; 当前中间节点索引    for (int i &#x3D; 1; i &lt;&#x3D; n - 1; i++)    &#123;        &#x2F;&#x2F; 获取两个最小节点        int s1 &#x3D; -1, s2 &#x3D; -1;        &#x2F;&#x2F; 寻找第一个有效节点        while (!pq.empty() &amp;&amp; s1 &#x3D;&#x3D; -1)        &#123;            auto top &#x3D; pq.top();            pq.pop();            if (T[top.second].parent &#x3D;&#x3D; 0)            &#123;                s1 &#x3D; top.second;            &#125;        &#125;        &#x2F;&#x2F; 寻找第二个有效节点        while (!pq.empty() &amp;&amp; s2 &#x3D;&#x3D; -1)        &#123;            auto top &#x3D; pq.top();            pq.pop();            if (T[top.second].parent &#x3D;&#x3D; 0)            &#123;                s2 &#x3D; top.second;            &#125;        &#125;        if (s1 &#x3D;&#x3D; -1 || s2 &#x3D;&#x3D; -1)        &#123;            return;        &#125;        &#x2F;&#x2F; 创建新节点        T[current].weight &#x3D; T[s1].weight + T[s2].weight;        T[current].lchild &#x3D; s1;        T[current].rchild &#x3D; s2;        T[s1].parent &#x3D; current;        T[s2].parent &#x3D; current;        &#x2F;&#x2F; 将新节点加入优先队列        pq.push(make_pair(T[current].weight, current));        current++;    &#125;&#125;void CreateHuffmanCode(HuffmanTree HT, HuffmanCode &amp;HC, int n)&#123;    HC &#x3D; new char *[n + 1];    char *cd &#x3D; new char[n];    cd[n - 1] &#x3D; &#39;\0&#39;;    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    &#123;        int start &#x3D; n - 1;        int c &#x3D; i;        int f &#x3D; HT[i].parent;        while (f !&#x3D; 0)        &#123;            start--;            if (HT[f].lchild &#x3D;&#x3D; c)            &#123;                cd[start] &#x3D; &#39;0&#39;;            &#125;            else            &#123;                cd[start] &#x3D; &#39;1&#39;;            &#125;            c &#x3D; f;            f &#x3D; HT[f].parent;        &#125;        HC[i] &#x3D; new char[n - start];        strcpy(HC[i], &amp;cd[start]);    &#125;    delete[] cd;&#125;</code></pre><h4 id="并查集">并查集</h4><pre class="language-c++" data-language="c++"><code class="language-c++">const int MAXN &#x3D; 1000;int father[MAXN];int Rank[MAXN];void init()&#123;    for (int i &#x3D; 0; i &lt; MAXN; i++)    &#123;        father[i] &#x3D; i;        Rank[i] &#x3D; 1;    &#125;&#125;int find_set(int x)&#123;    if (x !&#x3D; father[x])    &#123;        father[x] &#x3D; find_set(father[x]);    &#125;    return father[x];&#125;void Union(int x, int y)&#123;    int root_x &#x3D; find_set(x);    int root_y &#x3D; find_set(y);    if (root_x &#x3D;&#x3D; root_y)        return;    if (Rank[root_x] &gt; Rank[root_y])    &#123;        father[root_y] &#x3D; root_x;        Rank[root_x] +&#x3D; Rank[root_y];    &#125;    else    &#123;        father[root_x] &#x3D; root_y;        Rank[root_y] +&#x3D; Rank[root_x];    &#125;&#125;</code></pre><h2 id="图">图</h2><p><strong>邻接矩阵</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define MaxInt 32767     &#x2F;&#x2F; 极大值#define MVNum 100        &#x2F;&#x2F; 顶点最大值typedef char VerTexType; &#x2F;&#x2F; 顶点类型定义typedef int ArcType;     &#x2F;&#x2F; 边类型定义&#x2F;&#x2F; 邻接矩阵表示法typedef struct&#123;    VerTexType vexs[MVNum];     &#x2F;&#x2F; 顶点表    ArcType arcs[MVNum][MVNum]; &#x2F;&#x2F; 邻接矩阵    int vexnum, arcnum; &#x2F;&#x2F; 顶点数目 边数目&#125; AMGraph;&#x2F;&#x2F; 为AMGraph定位顶点int LocateVex(AMGraph G, VerTexType v)&#123;    for (int i &#x3D; 0; i &lt; G.vexnum; i++)    &#123;        if (G.vexs[i] &#x3D;&#x3D; v)        &#123;            return i;        &#125;    &#125;    return -1;&#125;&#x2F;&#x2F; 初始化邻接矩阵void CreateAM(AMGraph &amp;G)&#123;    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;    for (int i &#x3D; 0; i &lt; G.vexnum; i++)    &#123;        cin &gt;&gt; G.vexs[i];    &#125;    for (int i &#x3D; 0; i &lt; G.vexnum; i++)    &#123;        for (int j &#x3D; 0; j &lt; G.vexnum; j++)        &#123;            if (i &#x3D;&#x3D; j)            &#123;                G.arcs[i][j] &#x3D; 0;            &#125;            else            &#123;                G.arcs[i][j] &#x3D; MaxInt;            &#125;        &#125;    &#125;    for (int k &#x3D; 0; k &lt; G.arcnum; k++)    &#123;        VerTexType v1, v2;        ArcType w;        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;        int i &#x3D; LocateVex(G, v1);        int j &#x3D; LocateVex(G, v2);        G.arcs[i][j] &#x3D; w;        G.arcs[j][i] &#x3D; w;    &#125;&#125;</code></pre><p><strong>邻接表</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;&#x2F;&#x2F; 邻接表表示法typedef struct ArcNode&#123;    int adjvex; &#x2F;&#x2F; 该边指向的顶点位置    int weight; &#x2F;&#x2F; 边的权重    struct ArcNode *nextarc;&#125; ArcNode;typedef struct VNode&#123;    VerTexType data;   &#x2F;&#x2F; 顶点信息    ArcNode *firstarc; &#x2F;&#x2F; 指向第一条边的指针&#125; VNode, AdjList[MVNum];typedef struct&#123;    AdjList vertices;   &#x2F;&#x2F; 邻接表    int vexnum, arcnum; &#x2F;&#x2F; 顶点数和边数&#125; ALGraph;&#x2F;&#x2F; 为 ALGraph 定位顶点int LocateVex(const ALGraph &amp;G, VerTexType v)&#123;    for (int i &#x3D; 0; i &lt; G.vexnum; i++)    &#123;        if (G.vertices[i].data &#x3D;&#x3D; v)        &#123;            return i;        &#125;    &#125;    return -1;&#125;&#x2F;&#x2F; 初始化邻接表void CreateAL(ALGraph &amp;G)&#123;    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;    for (int i &#x3D; 0; i &lt; G.vexnum; i++)    &#123;        cin &gt;&gt; G.vertices[i].data;        G.vertices[i].firstarc &#x3D; NULL;    &#125;    for (int k &#x3D; 0; k &lt; G.arcnum; k++)    &#123;        VerTexType v1, v2;        ArcType weight;        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; weight;        int i &#x3D; LocateVex(G, v1);        int j &#x3D; LocateVex(G, v2);        &#x2F;&#x2F; 添加边 v1 -&gt; v2 头插法        ArcNode *p1 &#x3D; new ArcNode;        p1-&gt;adjvex &#x3D; j;        p1-&gt;weight &#x3D; weight;        p1-&gt;nextarc &#x3D; G.vertices[i].firstarc;        G.vertices[i].firstarc &#x3D; p1;        &#x2F;* 添加边 v2 -&gt; v1（无向图必须对称）        ArcNode *p2 &#x3D; new ArcNode;        p2-&gt;adjvex &#x3D; i;        p2-&gt;weight &#x3D; weight;        p2-&gt;nextarc &#x3D; G.vertices[j].firstarc;        G.vertices[j].firstarc &#x3D; p2;        *&#x2F;    &#125;&#125;</code></pre><p><strong>十字链表</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 十字链表表示法（有向图）typedef struct ArcNode_OL &#123;    int tailvex;             &#x2F;&#x2F; 弧尾顶点位置    int headvex;             &#x2F;&#x2F; 弧头顶点位置    struct ArcNode_OL *hlink; &#x2F;&#x2F; 指向同一弧头的下一条弧    struct ArcNode_OL *tlink; &#x2F;&#x2F; 指向同一弧尾的下一条弧    int weight;              &#x2F;&#x2F; 弧的权值    InfoType info;        &#x2F;&#x2F; 其他信息&#125; ArcNode_OL;typedef struct VexNode_OL &#123;    VerTexType data;         &#x2F;&#x2F; 顶点数据    ArcNode_OL *firstin;     &#x2F;&#x2F; 指向以该顶点为弧头的第一条弧    ArcNode_OL *firstout;    &#x2F;&#x2F; 指向以该顶点为弧尾的第一条弧&#125; VexNode_OL;typedef struct &#123;    VexNode_OL xlist[MVNum]; &#x2F;&#x2F; 顶点表    int vexnum, arcnum;      &#x2F;&#x2F; 顶点数和弧数&#125; OLGraph;</code></pre><p><strong>邻接多重表</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 邻接多重表表示法（无向图）typedef struct EBox &#123;    int ivex, jvex;          &#x2F;&#x2F; 该边依附的两个顶点位置    struct EBox *ilink;      &#x2F;&#x2F; 指向依附于顶点ivex的下一条边    struct EBox *jlink;      &#x2F;&#x2F; 指向依附于顶点jvex的下一条边    int weight;              &#x2F;&#x2F; 边的权值    bool mark;             &#x2F;&#x2F; 访问标记    InfoType info;         &#x2F;&#x2F; 其他信息&#125; EBox;typedef struct VexBox &#123;    VerTexType data;         &#x2F;&#x2F; 顶点数据    EBox *firstedge;         &#x2F;&#x2F; 指向第一条依附于该顶点的边&#125; VexBox;typedef struct &#123;    VexBox adjmulist[MVNum]; &#x2F;&#x2F; 顶点表    int vexnum, edgenum;     &#x2F;&#x2F; 顶点数和边数&#125; AMLGraph;</code></pre><p><strong>DFS</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int MVNum &#x3D; 100;bool visited[MVNum];vector&lt;int&gt; path;struct AMGraph&#123;    int arcs[MVNum][MVNum];    int vexnum, arcnum;&#125;;struct ArcNode&#123;    int adjvex;    ArcNode *nextarc;&#125;;struct VNode&#123;    ArcNode *firstarc;&#125;;struct ALGraph&#123;    VNode vertices[MVNum];    int vexnum, arcnum;&#125;;void DFS_AM(AMGraph G, int v)&#123;    cout &lt;&lt; v &lt;&lt; &quot; &quot;;    visited[v] &#x3D; true;    path.push_back(v);    for (int w &#x3D; 0; w &lt; G.vexnum; w++)        if (G.arcs[v][w] &amp;&amp; !visited[w])            DFS_AM(G, w);&#125;void DFS_AL(ALGraph G, int v)&#123;    cout &lt;&lt; v &lt;&lt; &quot; &quot;;    visited[v] &#x3D; true;    path.push_back(v);    ArcNode *p &#x3D; G.vertices[v].firstarc;    while (p)    &#123;        int w &#x3D; p-&gt;adjvex;        if (!visited[w])            DFS_AL(G, w);        p &#x3D; p-&gt;nextarc;    &#125;&#125;void DFSTraverse_AM(AMGraph G)&#123;    path.clear();    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)        visited[i] &#x3D; false;    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)        if (!visited[i])            DFS_AM(G, i);&#125;void DFSTraverse_AL(ALGraph G)&#123;    path.clear();    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)        visited[i] &#x3D; false;    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)        if (!visited[i])            DFS_AL(G, i);&#125;void PrintPath()&#123;    for (size_t i &#x3D; 0; i &lt; path.size(); ++i) &#123;        cout &lt;&lt; path[i];        if (i &lt; path.size() - 1)            cout &lt;&lt; &quot; -&gt; &quot;;    &#125;    cout &lt;&lt; endl;&#125;</code></pre><p><strong>BFS</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int MVNum &#x3D; 100;bool visited[MVNum];vector&lt;int&gt; path;struct AMGraph&#123;    int arcs[MVNum][MVNum];    int vexnum, arcnum;&#125;;struct ArcNode&#123;    int adjvex;    ArcNode *nextarc;&#125;;struct VNode&#123;    ArcNode *firstarc;&#125;;struct ALGraph&#123;    VNode vertices[MVNum];    int vexnum, arcnum;&#125;;void BFS_AM(AMGraph G, int v)&#123;    queue&lt;int&gt; Q;    cout &lt;&lt; v &lt;&lt; &quot; &quot;;    visited[v] &#x3D; true;    path.push_back(v);    Q.push(v);    while (!Q.empty())    &#123;        int u &#x3D; Q.front();        Q.pop();        for (int w &#x3D; 0; w &lt; G.vexnum; w++)        &#123;            if (G.arcs[u][w] &amp;&amp; !visited[w])            &#123;                cout &lt;&lt; w &lt;&lt; &quot; &quot;;                visited[w] &#x3D; true;                path.push_back(w);                Q.push(w);            &#125;        &#125;    &#125;&#125;void BFS_AL(ALGraph G, int v)&#123;    queue&lt;int&gt; Q;    cout &lt;&lt; v &lt;&lt; &quot; &quot;;    visited[v] &#x3D; true;    path.push_back(v);    Q.push(v);    while (!Q.empty())    &#123;        int u &#x3D; Q.front();        Q.pop();        ArcNode *p &#x3D; G.vertices[u].firstarc;        while (p)        &#123;            int w &#x3D; p-&gt;adjvex;            if (!visited[w])            &#123;                cout &lt;&lt; w &lt;&lt; &quot; &quot;;                visited[w] &#x3D; true;                path.push_back(w);                Q.push(w);            &#125;            p &#x3D; p-&gt;nextarc;        &#125;    &#125;&#125;void BFSTraverse_AM(AMGraph G)&#123;    path.clear();    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)        visited[i] &#x3D; false;    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)        if (!visited[i])            BFS_AM(G, i);&#125;void BFSTraverse_AL(ALGraph G)&#123;    path.clear();    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)        visited[i] &#x3D; false;    for (int i &#x3D; 0; i &lt; G.vexnum; ++i)        if (!visited[i])            BFS_AL(G, i);&#125;void PrintPath()&#123;    for (size_t i &#x3D; 0; i &lt; path.size(); ++i) &#123;        cout &lt;&lt; path[i];        if (i &lt; path.size() - 1)            cout &lt;&lt; &quot; -&gt; &quot;;    &#125;    cout &lt;&lt; endl;&#125;</code></pre><p><strong>最小生成树（MST）</strong></p><p><strong>Kruskal</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;#define MAXVEX 100#define INF 114514typedef struct &#123;    int adjvex;    int weight;    struct ArcNode *next;&#125; ArcNode;typedef struct &#123;    ArcNode *firstarc;&#125; AdjList[MAXVEX];typedef struct &#123;    AdjList vertices;    int vexnum, arcnum;&#125; Graph;bool hasCycle(Graph &amp;G, int from, int to, vector&lt;bool&gt;&amp; visited, int parent) &#123;    visited[from] &#x3D; true;    ArcNode* p &#x3D; G.vertices[from].firstarc;    while(p) &#123;        int next &#x3D; p-&gt;adjvex;        if(!visited[next]) &#123;        if(hasCycle(G, next, to, visited, from)) &#123;                return true;            &#125;        &#125;        else if( next !&#x3D; parent &amp;&amp; next &#x3D;&#x3D; to) &#123;            return true;        &#125;        p &#x3D; p-&gt;next;    &#125;    return false;&#125;bool isSafe(Graph &amp;G, int from, int to) &#123;    vector&lt;bool&gt; visited(G.vexnum + 1, false);    return !hasCycle(G, from, to, visited, -1);&#125;void CreateGraph(Graph &amp;G) &#123;    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;    for(int i&#x3D;1; i&lt;&#x3D;G.vexnum; i++) &#123;        G.vertices[i].firstarc &#x3D; nullptr;    &#125;    for(int i&#x3D;1; i&lt;&#x3D;G.arcnum; i++) &#123;        int m,n,w;        cin &gt;&gt; m &gt;&gt; n &gt;&gt; w;        ArcNode *p1 &#x3D; new ArcNode;        p1-&gt;adjvex &#x3D; n;        p1-&gt;weight &#x3D; w;        p1-&gt;next &#x3D; G.vertices[m].firstarc;        G.vertices[m].firstarc &#x3D; p1;        ArcNode *p2 &#x3D; new ArcNode;        p2-&gt;adjvex &#x3D; m;        p2-&gt;weight &#x3D; w;        p2-&gt;next &#x3D; G.vertices[n].firstarc;        G.vertices[n].firstarc &#x3D; p2;    &#125;&#125;void PrintMST(vector&lt;vector&lt;int&gt;&gt; &amp;mst, int n) &#123;    for(int i&#x3D;1; i&lt;&#x3D;n; i++) &#123;        for(int j&#x3D;i+1; j&lt;&#x3D;n; j++) &#123;            if(mst[i][j] !&#x3D; 0) &#123;                cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;            &#125;        &#125;    &#125;&#125;int main() &#123;    Graph G;    CreateGraph(G);    vector&lt;vector&lt;int&gt;&gt; mst(G.vexnum+1, vector&lt;int&gt;(G.vexnum+1, 0));    int MSTedge &#x3D; 0;    while(MSTedge &lt; G.vexnum-1) &#123;        int min &#x3D; INF;        int p1 &#x3D; -1, p2 &#x3D; -1;        for(int i&#x3D;1; i&lt;&#x3D;G.vexnum; i++) &#123;            ArcNode *p &#x3D; G.vertices[i].firstarc;            while(p) &#123;                if(p-&gt;weight &lt; min &amp;&amp; !mst[i][p-&gt;adjvex] &amp;&amp; isSafe(G, i, p-&gt;adjvex)) &#123;                    min &#x3D; p-&gt;weight;                    p1 &#x3D; i;                    p2 &#x3D; p-&gt;adjvex;                &#125;                p &#x3D; p-&gt;next;            &#125;        &#125;        if(p1 &#x3D;&#x3D; -1) &#123;            cout &lt;&lt; &quot;Invalid.&quot; &lt;&lt; endl;            return 1;        &#125;        mst[p1][p2] &#x3D; 1;        mst[p2][p1] &#x3D; 1;        MSTedge++;    &#125;    PrintMST(mst, G.vexnum);    return 0;&#125;</code></pre><p><strong>Prim</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;#define INF 32366#define MAX_VERTICES 100typedef struct &#123;    int edges[MAX_VERTICES][MAX_VERTICES];    int edgeCount;    int vertexCount;&#125; Graph;void printMST(vector&lt;vector&lt;int&gt;&gt;&amp; mst, int n) &#123;    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        for(int j &#x3D; i + 1; j &lt;&#x3D; n; j++) &#123;            if(mst[i][j] &#x3D;&#x3D; 1) &#123;                cout &lt;&lt; i &lt;&lt; &quot; - &quot; &lt;&lt; j &lt;&lt; endl;            &#125;        &#125;    &#125;&#125;int main() &#123;    int n;    cin &gt;&gt; n;    Graph g;    g.edgeCount &#x3D; n - 1;    g.vertexCount &#x3D; n;    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;            g.edges[i][j] &#x3D; INF;        &#125;    &#125;    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        int from, to, weight;        cin &gt;&gt; from &gt;&gt; to &gt;&gt; weight;        g.edges[from][to] &#x3D; weight;        g.edges[to][from] &#x3D; weight;    &#125;    vector&lt;bool&gt; visited(n + 1, false);    vector&lt;vector&lt;int&gt;&gt; mst(n + 1, vector&lt;int&gt;(n + 1, 0));    visited[1] &#x3D; true;    int mstEdgeCount &#x3D; 0;    while(mstEdgeCount &lt; n - 1) &#123;        int minWeight &#x3D; INF;        int minFrom &#x3D; -1;        int minTo &#x3D; -1;        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;            if(visited[i]) &#123;                for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;                    if(!visited[j] &amp;&amp; g.edges[i][j] &lt; minWeight) &#123;                        minWeight &#x3D; g.edges[i][j];                        minFrom &#x3D; i;                        minTo &#x3D; j;                    &#125;                &#125;            &#125;        &#125;        if(minFrom &#x3D;&#x3D; -1) &#123;            cout &lt;&lt; &quot;Invalid.&quot; &lt;&lt; endl;            return 1;        &#125;        mst[minFrom][minTo] &#x3D; 1;        mst[minTo][minFrom] &#x3D; 1;        visited[minTo] &#x3D; true;        mstEdgeCount++;    &#125;    printMST(mst, n);    return 0;&#125;</code></pre><p><strong>最短路径</strong></p><p><strong>Dijkstra</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define MVNum 100#define INF 114154typedef struct&#123;    char vexs[MVNum];    int arcs[MVNum][MVNum];    int vexNum, arcNum;&#125; Graph;int LocateVex(const Graph &amp;G, char v)&#123;    for (int i &#x3D; 0; i &lt; G.vexNum; ++i)    &#123;        if (G.vexs[i] &#x3D;&#x3D; v)            return i;    &#125;    return -1;&#125;void Create(Graph &amp;G)&#123;    cin &gt;&gt; G.vexNum &gt;&gt; G.arcNum;    for (int i &#x3D; 1; i &lt;&#x3D; G.vexNum; i++)    &#123;        cin &gt;&gt; G.vexs[i];    &#125;    for (int i &#x3D; 1; i &lt;&#x3D; G.vexNum; i++)    &#123;        for(int j&#x3D;1;j&lt;&#x3D;G.vexNum;j++)        &#123;            G.arcs[i][j]&#x3D;INF;            if(i&#x3D;&#x3D;j)            &#123;                G.arcs[i][j]&#x3D;0;            &#125;        &#125;    &#125;    for (int k &#x3D; 1; k &lt;&#x3D; G.arcNum; k++)    &#123;        char v1, v2;        int w;        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;        int i &#x3D; LocateVex(G, v1);        int j &#x3D; LocateVex(G, v2);        if (i !&#x3D; -1 &amp;&amp; j !&#x3D; -1)        &#123;            G.arcs[i][j] &#x3D; w;        &#125;    &#125;&#125;void Dijkstra(Graph &amp;G, char start)&#123;    int v0 &#x3D; LocateVex(G,start);    int n &#x3D; G.vexNum;    vector&lt;int&gt; dist(n + 1, INF);    vector&lt;bool&gt; visited(n + 1, false);    vector&lt;int&gt; path(n + 1, -1);    dist[v0] &#x3D; 0;    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        int u &#x3D; -1;        int minDist &#x3D; INF;        for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;            if(!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123;                u &#x3D; j;                minDist &#x3D; dist[j];            &#125;        &#125;        if(u &#x3D;&#x3D; -1) break;        visited[u] &#x3D; true;        for(int v &#x3D; 1; v &lt;&#x3D; n; v++) &#123;            if(!visited[v] &amp;&amp; G.arcs[u][v] !&#x3D; INF) &#123;                if(dist[u] + G.arcs[u][v] &lt; dist[v]) &#123;                    dist[v] &#x3D; dist[u] + G.arcs[u][v];                    path[v] &#x3D; u;  &#x2F;&#x2F; 记录路径                &#125;            &#125;        &#125;    &#125;    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        if(i !&#x3D; v0) &#123;            if(dist[i] &#x3D;&#x3D; INF) &#123;                cout &lt;&lt; &quot;Invalid.&quot; &lt;&lt; endl;            &#125; else &#123;                cout &lt;&lt; dist[i] &lt;&lt; endl;                cout &lt;&lt; start;                vector&lt;int&gt; route;                int k &#x3D; i;                while(k !&#x3D; -1) &#123;                    route.push_back(k);                    k &#x3D; path[k];                &#125;                for(int r &#x3D; route.size()-1; r &gt;&#x3D; 0; r--) &#123;                    cout &lt;&lt; &quot; -&gt; &quot; &lt;&lt; G.vexs[route[r]];                &#125;                cout &lt;&lt; endl;            &#125;        &#125;    &#125;&#125;int main()&#123;    Graph G;    Create(G);    char start;    cin &gt;&gt; start;    Dijkstra(G, start);    return 0;&#125;</code></pre><p><strong>Floyd</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define MVNum 100#define INF 114154typedef struct&#123;    char vexs[MVNum];    int arcs[MVNum][MVNum];    int vexNum, arcNum;&#125; Graph;int LocateVex(const Graph &amp;G, char v)&#123;    for (int i &#x3D; 0; i &lt; G.vexNum; ++i)    &#123;        if (G.vexs[i] &#x3D;&#x3D; v)            return i;    &#125;    return -1;&#125;void Create(Graph &amp;G)&#123;    cin &gt;&gt; G.vexNum &gt;&gt; G.arcNum;    for (int i &#x3D; 1; i &lt;&#x3D; G.vexNum; i++)    &#123;        cin &gt;&gt; G.vexs[i];    &#125;    for (int i &#x3D; 1; i &lt;&#x3D; G.vexNum; i++)    &#123;        for(int j&#x3D;1;j&lt;&#x3D;G.vexNum;j++)        &#123;            G.arcs[i][j]&#x3D;INF;            if(i&#x3D;&#x3D;j)            &#123;                G.arcs[i][j]&#x3D;0;            &#125;        &#125;    &#125;    for (int k &#x3D; 1; k &lt;&#x3D; G.arcNum; k++)    &#123;        char v1, v2;        int w;        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;        int i &#x3D; LocateVex(G, v1);        int j &#x3D; LocateVex(G, v2);        if (i !&#x3D; -1 &amp;&amp; j !&#x3D; -1)        &#123;            G.arcs[i][j] &#x3D; w;        &#125;    &#125;&#125;void Floyd(Graph &amp;G)&#123;    int n &#x3D; G.vexNum;    vector&lt;vector&lt;int&gt;&gt; dist(n + 1, vector&lt;int&gt;(n + 1));    vector&lt;vector&lt;int&gt;&gt; path(n + 1, vector&lt;int&gt;(n + 1, -1));    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;            dist[i][j] &#x3D; G.arcs[i][j];            if(dist[i][j] &lt; INF &amp;&amp; i !&#x3D; j) &#123;                path[i][j] &#x3D; i;            &#125;        &#125;    &#125;    for(int k &#x3D; 1; k &lt;&#x3D; n; k++) &#123;        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;            for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;                if(dist[i][k] !&#x3D; INF &amp;&amp; dist[k][j] !&#x3D; INF &amp;&amp;                   dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;                    dist[i][j] &#x3D; dist[i][k] + dist[k][j];                    path[i][j] &#x3D; path[k][j];                &#125;            &#125;        &#125;    &#125;    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;            if(i !&#x3D; j) &#123;                cout &lt;&lt; G.vexs[i] &lt;&lt; &quot; &quot; &lt;&lt; G.vexs[j];                if(dist[i][j] &#x3D;&#x3D; INF) &#123;                    cout &lt;&lt; &quot;Invalid.&quot; &lt;&lt; endl;                &#125; else &#123;                    cout &lt;&lt; dist[i][j] &lt;&lt; endl;                    cout &lt;&lt; G.vexs[i];                    int k &#x3D; path[i][j];                    vector&lt;int&gt; route;                    while(k !&#x3D; -1) &#123;                        route.push_back(k);                        k &#x3D; path[i][k];                    &#125;                    for(int r &#x3D; route.size()-1; r &gt;&#x3D; 0; r--) &#123;                        cout &lt;&lt; &quot; -&gt; &quot; &lt;&lt; G.vexs[route[r]];                    &#125;                    cout &lt;&lt; &quot; -&gt; &quot; &lt;&lt; G.vexs[j] &lt;&lt; endl;                &#125;            &#125;        &#125;    &#125;&#125;int main()&#123;    Graph G;    Create(G);    Floyd(G);    return 0;&#125;</code></pre><p><strong>拓扑排序</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define MVNum 100typedef struct &#123;    char vexs[MVNum];    int arcs[MVNum][MVNum];    int vexNum, arcNum;&#125; Graph;int LocateVex(const Graph &amp;G, char v) &#123;    for (int i &#x3D; 0; i &lt; G.vexNum; ++i) &#123;        if (G.vexs[i] &#x3D;&#x3D; v)            return i;    &#125;    return -1;&#125;void CreateGraph(Graph &amp;G) &#123;    cin &gt;&gt; G.vexNum &gt;&gt; G.arcNum;    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;        cin &gt;&gt; G.vexs[i];    &#125;    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;        for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123;            G.arcs[i][j] &#x3D; 0;        &#125;    &#125;    for (int k &#x3D; 0; k &lt; G.arcNum; k++) &#123;        char v1, v2;        cin &gt;&gt; v1 &gt;&gt; v2;        int i &#x3D; LocateVex(G, v1);        int j &#x3D; LocateVex(G, v2);        if (i !&#x3D; -1 &amp;&amp; j !&#x3D; -1) &#123;            G.arcs[i][j] &#x3D; 1;  &#x2F;&#x2F; 有向图        &#125;    &#125;&#125;bool TopologicalSort(Graph &amp;G) &#123;    vector&lt;int&gt; inDegree(G.vexNum, 0);    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;        for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123;            if (G.arcs[j][i] &#x3D;&#x3D; 1) &#123;                inDegree[i]++;            &#125;        &#125;    &#125;    queue&lt;int&gt; q;    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;        if (inDegree[i] &#x3D;&#x3D; 0) &#123;            q.push(i);        &#125;    &#125;    int count &#x3D; 0;    vector&lt;char&gt; result;    while (!q.empty()) &#123;        int v &#x3D; q.front();        q.pop();        result.push_back(G.vexs[v]);        count++;        for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;            if (G.arcs[v][i] &#x3D;&#x3D; 1) &#123;                inDegree[i]--;                if (inDegree[i] &#x3D;&#x3D; 0) &#123;                    q.push(i);                &#125;            &#125;        &#125;    &#125;    if (count &#x3D;&#x3D; G.vexNum) &#123;        for (char c : result) &#123;            cout &lt;&lt; c &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;        return true;    &#125; else &#123;        return false;    &#125;&#125;int main() &#123;    Graph G;    CreateGraph(G);    TopologicalSort(G);    return 0;&#125;</code></pre><p><strong>关键路径</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define MVNum 100#define INF 114154typedef struct &#123;    char vexs[MVNum];    int arcs[MVNum][MVNum];    int vexNum, arcNum;&#125; Graph;int LocateVex(const Graph &amp;G, char v) &#123;    for (int i &#x3D; 0; i &lt; G.vexNum; ++i) &#123;        if (G.vexs[i] &#x3D;&#x3D; v)            return i;    &#125;    return -1;&#125;void CreateGraph(Graph &amp;G) &#123;    cin &gt;&gt; G.vexNum &gt;&gt; G.arcNum;    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;        cin &gt;&gt; G.vexs[i];    &#125;    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;        for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123;            G.arcs[i][j] &#x3D; 0;        &#125;    &#125;    for (int k &#x3D; 0; k &lt; G.arcNum; k++) &#123;        char v1, v2;        int w;        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;        int i &#x3D; LocateVex(G, v1);        int j &#x3D; LocateVex(G, v2);        if (i !&#x3D; -1 &amp;&amp; j !&#x3D; -1) &#123;            G.arcs[i][j] &#x3D; w;        &#125;    &#125;&#125;bool TopologicalSort(Graph &amp;G, vector&lt;int&gt; &amp;topoOrder) &#123;    vector&lt;int&gt; inDegree(G.vexNum, 0);    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;        for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123;            if (G.arcs[j][i] !&#x3D; 0) &#123;                inDegree[i]++;            &#125;        &#125;    &#125;    queue&lt;int&gt; q;    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;        if (inDegree[i] &#x3D;&#x3D; 0) &#123;            q.push(i);        &#125;    &#125;    while (!q.empty()) &#123;        int v &#x3D; q.front();        q.pop();        topoOrder.push_back(v);        for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;            if (G.arcs[v][i] !&#x3D; 0) &#123;                inDegree[i]--;                if (inDegree[i] &#x3D;&#x3D; 0) &#123;                    q.push(i);                &#125;            &#125;        &#125;    &#125;    return topoOrder.size() &#x3D;&#x3D; G.vexNum;&#125;void CalculateVE(Graph &amp;G, const vector&lt;int&gt; &amp;topoOrder, vector&lt;int&gt; &amp;ve) &#123;    &#x2F;&#x2F; 初始化ve数组    ve.resize(G.vexNum, 0);    &#x2F;&#x2F; 按拓扑顺序计算ve    for (int i &#x3D; 0; i &lt; topoOrder.size(); i++) &#123;        int u &#x3D; topoOrder[i];        for (int v &#x3D; 0; v &lt; G.vexNum; v++) &#123;            if (G.arcs[u][v] !&#x3D; 0) &#123;                ve[v] &#x3D; max(ve[v], ve[u] + G.arcs[u][v]);            &#125;        &#125;    &#125;&#125;void CalculateVL(Graph &amp;G, const vector&lt;int&gt; &amp;topoOrder, const vector&lt;int&gt; &amp;ve, vector&lt;int&gt; &amp;vl) &#123;    &#x2F;&#x2F; 初始化vl数组    vl.resize(G.vexNum, ve[topoOrder.back()]);    &#x2F;&#x2F; 按逆拓扑顺序计算vl    for (int i &#x3D; topoOrder.size() - 1; i &gt;&#x3D; 0; i--) &#123;        int u &#x3D; topoOrder[i];        for (int v &#x3D; 0; v &lt; G.vexNum; v++) &#123;            if (G.arcs[u][v] !&#x3D; 0) &#123;                vl[u] &#x3D; min(vl[u], vl[v] - G.arcs[u][v]);            &#125;        &#125;    &#125;&#125;void FindCriticalPath(Graph &amp;G, const vector&lt;int&gt; &amp;ve, const vector&lt;int&gt; &amp;vl) &#123;    for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123;        for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123;            if (G.arcs[i][j] !&#x3D; 0) &#123;                int e &#x3D; ve[i];  &#x2F;&#x2F; 活动最早开始时间                int l &#x3D; vl[j] - G.arcs[i][j];  &#x2F;&#x2F; 活动最晚开始时间                if (e &#x3D;&#x3D; l) &#123;  &#x2F;&#x2F; 关键活动                    cout &lt;&lt; G.vexs[i] &lt;&lt; &quot; &quot; &lt;&lt; G.vexs[j] &lt;&lt; &quot; &quot; &lt;&lt; G.arcs[i][j] &lt;&lt; endl;                &#125;            &#125;        &#125;    &#125;&#125;int main() &#123;    Graph G;    CreateGraph(G);    vector&lt;int&gt; topoOrder;    if (!TopologicalSort(G, topoOrder)) &#123;        cout &lt;&lt; &quot;ERROR&quot; &lt;&lt; endl;        return 0;    &#125;    vector&lt;int&gt; ve, vl;    CalculateVE(G, topoOrder, ve);    CalculateVL(G, topoOrder, ve, vl);    FindCriticalPath(G, ve, vl);    return 0;&#125;</code></pre><h3 id="查找">查找</h3><h4 id="线性表-1">线性表</h4><p><strong>顺序查找</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">typedef struct&#123;    KeyType key;    InfoType otherinfo;&#125;ElemType;typedef struct&#123;    ElemType *R;    int length;&#125;SSTable;int Search_Seq(SSTable ST,KeyType key)&#123;    for(int i&#x3D;ST.length;i&gt;&#x3D;1;i--)&#123;        if(ST.R[i],key&#x3D;&#x3D;key)&#123;            return i;        &#125;    &#125;    return 0;&#125;</code></pre><p><strong>二分查找</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">typedef struct&#123;    KeyType key;    InfoType otherinfo;&#125;ElemType;typedef struct&#123;    ElemType *R;    int length;&#125;SSTable;int Search_Bin(SSTable ST,KeyType key)&#123;    int low &#x3D; 1;    int high &#x3D; ST.length;    while(low&lt;&#x3D;high)&#123;        int mid &#x3D; (low+high) &lt;&lt; 1;        if(key&#x3D;&#x3D;ST.R[mid].key)&#123;            return mid;        &#125;        else if(key&lt;ST.R[mid].key)&#123;            high &#x3D; mid - 1;        &#125;        else&#123;            low &#x3D; mid + 1;        &#125;    &#125;    return 0;&#125;</code></pre><p><strong>分块查找</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">typedef struct&#123;    KeyType key;    InfoType otherinfo;&#125;ElemType;typedef struct&#123;    ElemType *R;    int length;&#125;SSTable;typedef struct &#123;    KeyType max_key; &#x2F;&#x2F; 块内最大关键字    int start;       &#x2F;&#x2F; 块起始位置    int end;         &#x2F;&#x2F; 块结束位置&#125; IndexBlock;int BlockSearch(SSTable ST, IndexBlock index[], int index_len, KeyType key) &#123;    int low &#x3D; 0, high &#x3D; index_len - 1;    int block_idx &#x3D; -1;    &#x2F;&#x2F; 二分查找确定所在块    while (low &lt;&#x3D; high) &#123;        int mid &#x3D; (low + high) &#x2F; 2;        if (key &lt;&#x3D; index[mid].max_key) &#123;            block_idx &#x3D; mid;            high &#x3D; mid - 1;        &#125; else &#123;            low &#x3D; mid + 1;        &#125;    &#125;    if (block_idx &#x3D;&#x3D; -1)        return -1;    &#x2F;&#x2F; 在块内顺序查找    for (int i &#x3D; index[block_idx].start; i &lt;&#x3D; index[block_idx].end; ++i) &#123;        if (ST.R[i].key &#x3D;&#x3D; key)            return i;    &#125;    return -1;&#125;</code></pre><h4 id="树表">树表</h4><p><strong>二叉排序树</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">typedef struct&#123;    KeyType key;    InfoType otherinfo;&#125;ElemType;typedef struct BSTNode&#123;    ElemType data;    struct BSTNode *lchild,*rchild;&#125;BSTNode,*BSTree;BSTree SearchBST(BSTree T,KeyType key)&#123;    if(!T || key&#x3D;&#x3D;T-&gt;data.key)&#123;        return T;    &#125;    else if(key&lt;T-&gt;data.key)&#123;        return SearchBST(T-&gt;lchild,key);    &#125;    else&#123;        return SearchBST(T-&gt;rchild,key);    &#125;&#125;void InsertBST(BSTree &amp;T,ElemType e)&#123;    if(!T)&#123;        BSTNode S &#x3D; new BSTNode;        S-&gt;data &#x3D; e;        S-&gt;lchild &#x3D; NULL;        S-&gt;rchild &#x3D; NULL;        T &#x3D; S;    &#125;    else if(e.key&lt;T-&gt;data.key)&#123;        InsertBST(T-&gt;lchild,e);    &#125;    else if(e.key&gt;T-&gt;data.key)&#123;        InsertBST(T-&gt;rchild,e);    &#125;&#125;void CreateBST(BSTree &amp;T)&#123;    int e;    T &#x3D; NULL;    cin &gt;&gt; e;    while(e.key!&#x3D;-1)&#123;        InsertBST(T,e);        cin &gt;&gt; e;    &#125;&#125;void DeleteBST(BSTree &amp;T, KeyType key) &#123;    BSTree p &#x3D; T;      &#x2F;&#x2F; 当前节点指针    BSTree f &#x3D; NULL;   &#x2F;&#x2F; 父节点指针    &#x2F;&#x2F; 查找删除节点    while (p) &#123;        if (p-&gt;data.key &#x3D;&#x3D; key) break;        f &#x3D; p;        if (p-&gt;data.key &gt; key) p &#x3D; p-&gt;lchild;        else p &#x3D; p-&gt;rchild;    &#125;    if (!p) return;    BSTree q &#x3D; p;      &#x2F;&#x2F; 辅助指针 q 指向待删除节点    &#x2F;&#x2F; Case 1: 节点 p 是叶子节点或仅有一个子树    if (!p-&gt;lchild) &#123;        &#x2F;&#x2F; 左子树为空，用右子树替换        if (!f) T &#x3D; p-&gt;rchild;              &#x2F;&#x2F; p 是根节点        else if (f-&gt;lchild &#x3D;&#x3D; p) f-&gt;lchild &#x3D; p-&gt;rchild;        else f-&gt;rchild &#x3D; p-&gt;rchild;        free(q);    &#125; else if (!p-&gt;rchild) &#123; &#x2F;&#x2F; 右子树为空，用左子树替换        if (!f) T &#x3D; p-&gt;lchild;              &#x2F;&#x2F; p 是根节点        else if (f-&gt;lchild &#x3D;&#x3D; p) f-&gt;lchild &#x3D; p-&gt;lchild;        else f-&gt;rchild &#x3D; p-&gt;lchild;        free(q);    &#125; else &#123;        &#x2F;&#x2F; Case 2: 节点 p 有两个子树，找左子树的最右节点（前驱）        BSTree s &#x3D; p-&gt;lchild;        BSTree parent_s &#x3D; p; &#x2F;&#x2F; s 的父节点        while (s-&gt;rchild) &#123;            parent_s &#x3D; s;            s &#x3D; s-&gt;rchild;        &#125;        &#x2F;&#x2F; 用前驱 s 替换 p 的值        p-&gt;data &#x3D; s-&gt;data;        &#x2F;&#x2F; 删除前驱节点 s（此时 s 至多有一个左子树）        if (parent_s &#x3D;&#x3D; p) parent_s-&gt;lchild &#x3D; s-&gt;lchild;        else parent_s-&gt;rchild &#x3D; s-&gt;lchild;        free(s);    &#125;&#125;</code></pre><h4 id="哈希表">哈希表</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;string&gt;using namespace std;&#x2F;&#x2F; 拉链法static const int tableSize &#x3D; 10;vector&lt;list&lt;pair&lt;int, string&gt;&gt;&gt; chainTable(tableSize);int hashFunction(int key)&#123;    return key % tableSize;&#125;void insertChaining(int key, string value)&#123;    int index &#x3D; hashFunction(key);    chainTable[index].push_back(make_pair(key, value));&#125;string searchChaining(int key)&#123;    int index &#x3D; hashFunction(key);    for (auto &amp;p : chainTable[index])    &#123;        if (p.first &#x3D;&#x3D; key)            return p.second;    &#125;    return &quot;&quot;;&#125;void removeChaining(int key)&#123;    int index &#x3D; hashFunction(key);    auto &amp;chain &#x3D; chainTable[index];    for (auto it &#x3D; chain.begin(); it !&#x3D; chain.end(); ++it)    &#123;        if (it-&gt;first &#x3D;&#x3D; key)        &#123;            chain.erase(it);            return;        &#125;    &#125;&#125;&#x2F;&#x2F; 开放定址法（以线性探测为例）enum EntryState &#123; EMPTY, OCCUPIED, DELETED &#125;;struct HashEntry &#123;    int key;    string value;    EntryState state;&#125;;vector&lt;HashEntry&gt; openTable(tableSize, &#123;0, &quot;&quot;, EMPTY&#125;);int hashFunctionLP(int key)&#123;    return key % tableSize;&#125;void insertLinear(int key, string value)&#123;    int idx &#x3D; hashFunctionLP(key);    for (int i &#x3D; 0; i &lt; tableSize; ++i)    &#123;        int probe &#x3D; (idx + i) % tableSize;        if (openTable[probe].state &#x3D;&#x3D; EMPTY || openTable[probe].state &#x3D;&#x3D; DELETED)        &#123;            openTable[probe].key &#x3D; key;            openTable[probe].value &#x3D; value;            openTable[probe].state &#x3D; OCCUPIED;            return;        &#125;    &#125;&#125;string searchLinear(int key)&#123;    int idx &#x3D; hashFunctionLP(key);    for (int i &#x3D; 0; i &lt; tableSize; ++i)    &#123;        int probe &#x3D; (idx + i) % tableSize;        if (openTable[probe].state &#x3D;&#x3D; EMPTY)            return &quot;&quot;;        if (openTable[probe].state &#x3D;&#x3D; OCCUPIED &amp;&amp; openTable[probe].key &#x3D;&#x3D; key)            return openTable[probe].value;    &#125;    return &quot;&quot;;&#125;void removeLinear(int key)&#123;    int idx &#x3D; hashFunctionLP(key);    for (int i &#x3D; 0; i &lt; tableSize; ++i)    &#123;        int probe &#x3D; (idx + i) % tableSize;        if (openTable[probe].state &#x3D;&#x3D; EMPTY)            return;        if (openTable[probe].state &#x3D;&#x3D; OCCUPIED &amp;&amp; openTable[probe].key &#x3D;&#x3D; key)        &#123;            openTable[probe].state &#x3D; DELETED;            return;        &#125;    &#125;&#125;</code></pre><h4 id="stl-5">STL</h4><p><strong>unordered_set</strong></p><ul><li><code>insert(x)</code> 向集合中插入元素 x（若已存在，则不插入）</li><li><code>erase(x)</code> 从集合中删除元素 x</li><li><code>find(x)</code> 查找元素 x，返回迭代器；若未找到，返回<code>end()</code></li><li><code>count(x)</code> 统计元素 x 在集合中出现的次数（要么 0，要么1）</li><li><code>size()</code> 查询集合中元素数量</li><li><code>empty()</code> 判断集合是否为空</li><li><code>clear()</code> 清空集合中的所有元素</li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;unordered_set&gt;using namespace std;int main()&#123;    unordered_set&lt;int&gt; us;    us.insert(3);    us.insert(1);    us.insert(4)    us.insert(1);    cout &lt;&lt; us.size() &lt;&lt; endl;    cout &lt;&lt; (us.find(2) !&#x3D; us.end()) &lt;&lt; endl;    cout &lt;&lt; us.count(1) &lt;&lt; endl;    us.erase(3);    us.clear();    cout &lt;&lt; us.empty() &lt;&lt; endl;&#125;</code></pre><p><strong>unordered_map</strong></p><ul><li><code>insert({k, v})</code> 向映射中插入键值对<code>(k, v)</code>（若键已存在，不插入）</li><li><code>erase(k)</code> 删除键为 k 的元素</li><li><code>find(k)</code> 查找键为 k的元素，返回指向该元素的迭代器；若未找到，返回 <code>end()</code></li><li><code>count(k)</code> 统计键 k 在映射中出现的次数（要么 0，要么1）</li><li><code>operator[](k)</code> 如果键 k存在，返回对应的值；否则插入一个键为k、值为默认构造的元素并返回其引用</li><li><code>size()</code> 查询映射中元素数量</li><li><code>empty()</code> 判断映射是否为空</li><li><code>clear()</code> 清空映射中的所有元素</li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;int main()&#123;    unordered_map&lt;string, int&gt; um;    um.insert(&#123;&quot;apple&quot;, 3&#125;);    um.insert(make_pair(&quot;banana&quot;, 5));    um[&quot;cherry&quot;] &#x3D; 2;    cout &lt;&lt; um.size() &lt;&lt; endl;    cout &lt;&lt; um[&quot;cherry&quot;] &lt;&lt; endl;    auto it &#x3D; um.find(&quot;banana&quot;);    if (it !&#x3D; um.end()) &#123;        cout &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    um.erase(&quot;apple&quot;);    um.clear();    cout &lt;&lt; um.empty() &lt;&lt; endl;&#125;</code></pre><h3 id="排序">排序</h3><p><strong>插入排序</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;typedef struct&#123;    int *r;    int length;&#125; SqList;void InsertSort(SqList &amp;L)&#123;    for (int i &#x3D; 1; i &lt; L.length; i++)    &#123;        int temp &#x3D; L.r[i];        int j &#x3D; i - 1;        while (j &gt;&#x3D; 0 &amp;&amp; L.r[j] &gt; temp)        &#123;            L.r[j + 1] &#x3D; L.r[j];            j--;        &#125;        L.r[j + 1] &#x3D; temp;    &#125;&#125;&#x2F;&#x2F; 二分查找插入位置void BinaryInsertSort(SqList &amp;L)&#123;    for (int i &#x3D; 1; i &lt; L.length; i++)    &#123;        int temp &#x3D; L.r[i];        int start &#x3D; 0;        int end &#x3D; i - 1;        while (start &lt;&#x3D; end)        &#123;            int mid &#x3D; (start + end) &#x2F; 2;            if (L.r[mid] &gt; temp)            &#123;                end &#x3D; mid - 1;            &#125;            else            &#123;                start &#x3D; mid + 1;            &#125;        &#125;        for (int j &#x3D; i - 1; j &gt;&#x3D; start; j--)        &#123;            L.r[j + 1] &#x3D; L.r[j];        &#125;        L.r[start] &#x3D; temp;    &#125;&#125;</code></pre><p><strong>希尔排序</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100typedef struct&#123;    int data[MAXSIZE];    int length;&#125; Sqlist;void ShellSort(Sqlist &amp;L)&#123;    &#x2F;&#x2F; 初始间隔（gap）为长度的一半，逐步缩小间隔直到1    for (int gap &#x3D; L.length &#x2F; 2; gap &gt; 0; gap &#x2F;&#x3D; 2)    &#123;        &#x2F;&#x2F; 对每个子序列进行插入排序        for (int i &#x3D; gap; i &lt; L.length; i++)        &#123;            int temp &#x3D; L.data[i];            int j;            for (j &#x3D; i; j &gt;&#x3D; gap &amp;&amp; L.data[j - gap] &gt; temp; j -&#x3D; gap)            &#123;                L.data[j] &#x3D; L.data[j - gap];            &#125;            L.data[j] &#x3D; temp;        &#125;    &#125;&#125;</code></pre><p><strong>冒泡排序</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100typedef struct&#123;    int data[MAXSIZE];    int length;&#125; Sqlist;void bubble(Sqlist &amp;L)&#123;    for (int i &#x3D; L.length - 1; i &gt; 0; i--)    &#123;        for (int j &#x3D; 0; j &lt; i; j++)        &#123;            if (L.data[j] &gt; L.data[j + 1])            &#123;                swap(L.data[j], L.data[j + 1]);            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>快速排序</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;void QuickSort(int a[], int m, int n)&#123;    if (m &gt;&#x3D; n)        return;    int low &#x3D; m;    int high &#x3D; n;    int pivot &#x3D; a[(m + n) &#x2F; 2];    while (low &lt;&#x3D; high)    &#123;        while (a[low] &lt; pivot)            low++;        while (a[high] &gt; pivot)            high--;        if (low &lt;&#x3D; high)        &#123;            swap(a[low], a[high]);            low++;            high--;        &#125;    &#125;    QuickSort(a, m, high);    QuickSort(a, low, n);&#125;</code></pre><p><strong>选择排序</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100typedef struct&#123;    int data[MAXSIZE];    int length;&#125; Sqlist;void Select(Sqlist &amp;L)&#123;    for (int i &#x3D; 0; i &lt; L.length - 1; i++)    &#123;        int k &#x3D; i;        for (int j &#x3D; i + 1; j &lt; L.length; j++)        &#123;            if (L.data[j] &lt; L.data[k])            &#123;                k &#x3D; j;            &#125;        &#125;        if (k !&#x3D; i)        &#123;            swap(L.data[i], L.data[k]);        &#125;    &#125;&#125;</code></pre><p><strong>堆排序</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100typedef struct&#123;    int data[MAXSIZE];    int length;&#125; Sqlist;void HeapAdjust(Sqlist &amp;L, int s, int m)&#x2F;&#x2F; s: 待调整的子树根节点下标  m：最后一个元素的下标（调整范围上限）&#123;    int rc &#x3D; L.data[s];    &#x2F;&#x2F; 沿关键字较大的子节点向下筛选    for (int j &#x3D; 2 * s + 1; j &lt;&#x3D; m; j &#x3D; 2 * j + 1) &#x2F;&#x2F; 完全二叉树 左孩子下标2k+1    &#123;        &#x2F;&#x2F; 比较左右孩子，j指向较大的孩子        if (j &lt; m &amp;&amp; L.data[j] &lt; L.data[j + 1])            j &#x3D; j + 1; &#x2F;&#x2F; 右孩子更大，j指向右孩子        &#x2F;&#x2F; 若根节点已比最大孩子大，则调整完成        if (rc &gt;&#x3D; L.data[j])            break;        L.data[s] &#x3D; L.data[j]; &#x2F;&#x2F; 将较大孩子值上移        s &#x3D; j;                 &#x2F;&#x2F; s指向下一层待比较位置    &#125;    L.data[s] &#x3D; rc; &#x2F;&#x2F; 将最初根节点值放入最终位置&#125;void CreateHeap(Sqlist &amp;L)&#123;    &#x2F;&#x2F; 从最后一个非叶子节点开始向前调整    for (int i &#x3D; L.length &#x2F; 2 - 1; i &gt;&#x3D; 0; i--)    &#123;        HeapAdjust(L, i, L.length - 1); &#x2F;&#x2F; 调整以i为根的子树    &#125;&#125;void HeapSort(Sqlist &amp;L)&#123;    CreateHeap(L);    for (int i &#x3D; L.length - 1; i &gt; 0; i--)    &#123;        swap(L.data[0], L.data[i]); &#x2F;&#x2F; 堆顶最大值交换到末尾        HeapAdjust(L, 0, i - 1);    &#x2F;&#x2F; 调整剩余元素为新堆    &#125;&#125;</code></pre><p><strong>归并排序</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100typedef struct&#123;    int data[MAXSIZE];    int length;&#125; Sqlist;void Merge(Sqlist &amp;L, int low, int mid, int high)&#123;    int *temp &#x3D; new int[high - low + 1];    int i &#x3D; low;     &#x2F;&#x2F; 左半部分起始索引    int j &#x3D; mid + 1; &#x2F;&#x2F; 右半部分起始索引    int k &#x3D; 0;       &#x2F;&#x2F; 临时数组索引    &#x2F;&#x2F; 合并元素到临时数组    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; high)    &#123;        if (L.data[i] &lt;&#x3D; L.data[j])            temp[k++] &#x3D; L.data[i++];        else            temp[k++] &#x3D; L.data[j++];    &#125;    &#x2F;&#x2F; 处理剩余元素    while (i &lt;&#x3D; mid)        temp[k++] &#x3D; L.data[i++];    while (j &lt;&#x3D; high)        temp[k++] &#x3D; L.data[j++];    &#x2F;&#x2F; 将排序好的数据拷贝回原数组    for (i &#x3D; low, k &#x3D; 0; i &lt;&#x3D; high; i++, k++)        L.data[i] &#x3D; temp[k];    delete[] temp; &#x2F;&#x2F; 释放临时数组&#125;&#x2F;&#x2F; 递归分治函数void MSort(Sqlist &amp;L, int low, int high)&#123;    if (low &lt; high)    &#123;        int mid &#x3D; (low + high) &#x2F; 2; &#x2F;&#x2F; 计算中间位置        MSort(L, low, mid);         &#x2F;&#x2F; 递归左半部分        MSort(L, mid + 1, high);    &#x2F;&#x2F; 递归右半部分        Merge(L, low, mid, high);   &#x2F;&#x2F; 合并已排序部分    &#125;&#125;&#x2F;&#x2F; 归并排序入口函数void MergeSort(Sqlist &amp;L)&#123;    if (L.length &lt;&#x3D; 0)        return;    MSort(L, 0, L.length - 1); &#x2F;&#x2F; 调用递归排序&#125;</code></pre><p><strong>基数排序</strong></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100typedef struct&#123;    int data[MAXSIZE];    int length;&#125; Sqlist;&#x2F;&#x2F; 以位数比较为例void RadixSort(Sqlist &amp;L)&#123;    if (L-&gt;length &lt;&#x3D; 1)        return;    int max_num &#x3D; L-&gt;data[0];    for (int i &#x3D; 1; i &lt; L-&gt;length; ++i)    &#123;        if (L-&gt;data[i] &gt; max_num)            max_num &#x3D; L-&gt;data[i];    &#125;    for (int exp &#x3D; 1; max_num &#x2F; exp &gt; 0; exp *&#x3D; 10)    &#123;        int count[10] &#x3D; &#123;0&#125;;        int output[MAXSIZE];        for (int i &#x3D; 0; i &lt; L-&gt;length; ++i)        &#123;            int digit &#x3D; (L-&gt;data[i] &#x2F; exp) % 10;            count[digit]++;        &#125;        for (int j &#x3D; 1; j &lt; 10; ++j)        &#123;            count[j] +&#x3D; count[j - 1];        &#125;        for (int i &#x3D; L-&gt;length - 1; i &gt;&#x3D; 0; --i)        &#123;            int digit &#x3D; (L-&gt;data[i] &#x2F; exp) % 10;            output[count[digit] - 1] &#x3D; L-&gt;data[i];            count[digit]--;        &#125;        for (int i &#x3D; 0; i &lt; L-&gt;length; ++i)        &#123;            L-&gt;data[i] &#x3D; output[i];        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;data-structure&quot;&gt;Data Structure&lt;/h1&gt;
&lt;h2 id=&quot;线性表&quot;&gt;线性表&lt;/h2&gt;
&lt;h3 id=&quot;顺序表&quot;&gt;顺序表&lt;/h3&gt;
&lt;pre class=&quot;language-c++&quot; data-language=&quot;c++&quot;&gt;&lt;co</summary>
      
    
    
    
    <category term="笔记" scheme="https://saintcen.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="CS基础" scheme="https://saintcen.github.io/tags/CS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Blog</title>
    <link href="https://saintcen.github.io/2025/09/25/Hexo-Blog/"/>
    <id>https://saintcen.github.io/2025/09/25/Hexo-Blog/</id>
    <published>2025-09-24T16:00:00.000Z</published>
    <updated>2025-09-25T11:23:30.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo博客搭建教程">Hexo博客搭建教程</h1><p><img src="/2025/09/25/Hexo-Blog/1.png"></p><h2 id="参考资料">参考资料</h2><p>官方文档：<a href="https://hexo.io/zh-cn/docs/configuration">配置 |Hexo</a></p><p>大佬的博客1：<a href="https://bg51717.github.io/13640/">Hexo+Github搭建个人Wiki风格博客| Blogs</a></p><p>大佬的博客2：[<a href="https://aiyoja.github.io/20220704/">三万字教程]基于Hexo的matery主题搭建博客并深度优化一站式完全教程- 游颜色</a></p><h2 id="配置流程">配置流程</h2><h2 id="问题记录">问题记录</h2><pre class="language-none"><code class="language-none">Uncaught TypeError: $(...).lightGallery is not a function</code></pre><p><a href="https://cloud.tencent.com/developer/ask/sof/113583944">Uncaught：$(.).lightGallery不是函数-腾讯云开发者社区-腾讯云</a></p><p>把本地硬编码替换成<code>cdn</code>，并且修改<code>main-style.ejs</code>的引用。</p><pre class="language-none"><code class="language-none">&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;&lt;%- theme.libs.css.lightgallery %&gt;&quot;&gt;</code></pre><h2 id="美化建议">美化建议</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hexo博客搭建教程&quot;&gt;Hexo博客搭建教程&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2025/09/25/Hexo-Blog/1.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://hexo.</summary>
      
    
    
    
    <category term="教程" scheme="https://saintcen.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="开发" scheme="https://saintcen.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>MoeCTF2025_Misc_wp</title>
    <link href="https://saintcen.github.io/2025/01/09/MoeCTF2025_Misc_wp/"/>
    <id>https://saintcen.github.io/2025/01/09/MoeCTF2025_Misc_wp/</id>
    <published>2025-01-08T16:00:00.000Z</published>
    <updated>2025-09-25T11:15:48.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="moectf2025_misc">MoeCTF2025_Misc</h1><blockquote><p>工具大赛罢了</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;moectf2025_misc&quot;&gt;MoeCTF2025_Misc&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;工具大赛罢了&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="笔记" scheme="https://saintcen.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="CTF" scheme="https://saintcen.github.io/tags/CTF/"/>
    
  </entry>
  
</feed>
